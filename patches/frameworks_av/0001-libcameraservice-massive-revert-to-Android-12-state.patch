From 44e692f85cf11aa208d13ffeb1fbd07af6322a13 Mon Sep 17 00:00:00 2001
From: Yaroslav Zviezda <acroreiser@gmail.com>
Date: Sun, 18 Sep 2022 19:08:10 +0300
Subject: [PATCH 03/20] libcameraservice: massive revert to Android 12 state.

    Needed to restore HAL1.

Change-Id: I737aa1c748c954ffebeefb5d9a00d84f35b1ff05
---
 camera/Android.bp                             |    2 -
 camera/CameraSessionStats.cpp                 |   79 +-
 camera/CameraUtils.cpp                        |   28 +-
 .../aidl/android/hardware/ICameraService.aidl |   14 -
 .../hardware/ICameraServiceListener.aidl      |    2 -
 .../camera2/ICameraInjectionCallback.aidl     |   44 -
 .../camera2/ICameraInjectionSession.aidl      |   23 -
 camera/camera2/CaptureRequest.cpp             |   22 -
 camera/camera2/OutputConfiguration.cpp        |   80 +-
 camera/cameraserver/Android.bp                |    1 -
 camera/include/camera/CameraSessionStats.h    |   32 +-
 camera/include/camera/CameraUtils.h           |    5 +-
 .../include/camera/camera2/CaptureRequest.h   |    2 -
 .../camera/camera2/OutputConfiguration.h      |   40 +-
 camera/ndk/impl/ACameraManager.h              |    3 -
 .../include/camera/NdkCameraMetadataTags.h    |  682 +-----
 camera/ndk/ndk_vendor/impl/ACameraDevice.cpp  |   41 +-
 camera/ndk/ndk_vendor/impl/utils.h            |   26 +-
 camera/tests/CameraBinderTests.cpp            |    6 -
 media/ndk/NdkImage.cpp                        |    7 +-
 services/camera/libcameraservice/Android.bp   |   44 +-
 .../libcameraservice/CameraFlashlight.cpp     |   71 +-
 .../libcameraservice/CameraFlashlight.h       |   16 -
 .../camera/libcameraservice/CameraService.cpp |  796 ++----
 .../camera/libcameraservice/CameraService.h   |  146 +-
 .../CameraServiceWatchdog.cpp                 |   92 -
 .../libcameraservice/CameraServiceWatchdog.h  |  121 -
 .../libcameraservice/api1/Camera2Client.cpp   |   41 +-
 .../libcameraservice/api1/Camera2Client.h     |    9 -
 .../api1/client2/JpegProcessor.cpp            |   18 +-
 .../api1/client2/Parameters.cpp               |   53 +-
 .../api1/client2/Parameters.h                 |    8 +-
 .../api2/CameraDeviceClient.cpp               |  230 +-
 .../api2/CameraDeviceClient.h                 |   18 +-
 .../api2/CameraOfflineSessionClient.cpp       |   16 +-
 .../api2/CameraOfflineSessionClient.h         |    8 +-
 .../api2/DepthCompositeStream.cpp             |   19 +-
 .../api2/HeicCompositeStream.cpp              |   30 +-
 .../common/Camera2ClientBase.cpp              |   70 +-
 .../common/Camera2ClientBase.h                |   32 +-
 .../common/CameraDeviceBase.h                 |   38 +-
 .../common/CameraOfflineSessionBase.h         |    3 +-
 .../common/CameraProviderInfoTemplated.h      |  112 -
 .../common/CameraProviderManager.cpp          | 1909 +++++++++------
 .../common/CameraProviderManager.h            |  491 ++--
 .../common/DepthPhotoProcessor.cpp            |    4 -
 .../common/HalConversionsTemplated.h          |   97 -
 .../common/aidl/AidlProviderInfo.cpp          |  832 -------
 .../common/aidl/AidlProviderInfo.h            |  168 --
 .../common/hidl/HidlProviderInfo.cpp          | 1050 --------
 .../common/hidl/HidlProviderInfo.h            |  136 --
 .../libcameraservice/device3/BufferUtils.cpp  |   10 +
 .../libcameraservice/device3/BufferUtils.h    |    3 +
 .../device3/Camera3Device.cpp                 | 2143 ++++++++++++++---
 .../libcameraservice/device3/Camera3Device.h  |  302 ++-
 .../device3/Camera3DeviceInjectionMethods.cpp |  121 +
 .../device3/Camera3FakeStream.cpp             |    6 +-
 .../device3/Camera3FakeStream.h               |    7 +-
 .../device3/Camera3IOStreamBase.cpp           |   14 +-
 .../device3/Camera3IOStreamBase.h             |    8 +-
 .../device3/Camera3InputStream.cpp            |    5 +-
 .../device3/Camera3InputStream.h              |    1 -
 .../device3/Camera3OfflineSession.cpp         |  190 +-
 .../device3/Camera3OfflineSession.h           |   48 +-
 .../device3/Camera3OutputStream.cpp           |  356 +--
 .../device3/Camera3OutputStream.h             |   93 +-
 .../device3/Camera3OutputStreamInterface.h    |   10 +-
 .../device3/Camera3OutputUtils.cpp            |  518 +++-
 .../device3/Camera3OutputUtils.h              |   27 +-
 .../device3/Camera3OutputUtilsTemplated.h     |  349 ---
 .../device3/Camera3SharedOutputStream.cpp     |   24 +-
 .../device3/Camera3SharedOutputStream.h       |    9 +-
 .../device3/Camera3Stream.cpp                 |   83 +-
 .../libcameraservice/device3/Camera3Stream.h  |   18 +-
 .../device3/Camera3StreamInterface.h          |   59 +-
 .../device3/Camera3StreamSplitter.cpp         |   17 +-
 .../device3/Camera3StreamSplitter.h           |    9 +-
 .../device3/DistortionMapper.cpp              |    2 +-
 .../device3/InFlightRequest.h                 |   19 +-
 .../device3/PreviewFrameScheduler.cpp         |  210 ++
 .../device3/PreviewFrameScheduler.h           |  108 +
 .../device3/PreviewFrameSpacer.cpp            |  131 -
 .../device3/PreviewFrameSpacer.h              |   94 -
 .../device3/ZoomRatioMapper.cpp               |    2 +-
 .../device3/aidl/AidlCamera3Device.cpp        | 1583 ------------
 .../device3/aidl/AidlCamera3Device.h          |  273 ---
 .../aidl/AidlCamera3OfflineSession.cpp        |  247 --
 .../device3/aidl/AidlCamera3OfflineSession.h  |  136 --
 .../device3/aidl/AidlCamera3OutputUtils.cpp   |  343 ---
 .../device3/aidl/AidlCamera3OutputUtils.h     |  100 -
 .../device3/hidl/HidlCamera3Device.cpp        | 1856 --------------
 .../device3/hidl/HidlCamera3Device.h          |  237 --
 .../hidl/HidlCamera3OfflineSession.cpp        |  235 --
 .../device3/hidl/HidlCamera3OfflineSession.h  |  109 -
 .../device3/hidl/HidlCamera3OutputUtils.cpp   |  261 --
 .../device3/hidl/HidlCamera3OutputUtils.h     |   74 -
 .../hidl/AidlCameraServiceListener.cpp        |    5 -
 .../hidl/AidlCameraServiceListener.h          |    2 -
 .../libcameraservice_fuzzer/Android.bp        |    1 -
 .../camera_service_fuzzer.cpp                 |    6 -
 .../camera/libcameraservice/tests/Android.bp  |   15 +-
 .../tests/CameraProviderManagerTest.cpp       |   10 +-
 .../libcameraservice/tests/NV12Compressor.h   |    1 -
 .../tests/PreviewSchedulerTest.cpp            |  213 ++
 .../utils/CameraServiceProxyWrapper.cpp       |   19 +-
 .../utils/CameraServiceProxyWrapper.h         |    6 +-
 .../libcameraservice/utils/ClientManager.h    |   12 +-
 .../libcameraservice/utils/IPCTransport.h     |   26 -
 .../utils/SessionConfigurationUtils.cpp       |  572 ++---
 .../utils/SessionConfigurationUtils.h         |  163 +-
 .../utils/SessionConfigurationUtilsHidl.cpp   |  156 --
 .../utils/SessionConfigurationUtilsHidl.h     |   52 -
 .../utils/SessionConfigurationUtilsHost.cpp   |   96 -
 .../utils/SessionConfigurationUtilsHost.h     |   36 -
 .../utils/SessionStatsBuilder.cpp             |    1 -
 .../utils/SessionStatsBuilder.h               |    1 -
 116 files changed, 5682 insertions(+), 13978 deletions(-)
 delete mode 100644 camera/aidl/android/hardware/camera2/ICameraInjectionCallback.aidl
 delete mode 100644 camera/aidl/android/hardware/camera2/ICameraInjectionSession.aidl
 delete mode 100644 services/camera/libcameraservice/CameraServiceWatchdog.cpp
 delete mode 100644 services/camera/libcameraservice/CameraServiceWatchdog.h
 delete mode 100644 services/camera/libcameraservice/common/CameraProviderInfoTemplated.h
 delete mode 100644 services/camera/libcameraservice/common/HalConversionsTemplated.h
 delete mode 100644 services/camera/libcameraservice/common/aidl/AidlProviderInfo.cpp
 delete mode 100644 services/camera/libcameraservice/common/aidl/AidlProviderInfo.h
 delete mode 100644 services/camera/libcameraservice/common/hidl/HidlProviderInfo.cpp
 delete mode 100644 services/camera/libcameraservice/common/hidl/HidlProviderInfo.h
 delete mode 100644 services/camera/libcameraservice/device3/Camera3OutputUtilsTemplated.h
 create mode 100644 services/camera/libcameraservice/device3/PreviewFrameScheduler.cpp
 create mode 100644 services/camera/libcameraservice/device3/PreviewFrameScheduler.h
 delete mode 100644 services/camera/libcameraservice/device3/PreviewFrameSpacer.cpp
 delete mode 100644 services/camera/libcameraservice/device3/PreviewFrameSpacer.h
 delete mode 100644 services/camera/libcameraservice/device3/aidl/AidlCamera3Device.cpp
 delete mode 100644 services/camera/libcameraservice/device3/aidl/AidlCamera3Device.h
 delete mode 100644 services/camera/libcameraservice/device3/aidl/AidlCamera3OfflineSession.cpp
 delete mode 100644 services/camera/libcameraservice/device3/aidl/AidlCamera3OfflineSession.h
 delete mode 100644 services/camera/libcameraservice/device3/aidl/AidlCamera3OutputUtils.cpp
 delete mode 100644 services/camera/libcameraservice/device3/aidl/AidlCamera3OutputUtils.h
 delete mode 100644 services/camera/libcameraservice/device3/hidl/HidlCamera3Device.cpp
 delete mode 100644 services/camera/libcameraservice/device3/hidl/HidlCamera3Device.h
 delete mode 100644 services/camera/libcameraservice/device3/hidl/HidlCamera3OfflineSession.cpp
 delete mode 100644 services/camera/libcameraservice/device3/hidl/HidlCamera3OfflineSession.h
 delete mode 100644 services/camera/libcameraservice/device3/hidl/HidlCamera3OutputUtils.cpp
 delete mode 100644 services/camera/libcameraservice/device3/hidl/HidlCamera3OutputUtils.h
 create mode 100644 services/camera/libcameraservice/tests/PreviewSchedulerTest.cpp
 delete mode 100644 services/camera/libcameraservice/utils/IPCTransport.h
 delete mode 100644 services/camera/libcameraservice/utils/SessionConfigurationUtilsHidl.cpp
 delete mode 100644 services/camera/libcameraservice/utils/SessionConfigurationUtilsHidl.h
 delete mode 100644 services/camera/libcameraservice/utils/SessionConfigurationUtilsHost.cpp
 delete mode 100644 services/camera/libcameraservice/utils/SessionConfigurationUtilsHost.h

diff --git a/camera/Android.bp b/camera/Android.bp
index e44202bfbf..994df62e33 100644
--- a/camera/Android.bp
+++ b/camera/Android.bp
@@ -147,8 +147,6 @@ filegroup {
         "aidl/android/hardware/camera2/ICameraDeviceCallbacks.aidl",
         "aidl/android/hardware/camera2/ICameraDeviceUser.aidl",
         "aidl/android/hardware/camera2/ICameraOfflineSession.aidl",
-        "aidl/android/hardware/camera2/ICameraInjectionCallback.aidl",
-        "aidl/android/hardware/camera2/ICameraInjectionSession.aidl",
     ],
     path: "aidl",
 }
diff --git a/camera/CameraSessionStats.cpp b/camera/CameraSessionStats.cpp
index d1aa36a524..28e037ff94 100644
--- a/camera/CameraSessionStats.cpp
+++ b/camera/CameraSessionStats.cpp
@@ -52,12 +52,6 @@ status_t CameraStreamStats::readFromParcel(const android::Parcel* parcel) {
         return err;
     }
 
-    float maxPreviewFps = 0;
-    if ((err = parcel->readFloat(&maxPreviewFps)) != OK) {
-        ALOGE("%s: Failed to read maxPreviewFps from parcel", __FUNCTION__);
-        return err;
-    }
-
     int dataSpace = 0;
     if ((err = parcel->readInt32(&dataSpace)) != OK) {
         ALOGE("%s: Failed to read dataSpace from parcel", __FUNCTION__);
@@ -118,22 +112,9 @@ status_t CameraStreamStats::readFromParcel(const android::Parcel* parcel) {
         return err;
     }
 
-    int64_t dynamicRangeProfile = ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD;
-    if ((err = parcel->readInt64(&dynamicRangeProfile)) != OK) {
-        ALOGE("%s: Failed to read dynamic range profile type from parcel", __FUNCTION__);
-        return err;
-    }
-
-    int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT;
-    if ((err = parcel->readInt64(&streamUseCase)) != OK) {
-        ALOGE("%s: Failed to read stream use case from parcel", __FUNCTION__);
-        return err;
-    }
-
     mWidth = width;
     mHeight = height;
     mFormat = format;
-    mMaxPreviewFps = maxPreviewFps;
     mDataSpace = dataSpace;
     mUsage = usage;
     mRequestCount = requestCount;
@@ -144,8 +125,6 @@ status_t CameraStreamStats::readFromParcel(const android::Parcel* parcel) {
     mHistogramType = histogramType;
     mHistogramBins = std::move(histogramBins);
     mHistogramCounts = std::move(histogramCounts);
-    mDynamicRangeProfile = dynamicRangeProfile;
-    mStreamUseCase = streamUseCase;
 
     return OK;
 }
@@ -173,11 +152,6 @@ status_t CameraStreamStats::writeToParcel(android::Parcel* parcel) const {
         return err;
     }
 
-    if ((err = parcel->writeFloat(mMaxPreviewFps)) != OK) {
-        ALOGE("%s: Failed to write stream maxPreviewFps!", __FUNCTION__);
-        return err;
-    }
-
     if ((err = parcel->writeInt32(mDataSpace)) != OK) {
         ALOGE("%s: Failed to write stream dataSpace!", __FUNCTION__);
         return err;
@@ -228,16 +202,6 @@ status_t CameraStreamStats::writeToParcel(android::Parcel* parcel) const {
         return err;
     }
 
-    if ((err = parcel->writeInt64(mDynamicRangeProfile)) != OK) {
-        ALOGE("%s: Failed to write dynamic range profile type", __FUNCTION__);
-        return err;
-    }
-
-    if ((err = parcel->writeInt64(mStreamUseCase)) != OK) {
-        ALOGE("%s: Failed to write stream use case!", __FUNCTION__);
-        return err;
-    }
-
     return OK;
 }
 
@@ -259,13 +223,11 @@ CameraSessionStats::CameraSessionStats() :
         mApiLevel(0),
         mIsNdk(false),
         mLatencyMs(-1),
-        mMaxPreviewFps(0),
         mSessionType(0),
         mInternalReconfigure(0),
         mRequestCount(0),
         mResultErrorCount(0),
-        mDeviceError(false),
-        mVideoStabilizationMode(-1) {}
+        mDeviceError(false) {}
 
 CameraSessionStats::CameraSessionStats(const String16& cameraId,
         int facing, int newCameraState, const String16& clientName,
@@ -277,13 +239,11 @@ CameraSessionStats::CameraSessionStats(const String16& cameraId,
                 mApiLevel(apiLevel),
                 mIsNdk(isNdk),
                 mLatencyMs(latencyMs),
-                mMaxPreviewFps(0),
                 mSessionType(0),
                 mInternalReconfigure(0),
                 mRequestCount(0),
                 mResultErrorCount(0),
-                mDeviceError(0),
-                mVideoStabilizationMode(-1) {}
+                mDeviceError(0) {}
 
 status_t CameraSessionStats::readFromParcel(const android::Parcel* parcel) {
     if (parcel == NULL) {
@@ -335,12 +295,6 @@ status_t CameraSessionStats::readFromParcel(const android::Parcel* parcel) {
         return err;
     }
 
-    float maxPreviewFps;
-    if ((err = parcel->readFloat(&maxPreviewFps)) != OK) {
-        ALOGE("%s: Failed to read maxPreviewFps from parcel", __FUNCTION__);
-        return err;
-    }
-
     int32_t sessionType;
     if ((err = parcel->readInt32(&sessionType)) != OK) {
         ALOGE("%s: Failed to read session type from parcel", __FUNCTION__);
@@ -377,18 +331,6 @@ status_t CameraSessionStats::readFromParcel(const android::Parcel* parcel) {
         return err;
     }
 
-    String16 userTag;
-    if ((err = parcel->readString16(&userTag)) != OK) {
-        ALOGE("%s: Failed to read user tag!", __FUNCTION__);
-        return BAD_VALUE;
-    }
-
-    int32_t videoStabilizationMode;
-    if ((err = parcel->readInt32(&videoStabilizationMode)) != OK) {
-        ALOGE("%s: Failed to read video stabilization mode from parcel", __FUNCTION__);
-        return err;
-    }
-
     mCameraId = id;
     mFacing = facing;
     mNewCameraState = newCameraState;
@@ -396,15 +338,12 @@ status_t CameraSessionStats::readFromParcel(const android::Parcel* parcel) {
     mApiLevel = apiLevel;
     mIsNdk = isNdk;
     mLatencyMs = latencyMs;
-    mMaxPreviewFps = maxPreviewFps;
     mSessionType = sessionType;
     mInternalReconfigure = internalReconfigure;
     mRequestCount = requestCount;
     mResultErrorCount = resultErrorCount;
     mDeviceError = deviceError;
     mStreamStats = std::move(streamStats);
-    mUserTag = userTag;
-    mVideoStabilizationMode = videoStabilizationMode;
 
     return OK;
 }
@@ -452,11 +391,6 @@ status_t CameraSessionStats::writeToParcel(android::Parcel* parcel) const {
         return err;
     }
 
-    if ((err = parcel->writeFloat(mMaxPreviewFps)) != OK) {
-        ALOGE("%s: Failed to write maxPreviewFps!", __FUNCTION__);
-        return err;
-    }
-
     if ((err = parcel->writeInt32(mSessionType)) != OK) {
         ALOGE("%s: Failed to write session type!", __FUNCTION__);
         return err;
@@ -487,15 +421,6 @@ status_t CameraSessionStats::writeToParcel(android::Parcel* parcel) const {
         return err;
     }
 
-    if ((err = parcel->writeString16(mUserTag)) != OK) {
-        ALOGE("%s: Failed to write user tag!", __FUNCTION__);
-        return err;
-    }
-
-    if ((err = parcel->writeInt32(mVideoStabilizationMode)) != OK) {
-        ALOGE("%s: Failed to write video stabilization mode!", __FUNCTION__);
-        return err;
-    }
     return OK;
 }
 
diff --git a/camera/CameraUtils.cpp b/camera/CameraUtils.cpp
index 34737806eb..af3c492762 100644
--- a/camera/CameraUtils.cpp
+++ b/camera/CameraUtils.cpp
@@ -18,7 +18,6 @@
 //#define LOG_NDEBUG 0
 
 #include <camera/CameraUtils.h>
-#include <camera/camera2/OutputConfiguration.h>
 #include <media/hardware/HardwareAPI.h>
 
 #include <android-base/properties.h>
@@ -32,7 +31,7 @@ namespace android {
 const char *kCameraServiceDisabledProperty = "config.disable_cameraservice";
 
 status_t CameraUtils::getRotationTransform(const CameraMetadata& staticInfo,
-        int mirrorMode, /*out*/int32_t* transform) {
+                /*out*/int32_t* transform) {
     ALOGV("%s", __FUNCTION__);
 
     if (transform == NULL) {
@@ -56,18 +55,9 @@ status_t CameraUtils::getRotationTransform(const CameraMetadata& staticInfo,
 
     int32_t& flags = *transform;
 
-    int32_t mirror = 0;
-    if (mirrorMode == OutputConfiguration::MIRROR_MODE_AUTO &&
-            entryFacing.data.u8[0] == ANDROID_LENS_FACING_FRONT) {
-        mirror = NATIVE_WINDOW_TRANSFORM_FLIP_H;
-    } else if (mirrorMode == OutputConfiguration::MIRROR_MODE_H) {
-        mirror = NATIVE_WINDOW_TRANSFORM_FLIP_H;
-    } else if (mirrorMode == OutputConfiguration::MIRROR_MODE_V) {
-        mirror = NATIVE_WINDOW_TRANSFORM_FLIP_V;
-    }
-
+    bool mirror = (entryFacing.data.u8[0] == ANDROID_LENS_FACING_FRONT);
     int orientation = entry.data.i32[0];
-    if (mirror == 0) {
+    if (!mirror) {
         switch (orientation) {
             case 0:
                 flags = 0;
@@ -87,25 +77,25 @@ status_t CameraUtils::getRotationTransform(const CameraMetadata& staticInfo,
                 return INVALID_OPERATION;
         }
     } else {
-        // - Front camera needs to be horizontally flipped for mirror-like behavior.
-        // - Application-specified mirroring needs to be applied.
+        // Front camera needs to be horizontally flipped for mirror-like behavior.
         // Note: Flips are applied before rotates; using XOR here as some of these flags are
         // composed in terms of other flip/rotation flags, and are not bitwise-ORable.
         switch (orientation) {
             case 0:
-                flags = mirror;
+                flags = NATIVE_WINDOW_TRANSFORM_FLIP_H;
                 break;
             case 90:
-                flags = mirror ^
+                flags = NATIVE_WINDOW_TRANSFORM_FLIP_H ^
                         NATIVE_WINDOW_TRANSFORM_ROT_270;
                 break;
             case 180:
-                flags = mirror ^
+                flags = NATIVE_WINDOW_TRANSFORM_FLIP_H ^
                         NATIVE_WINDOW_TRANSFORM_ROT_180;
                 break;
             case 270:
-                flags = mirror ^
+                flags = NATIVE_WINDOW_TRANSFORM_FLIP_H ^
                         NATIVE_WINDOW_TRANSFORM_ROT_90;
+
                 break;
             default:
                 ALOGE("%s: Invalid HAL android.sensor.orientation value: %d",
diff --git a/camera/aidl/android/hardware/ICameraService.aidl b/camera/aidl/android/hardware/ICameraService.aidl
index 1e748c7540..9ded2215e8 100644
--- a/camera/aidl/android/hardware/ICameraService.aidl
+++ b/camera/aidl/android/hardware/ICameraService.aidl
@@ -20,8 +20,6 @@ import android.hardware.ICamera;
 import android.hardware.ICameraClient;
 import android.hardware.camera2.ICameraDeviceUser;
 import android.hardware.camera2.ICameraDeviceCallbacks;
-import android.hardware.camera2.ICameraInjectionCallback;
-import android.hardware.camera2.ICameraInjectionSession;
 import android.hardware.camera2.params.VendorTagDescriptor;
 import android.hardware.camera2.params.VendorTagDescriptorCache;
 import android.hardware.camera2.utils.ConcurrentCameraIdCombination;
@@ -167,19 +165,9 @@ interface ICameraService
     boolean supportsCameraApi(String cameraId, int apiVersion);
     // Determines if a cameraId is a hidden physical camera of a logical multi-camera.
     boolean isHiddenPhysicalCamera(String cameraId);
-    // Inject the external camera to replace the internal camera session.
-    ICameraInjectionSession injectCamera(String packageName, String internalCamId,
-            String externalCamId, in ICameraInjectionCallback CameraInjectionCallback);
 
     void setTorchMode(String cameraId, boolean enabled, IBinder clientBinder);
 
-    // Change the brightness level of the flash unit associated with cameraId to strengthLevel.
-    // If the torch is in OFF state and strengthLevel > 0 then the torch will also be turned ON.
-    void turnOnTorchWithStrengthLevel(String cameraId, int strengthLevel, IBinder clientBinder);
-
-    // Get the brightness level of the flash unit associated with cameraId.
-    int getTorchStrengthLevel(String cameraId);
-
     /**
      * Notify the camera service of a system event.  Should only be called from system_server.
      *
@@ -187,8 +175,6 @@ interface ICameraService
      */
     const int EVENT_NONE = 0;
     const int EVENT_USER_SWITCHED = 1; // The argument is the set of new foreground user IDs.
-    const int EVENT_USB_DEVICE_ATTACHED = 2; // The argument is the deviceId and vendorId
-    const int EVENT_USB_DEVICE_DETACHED = 3; // The argument is the deviceId and vendorId
     oneway void notifySystemEvent(int eventId, in int[] args);
 
     /**
diff --git a/camera/aidl/android/hardware/ICameraServiceListener.aidl b/camera/aidl/android/hardware/ICameraServiceListener.aidl
index 5f17f5be59..c54813c8b2 100644
--- a/camera/aidl/android/hardware/ICameraServiceListener.aidl
+++ b/camera/aidl/android/hardware/ICameraServiceListener.aidl
@@ -83,8 +83,6 @@ interface ICameraServiceListener
 
     oneway void onTorchStatusChanged(int status, String cameraId);
 
-    oneway void onTorchStrengthLevelChanged(String cameraId, int newTorchStrength);
-
     /**
      * Notify registered clients about camera access priority changes.
      * Clients which were previously unable to open a certain camera device
diff --git a/camera/aidl/android/hardware/camera2/ICameraInjectionCallback.aidl b/camera/aidl/android/hardware/camera2/ICameraInjectionCallback.aidl
deleted file mode 100644
index 9791352c2b..0000000000
--- a/camera/aidl/android/hardware/camera2/ICameraInjectionCallback.aidl
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.camera2;
-
-import android.hardware.camera2.ICameraInjectionSession;
-
-/**
- * Binder interface used to call back the error state injected by the external camera,
- * and camera service can be switched back to internal camera when binder signals process death.
- *
- * @hide
- */
-interface ICameraInjectionCallback
-{
-    // Error codes for onInjectionError
-    // To indicate all invalid error codes
-    const int ERROR_INJECTION_INVALID_ERROR = -1;
-    // To indicate the camera injection session has encountered a fatal error, such as injection
-    // init failure, configure failure or injecting failure etc.
-    const int ERROR_INJECTION_SESSION = 0;
-    // To indicate the camera service has encountered a fatal error.
-    const int ERROR_INJECTION_SERVICE = 1;
-    // To indicate the injection camera does not support certain camera functions, such as
-    // unsupport stream format, no capture/record function or no multi-camera function etc.
-    // When this error occurs, the default processing is still in the inject state, and the app is
-    // notified to display an error message and a black screen.
-    const int ERROR_INJECTION_UNSUPPORTED = 2;
-
-    oneway void onInjectionError(int errorCode);
-}
diff --git a/camera/aidl/android/hardware/camera2/ICameraInjectionSession.aidl b/camera/aidl/android/hardware/camera2/ICameraInjectionSession.aidl
deleted file mode 100644
index c31c30bcad..0000000000
--- a/camera/aidl/android/hardware/camera2/ICameraInjectionSession.aidl
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.hardware.camera2;
-
-/** @hide */
-interface ICameraInjectionSession
-{
-    oneway void stopInjection();
-}
diff --git a/camera/camera2/CaptureRequest.cpp b/camera/camera2/CaptureRequest.cpp
index 7a8a4bae41..ebc09d7429 100644
--- a/camera/camera2/CaptureRequest.cpp
+++ b/camera/camera2/CaptureRequest.cpp
@@ -146,20 +146,6 @@ status_t CaptureRequest::readFromParcel(const android::Parcel* parcel) {
         mSurfaceIdxList.push_back(surfaceIdx);
     }
 
-    int32_t hasUserTag;
-    if ((err = parcel->readInt32(&hasUserTag)) != OK) {
-        ALOGE("%s: Failed to read user tag availability flag", __FUNCTION__);
-        return BAD_VALUE;
-    }
-    if (hasUserTag) {
-        String16 userTag;
-        if ((err = parcel->readString16(&userTag)) != OK) {
-            ALOGE("%s: Failed to read user tag!", __FUNCTION__);
-            return BAD_VALUE;
-        }
-        mUserTag = String8(userTag).c_str();
-    }
-
     return OK;
 }
 
@@ -227,14 +213,6 @@ status_t CaptureRequest::writeToParcel(android::Parcel* parcel) const {
             return err;
         }
     }
-
-    if (mUserTag.empty()) {
-        parcel->writeInt32(0);
-    } else {
-        parcel->writeInt32(1);
-        parcel->writeString16(String16(mUserTag.c_str()));
-    }
-
     return OK;
 }
 
diff --git a/camera/camera2/OutputConfiguration.cpp b/camera/camera2/OutputConfiguration.cpp
index 11d4960dbc..2bccd870b8 100644
--- a/camera/camera2/OutputConfiguration.cpp
+++ b/camera/camera2/OutputConfiguration.cpp
@@ -23,7 +23,6 @@
 #include <camera/camera2/OutputConfiguration.h>
 #include <binder/Parcel.h>
 #include <gui/view/Surface.h>
-#include <system/camera_metadata.h>
 #include <utils/String8.h>
 
 namespace android {
@@ -77,22 +76,6 @@ const std::vector<int32_t> &OutputConfiguration::getSensorPixelModesUsed() const
     return mSensorPixelModesUsed;
 }
 
-int64_t OutputConfiguration::getDynamicRangeProfile() const {
-    return mDynamicRangeProfile;
-}
-
-int64_t OutputConfiguration::getStreamUseCase() const {
-    return mStreamUseCase;
-}
-
-int OutputConfiguration::getTimestampBase() const {
-    return mTimestampBase;
-}
-
-int OutputConfiguration::getMirrorMode() const {
-    return mMirrorMode;
-}
-
 OutputConfiguration::OutputConfiguration() :
         mRotation(INVALID_ROTATION),
         mSurfaceSetID(INVALID_SET_ID),
@@ -101,11 +84,7 @@ OutputConfiguration::OutputConfiguration() :
         mHeight(0),
         mIsDeferred(false),
         mIsShared(false),
-        mIsMultiResolution(false),
-        mDynamicRangeProfile(ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD),
-        mStreamUseCase(ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT),
-        mTimestampBase(TIMESTAMP_BASE_DEFAULT),
-        mMirrorMode(MIRROR_MODE_AUTO) {
+        mIsMultiResolution(false) {
 }
 
 OutputConfiguration::OutputConfiguration(const android::Parcel& parcel) :
@@ -186,30 +165,6 @@ status_t OutputConfiguration::readFromParcel(const android::Parcel* parcel) {
         ALOGE("%s: Failed to read sensor pixel mode(s) from parcel", __FUNCTION__);
         return err;
     }
-    int64_t dynamicProfile;
-    if ((err = parcel->readInt64(&dynamicProfile)) != OK) {
-        ALOGE("%s: Failed to read surface dynamic range profile flag from parcel", __FUNCTION__);
-        return err;
-    }
-
-    int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT;
-    if ((err = parcel->readInt64(&streamUseCase)) != OK) {
-        ALOGE("%s: Failed to read stream use case from parcel", __FUNCTION__);
-        return err;
-    }
-
-    int timestampBase = TIMESTAMP_BASE_DEFAULT;
-    if ((err = parcel->readInt32(&timestampBase)) != OK) {
-        ALOGE("%s: Failed to read timestamp base from parcel", __FUNCTION__);
-        return err;
-    }
-
-    int mirrorMode = MIRROR_MODE_AUTO;
-    if ((err = parcel->readInt32(&mirrorMode)) != OK) {
-        ALOGE("%s: Failed to read mirroring mode from parcel", __FUNCTION__);
-        return err;
-    }
-
     mRotation = rotation;
     mSurfaceSetID = setID;
     mSurfaceType = surfaceType;
@@ -218,9 +173,6 @@ status_t OutputConfiguration::readFromParcel(const android::Parcel* parcel) {
     mIsDeferred = isDeferred != 0;
     mIsShared = isShared != 0;
     mIsMultiResolution = isMultiResolution != 0;
-    mStreamUseCase = streamUseCase;
-    mTimestampBase = timestampBase;
-    mMirrorMode = mirrorMode;
     for (auto& surface : surfaceShims) {
         ALOGV("%s: OutputConfiguration: %p, name %s", __FUNCTION__,
                 surface.graphicBufferProducer.get(),
@@ -229,14 +181,10 @@ status_t OutputConfiguration::readFromParcel(const android::Parcel* parcel) {
     }
 
     mSensorPixelModesUsed = std::move(sensorPixelModesUsed);
-    mDynamicRangeProfile = dynamicProfile;
 
     ALOGV("%s: OutputConfiguration: rotation = %d, setId = %d, surfaceType = %d,"
-          " physicalCameraId = %s, isMultiResolution = %d, streamUseCase = %" PRId64
-          ", timestampBase = %d, mirrorMode = %d",
-          __FUNCTION__, mRotation, mSurfaceSetID, mSurfaceType,
-          String8(mPhysicalCameraId).string(), mIsMultiResolution, mStreamUseCase, timestampBase,
-          mMirrorMode);
+          " physicalCameraId = %s, isMultiResolution = %d", __FUNCTION__, mRotation,
+          mSurfaceSetID, mSurfaceType, String8(mPhysicalCameraId).string(), mIsMultiResolution);
 
     return err;
 }
@@ -251,10 +199,6 @@ OutputConfiguration::OutputConfiguration(sp<IGraphicBufferProducer>& gbp, int ro
     mIsShared = isShared;
     mPhysicalCameraId = physicalId;
     mIsMultiResolution = false;
-    mDynamicRangeProfile = ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD;
-    mStreamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT;
-    mTimestampBase = TIMESTAMP_BASE_DEFAULT;
-    mMirrorMode = MIRROR_MODE_AUTO;
 }
 
 OutputConfiguration::OutputConfiguration(
@@ -263,11 +207,7 @@ OutputConfiguration::OutputConfiguration(
     int width, int height, bool isShared)
   : mGbps(gbps), mRotation(rotation), mSurfaceSetID(surfaceSetID), mSurfaceType(surfaceType),
     mWidth(width), mHeight(height), mIsDeferred(false), mIsShared(isShared),
-    mPhysicalCameraId(physicalCameraId), mIsMultiResolution(false),
-    mDynamicRangeProfile(ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD),
-    mStreamUseCase(ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT),
-    mTimestampBase(TIMESTAMP_BASE_DEFAULT),
-    mMirrorMode(MIRROR_MODE_AUTO) { }
+    mPhysicalCameraId(physicalCameraId), mIsMultiResolution(false) { }
 
 status_t OutputConfiguration::writeToParcel(android::Parcel* parcel) const {
 
@@ -314,18 +254,6 @@ status_t OutputConfiguration::writeToParcel(android::Parcel* parcel) const {
     err = parcel->writeParcelableVector(mSensorPixelModesUsed);
     if (err != OK) return err;
 
-    err = parcel->writeInt64(mDynamicRangeProfile);
-    if (err != OK) return err;
-
-    err = parcel->writeInt64(mStreamUseCase);
-    if (err != OK) return err;
-
-    err = parcel->writeInt32(mTimestampBase);
-    if (err != OK) return err;
-
-    err = parcel->writeInt32(mMirrorMode);
-    if (err != OK) return err;
-
     return OK;
 }
 
diff --git a/camera/cameraserver/Android.bp b/camera/cameraserver/Android.bp
index 094a3c1985..8ca8920012 100644
--- a/camera/cameraserver/Android.bp
+++ b/camera/cameraserver/Android.bp
@@ -43,7 +43,6 @@ cc_binary {
         "android.hardware.camera.provider@2.5",
         "android.hardware.camera.provider@2.6",
         "android.hardware.camera.provider@2.7",
-        "android.hardware.camera.provider-V1-ndk",
         "android.hardware.camera.device@1.0",
         "android.hardware.camera.device@3.2",
         "android.hardware.camera.device@3.4",
diff --git a/camera/include/camera/CameraSessionStats.h b/camera/include/camera/CameraSessionStats.h
index aaa88b2b08..c398acaa02 100644
--- a/camera/include/camera/CameraSessionStats.h
+++ b/camera/include/camera/CameraSessionStats.h
@@ -19,8 +19,6 @@
 
 #include <binder/Parcelable.h>
 
-#include <camera/CameraMetadata.h>
-
 namespace android {
 namespace hardware {
 
@@ -37,7 +35,6 @@ public:
     int mWidth;
     int mHeight;
     int mFormat;
-    float mMaxPreviewFps;
     int mDataSpace;
     int64_t mUsage;
 
@@ -63,26 +60,16 @@ public:
     // size(mHistogramBins) + 1 = size(mHistogramCounts)
     std::vector<int64_t> mHistogramCounts;
 
-    // Dynamic range profile
-    int64_t mDynamicRangeProfile;
-    // Stream use case
-    int64_t mStreamUseCase;
-
     CameraStreamStats() :
-            mWidth(0), mHeight(0), mFormat(0), mMaxPreviewFps(0), mDataSpace(0), mUsage(0),
+            mWidth(0), mHeight(0), mFormat(0), mDataSpace(0), mUsage(0),
             mRequestCount(0), mErrorCount(0), mStartLatencyMs(0),
-            mMaxHalBuffers(0), mMaxAppBuffers(0), mHistogramType(HISTOGRAM_TYPE_UNKNOWN),
-            mDynamicRangeProfile(ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD),
-            mStreamUseCase(ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT) {}
-    CameraStreamStats(int width, int height, int format, float maxPreviewFps, int dataSpace,
-            int64_t usage, int maxHalBuffers, int maxAppBuffers, int dynamicRangeProfile,
-            int streamUseCase)
-            : mWidth(width), mHeight(height), mFormat(format), mMaxPreviewFps(maxPreviewFps),
-              mDataSpace(dataSpace), mUsage(usage), mRequestCount(0), mErrorCount(0),
-              mStartLatencyMs(0), mMaxHalBuffers(maxHalBuffers), mMaxAppBuffers(maxAppBuffers),
-              mHistogramType(HISTOGRAM_TYPE_UNKNOWN),
-              mDynamicRangeProfile(dynamicRangeProfile),
-              mStreamUseCase(streamUseCase) {}
+            mMaxHalBuffers(0), mMaxAppBuffers(0), mHistogramType(HISTOGRAM_TYPE_UNKNOWN) {}
+    CameraStreamStats(int width, int height, int format, int dataSpace, int64_t usage,
+            int maxHalBuffers, int maxAppBuffers)
+            : mWidth(width), mHeight(height), mFormat(format), mDataSpace(dataSpace),
+              mUsage(usage), mRequestCount(0), mErrorCount(0), mStartLatencyMs(0),
+              mMaxHalBuffers(maxHalBuffers), mMaxAppBuffers(maxAppBuffers),
+              mHistogramType(HISTOGRAM_TYPE_UNKNOWN) {}
 
     virtual status_t readFromParcel(const android::Parcel* parcel) override;
     virtual status_t writeToParcel(android::Parcel* parcel) const override;
@@ -124,7 +111,6 @@ public:
     bool mIsNdk;
     // latency in ms for camera open, close, or session creation.
     int mLatencyMs;
-    float mMaxPreviewFps;
 
     // Session info and statistics
     int mSessionType;
@@ -136,8 +122,6 @@ public:
     // Whether the device runs into an error state
     bool mDeviceError;
     std::vector<CameraStreamStats> mStreamStats;
-    String16 mUserTag;
-    int mVideoStabilizationMode;
 
     // Constructors
     CameraSessionStats();
diff --git a/camera/include/camera/CameraUtils.h b/camera/include/camera/CameraUtils.h
index 31d25e79ea..a397ccdd5e 100644
--- a/camera/include/camera/CameraUtils.h
+++ b/camera/include/camera/CameraUtils.h
@@ -37,13 +37,10 @@ class CameraUtils {
          * metadata.  This is based on the sensor orientation and lens facing
          * attributes of the camera device.
          *
-         * If mirrorMode is not AUTO, it will be used to override the lens
-         * facing based mirror.
-         *
          * Returns OK on success, or a negative error code.
          */
         static status_t getRotationTransform(const CameraMetadata& staticInfo,
-                int mirrorMode, /*out*/int32_t* transform);
+                /*out*/int32_t* transform);
 
         /**
          * Check if the image data is VideoNativeHandleMetadata, that contains a native handle.
diff --git a/camera/include/camera/camera2/CaptureRequest.h b/camera/include/camera/camera2/CaptureRequest.h
index 28dbc7cb28..506abab704 100644
--- a/camera/include/camera/camera2/CaptureRequest.h
+++ b/camera/include/camera/camera2/CaptureRequest.h
@@ -63,8 +63,6 @@ struct CaptureRequest : public Parcelable {
 
     void*                   mContext; // arbitrary user context from NDK apps, null for java apps
 
-    std::string             mUserTag; // The string representation of object passed into setTag.
-
     /**
      * Keep impl up-to-date with CaptureRequest.java in frameworks/base
      */
diff --git a/camera/include/camera/camera2/OutputConfiguration.h b/camera/include/camera/camera2/OutputConfiguration.h
index b842885a6b..f80ed3a8e6 100644
--- a/camera/include/camera/camera2/OutputConfiguration.h
+++ b/camera/include/camera/camera2/OutputConfiguration.h
@@ -38,34 +38,16 @@ public:
         SURFACE_TYPE_SURFACE_VIEW = 0,
         SURFACE_TYPE_SURFACE_TEXTURE = 1
     };
-    enum TimestampBaseType {
-        TIMESTAMP_BASE_DEFAULT = 0,
-        TIMESTAMP_BASE_SENSOR = 1,
-        TIMESTAMP_BASE_MONOTONIC = 2,
-        TIMESTAMP_BASE_REALTIME = 3,
-        TIMESTAMP_BASE_CHOREOGRAPHER_SYNCED = 4
-    };
-    enum MirrorModeType {
-        MIRROR_MODE_AUTO = 0,
-        MIRROR_MODE_NONE = 1,
-        MIRROR_MODE_H = 2,
-        MIRROR_MODE_V = 3,
-    };
-
     const std::vector<sp<IGraphicBufferProducer>>& getGraphicBufferProducers() const;
     int                        getRotation() const;
     int                        getSurfaceSetID() const;
     int                        getSurfaceType() const;
     int                        getWidth() const;
     int                        getHeight() const;
-    int64_t                    getDynamicRangeProfile() const;
     bool                       isDeferred() const;
     bool                       isShared() const;
     String16                   getPhysicalCameraId() const;
     bool                       isMultiResolution() const;
-    int64_t                    getStreamUseCase() const;
-    int                        getTimestampBase() const;
-    int                        getMirrorMode() const;
 
     // set of sensor pixel mode resolutions allowed {MAX_RESOLUTION, DEFAULT_MODE};
     const std::vector<int32_t>&            getSensorPixelModesUsed() const;
@@ -107,11 +89,7 @@ public:
                 gbpsEqual(other) &&
                 mPhysicalCameraId == other.mPhysicalCameraId &&
                 mIsMultiResolution == other.mIsMultiResolution &&
-                sensorPixelModesUsedEqual(other) &&
-                mDynamicRangeProfile == other.mDynamicRangeProfile &&
-                mStreamUseCase == other.mStreamUseCase &&
-                mTimestampBase == other.mTimestampBase &&
-                mMirrorMode == other.mMirrorMode);
+                sensorPixelModesUsedEqual(other));
     }
     bool operator != (const OutputConfiguration& other) const {
         return !(*this == other);
@@ -148,18 +126,6 @@ public:
         if (!sensorPixelModesUsedEqual(other)) {
             return sensorPixelModesUsedLessThan(other);
         }
-        if (mDynamicRangeProfile != other.mDynamicRangeProfile) {
-            return mDynamicRangeProfile < other.mDynamicRangeProfile;
-        }
-        if (mStreamUseCase != other.mStreamUseCase) {
-            return mStreamUseCase < other.mStreamUseCase;
-        }
-        if (mTimestampBase != other.mTimestampBase) {
-            return mTimestampBase < other.mTimestampBase;
-        }
-        if (mMirrorMode != other.mMirrorMode) {
-            return mMirrorMode < other.mMirrorMode;
-        }
         return gbpsLessThan(other);
     }
 
@@ -184,10 +150,6 @@ private:
     String16                   mPhysicalCameraId;
     bool                       mIsMultiResolution;
     std::vector<int32_t>       mSensorPixelModesUsed;
-    int64_t                    mDynamicRangeProfile;
-    int64_t                    mStreamUseCase;
-    int                        mTimestampBase;
-    int                        mMirrorMode;
 };
 } // namespace params
 } // namespace camera2
diff --git a/camera/ndk/impl/ACameraManager.h b/camera/ndk/impl/ACameraManager.h
index d53d8099de..da887a26e0 100644
--- a/camera/ndk/impl/ACameraManager.h
+++ b/camera/ndk/impl/ACameraManager.h
@@ -95,9 +95,6 @@ class CameraManagerGlobal final : public RefBase {
         virtual binder::Status onTorchStatusChanged(int32_t, const String16&) {
             return binder::Status::ok();
         }
-        virtual binder::Status onTorchStrengthLevelChanged(const String16&, int32_t) {
-            return binder::Status::ok();
-        }
 
         virtual binder::Status onCameraAccessPrioritiesChanged();
         virtual binder::Status onCameraOpened(const String16&, const String16&) {
diff --git a/camera/ndk/include/camera/NdkCameraMetadataTags.h b/camera/ndk/include/camera/NdkCameraMetadataTags.h
index b6f8552ae1..abc63acd97 100644
--- a/camera/ndk/include/camera/NdkCameraMetadataTags.h
+++ b/camera/ndk/include/camera/NdkCameraMetadataTags.h
@@ -72,8 +72,6 @@ typedef enum acamera_metadata_section {
     ACAMERA_DISTORTION_CORRECTION,
     ACAMERA_HEIC,
     ACAMERA_HEIC_INFO,
-    ACAMERA_AUTOMOTIVE,
-    ACAMERA_AUTOMOTIVE_LENS,
     ACAMERA_SECTION_COUNT,
 
     ACAMERA_VENDOR = 0x8000
@@ -117,8 +115,6 @@ typedef enum acamera_metadata_section_start {
                                                                 << 16,
     ACAMERA_HEIC_START             = ACAMERA_HEIC              << 16,
     ACAMERA_HEIC_INFO_START        = ACAMERA_HEIC_INFO         << 16,
-    ACAMERA_AUTOMOTIVE_START       = ACAMERA_AUTOMOTIVE        << 16,
-    ACAMERA_AUTOMOTIVE_LENS_START  = ACAMERA_AUTOMOTIVE_LENS   << 16,
     ACAMERA_VENDOR_START           = ACAMERA_VENDOR            << 16
 } acamera_metadata_section_start_t;
 
@@ -521,14 +517,6 @@ typedef enum acamera_metadata_tag {
      * region and output only the intersection rectangle as the metering region in the result
      * metadata.  If the region is entirely outside the crop region, it will be ignored and
      * not reported in the result metadata.</p>
-     * <p>When setting the AE metering regions, the application must consider the additional
-     * crop resulted from the aspect ratio differences between the preview stream and
-     * ACAMERA_SCALER_CROP_REGION. For example, if the ACAMERA_SCALER_CROP_REGION is the full
-     * active array size with 4:3 aspect ratio, and the preview stream is 16:9,
-     * the boundary of AE regions will be [0, y_crop] and
-     * [active_width, active_height - 2 * y_crop] rather than [0, 0] and
-     * [active_width, active_height], where y_crop is the additional crop due to aspect ratio
-     * mismatch.</p>
      * <p>Starting from API level 30, the coordinate system of activeArraySize or
      * preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not
      * pre-zoom field of view. This means that the same aeRegions values at different
@@ -730,14 +718,6 @@ typedef enum acamera_metadata_tag {
      * region and output only the intersection rectangle as the metering region in the result
      * metadata. If the region is entirely outside the crop region, it will be ignored and
      * not reported in the result metadata.</p>
-     * <p>When setting the AF metering regions, the application must consider the additional
-     * crop resulted from the aspect ratio differences between the preview stream and
-     * ACAMERA_SCALER_CROP_REGION. For example, if the ACAMERA_SCALER_CROP_REGION is the full
-     * active array size with 4:3 aspect ratio, and the preview stream is 16:9,
-     * the boundary of AF regions will be [0, y_crop] and
-     * [active_width, active_height - 2 * y_crop] rather than [0, 0] and
-     * [active_width, active_height], where y_crop is the additional crop due to aspect ratio
-     * mismatch.</p>
      * <p>Starting from API level 30, the coordinate system of activeArraySize or
      * preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not
      * pre-zoom field of view. This means that the same afRegions values at different
@@ -858,7 +838,7 @@ typedef enum acamera_metadata_tag {
      * routine is enabled, overriding the application's selected
      * ACAMERA_COLOR_CORRECTION_TRANSFORM, ACAMERA_COLOR_CORRECTION_GAINS and
      * ACAMERA_COLOR_CORRECTION_MODE. Note that when ACAMERA_CONTROL_AE_MODE
-     * is OFF, the behavior of AWB is device dependent. It is recommended to
+     * is OFF, the behavior of AWB is device dependent. It is recommened to
      * also set AWB mode to OFF or lock AWB by using ACAMERA_CONTROL_AWB_LOCK before
      * setting AE mode to OFF.</p>
      * <p>When set to the OFF mode, the camera device's auto-white balance
@@ -933,14 +913,6 @@ typedef enum acamera_metadata_tag {
      * region and output only the intersection rectangle as the metering region in the result
      * metadata.  If the region is entirely outside the crop region, it will be ignored and
      * not reported in the result metadata.</p>
-     * <p>When setting the AWB metering regions, the application must consider the additional
-     * crop resulted from the aspect ratio differences between the preview stream and
-     * ACAMERA_SCALER_CROP_REGION. For example, if the ACAMERA_SCALER_CROP_REGION is the full
-     * active array size with 4:3 aspect ratio, and the preview stream is 16:9,
-     * the boundary of AWB regions will be [0, y_crop] and
-     * [active_width, active_height - 2 * y_crop] rather than [0, 0] and
-     * [active_width, active_height], where y_crop is the additional crop due to aspect ratio
-     * mismatch.</p>
      * <p>Starting from API level 30, the coordinate system of activeArraySize or
      * preCorrectionActiveArraySize is used to represent post-zoomRatio field of view, not
      * pre-zoom field of view. This means that the same awbRegions values at different
@@ -989,15 +961,13 @@ typedef enum acamera_metadata_tag {
      *
      * <p>This control (except for MANUAL) is only effective if
      * <code>ACAMERA_CONTROL_MODE != OFF</code> and any 3A routine is active.</p>
-     * <p>All intents are supported by all devices, except that:</p>
-     * <ul>
-     * <li>ZERO_SHUTTER_LAG will be supported if ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains
-     * PRIVATE_REPROCESSING or YUV_REPROCESSING.</li>
-     * <li>MANUAL will be supported if ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains
-     * MANUAL_SENSOR.</li>
-     * <li>MOTION_TRACKING will be supported if ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains
-     * MOTION_TRACKING.</li>
-     * </ul>
+     * <p>All intents are supported by all devices, except that:
+     *   * ZERO_SHUTTER_LAG will be supported if ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains
+     * PRIVATE_REPROCESSING or YUV_REPROCESSING.
+     *   * MANUAL will be supported if ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains
+     * MANUAL_SENSOR.
+     *   * MOTION_TRACKING will be supported if ACAMERA_REQUEST_AVAILABLE_CAPABILITIES contains
+     * MOTION_TRACKING.</p>
      *
      * @see ACAMERA_CONTROL_MODE
      * @see ACAMERA_REQUEST_AVAILABLE_CAPABILITIES
@@ -1120,15 +1090,6 @@ typedef enum acamera_metadata_tag {
      * (ACAMERA_LENS_OPTICAL_STABILIZATION_MODE), turning both modes on may
      * produce undesirable interaction, so it is recommended not to enable
      * both at the same time.</p>
-     * <p>If video stabilization is set to "PREVIEW_STABILIZATION",
-     * ACAMERA_LENS_OPTICAL_STABILIZATION_MODE is overridden. The camera sub-system may choose
-     * to turn on hardware based image stabilization in addition to software based stabilization
-     * if it deems that appropriate.
-     * This key may be a part of the available session keys, which camera clients may
-     * query via
-     * {@link ACameraManager_getCameraCharacteristics }.
-     * If this is the case, changing this key over the life-time of a capture session may
-     * cause delays / glitches.</p>
      *
      * @see ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE
      * @see ACAMERA_LENS_OPTICAL_STABILIZATION_MODE
@@ -1488,7 +1449,7 @@ typedef enum acamera_metadata_tag {
      * Any state (excluding LOCKED) | ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER is START, sequence done | FLASH_REQUIRED | Converged but too dark w/o flash after a precapture sequence, transient states are skipped by camera device.
      * Any state (excluding LOCKED) | ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER is START, sequence done | CONVERGED      | Converged after a precapture sequence, transient states are skipped by camera device.
      * Any state (excluding LOCKED) | ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER is CANCEL, converged    | FLASH_REQUIRED | Converged but too dark w/o flash after a precapture sequence is canceled, transient states are skipped by camera device.
-     * Any state (excluding LOCKED) | ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER is CANCEL, converged    | CONVERGED      | Converged after a precapture sequences canceled, transient states are skipped by camera device.
+     * Any state (excluding LOCKED) | ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER is CANCEL, converged    | CONVERGED      | Converged after a precapture sequenceis canceled, transient states are skipped by camera device.
      * CONVERGED      | Camera device finished AE scan                              | FLASH_REQUIRED | Converged but too dark w/o flash after a new scan, transient states are skipped by camera device.
      * FLASH_REQUIRED | Camera device finished AE scan                              | CONVERGED      | Converged after a new scan, transient states are skipped by camera device.</p>
      *
@@ -1724,7 +1685,7 @@ typedef enum acamera_metadata_tag {
      * </ul></p>
      *
      * <p>Devices support post RAW sensitivity boost  will advertise
-     * ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST key for controlling
+     * ACAMERA_CONTROL_POST_RAW_SENSITIVITY_BOOST key for controling
      * post RAW sensitivity boost.</p>
      * <p>This key will be <code>null</code> for devices that do not support any RAW format
      * outputs. For devices that do support RAW format outputs, this key will always
@@ -2195,15 +2156,15 @@ typedef enum acamera_metadata_tag {
      *
      * <p>If this value is greater than 1, then the device supports controlling the
      * flashlight brightness level via
-     * <a href="https://developer.android.com/reference/android/hardware/camera2/CameraManager.html#turnOnTorchWithStrengthLevel">CameraManager#turnOnTorchWithStrengthLevel</a>.
+     * {android.hardware.camera2.CameraManager#setTorchStrengthLevel}.
      * If this value is equal to 1, flashlight brightness control is not supported.
-     * The value for this key will be null for devices with no flash unit.</p>
+     * This value will be -1 if the flash unit is not available.</p>
      */
     ACAMERA_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL =                 // int32
             ACAMERA_FLASH_INFO_START + 2,
     /**
      * <p>Default flashlight brightness level to be set via
-     * <a href="https://developer.android.com/reference/android/hardware/camera2/CameraManager.html#turnOnTorchWithStrengthLevel">CameraManager#turnOnTorchWithStrengthLevel</a>.</p>
+     * {android.hardware.camera2.CameraManager#setTorchStrengthLevel}.</p>
      *
      * <p>Type: int32</p>
      *
@@ -2213,15 +2174,14 @@ typedef enum acamera_metadata_tag {
      * </ul></p>
      *
      * <p>If flash unit is available this will be greater than or equal to 1 and less
-     * or equal to <code>ACAMERA_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL</code>.</p>
+     * or equal to <code>ACAMERA_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL</code>.
+     * If flash unit is not available this will be set to -1.</p>
      * <p>Setting flashlight brightness above the default level
      * (i.e.<code>ACAMERA_FLASH_INFO_STRENGTH_DEFAULT_LEVEL</code>) may make the device more
      * likely to reach thermal throttling conditions and slow down, or drain the
      * battery quicker than normal. To minimize such issues, it is recommended to
      * start the flashlight at this default brightness until a user explicitly requests
-     * a brighter level.
-     * Note that the value for this key will be null for devices with no flash unit.
-     * The default level should always be &gt; 0.</p>
+     * a brighter level.</p>
      *
      * @see ACAMERA_FLASH_INFO_STRENGTH_DEFAULT_LEVEL
      * @see ACAMERA_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL
@@ -2425,7 +2385,7 @@ typedef enum acamera_metadata_tag {
      *   and keep jpeg and thumbnail image data unrotated.</li>
      * <li>Rotate the jpeg and thumbnail image data and not set
      *   <a href="https://developer.android.com/reference/android/media/ExifInterface.html#TAG_ORIENTATION">EXIF orientation flag</a>. In this
-     *   case, LIMITED or FULL hardware level devices will report rotated thumbnail size in
+     *   case, LIMITED or FULL hardware level devices will report rotated thumnail size in
      *   capture result, so the width and height will be interchanged if 90 or 270 degree
      *   orientation is requested. LEGACY device will always report unrotated thumbnail
      *   size.</li>
@@ -2454,7 +2414,7 @@ typedef enum acamera_metadata_tag {
      *
      * <p>This list will include at least one non-zero resolution, plus <code>(0,0)</code> for indicating no
      * thumbnail should be generated.</p>
-     * <p>Below conditions will be satisfied for this size list:</p>
+     * <p>Below condiditions will be satisfied for this size list:</p>
      * <ul>
      * <li>The sizes will be sorted by increasing pixel area (width x height).
      * If several resolutions have the same area, they will be sorted by increasing width.</li>
@@ -2610,18 +2570,12 @@ typedef enum acamera_metadata_tag {
      * <p>If a camera device supports both OIS and digital image stabilization
      * (ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE), turning both modes on may produce undesirable
      * interaction, so it is recommended not to enable both at the same time.</p>
-     * <p>If ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE is set to "PREVIEW_STABILIZATION",
-     * ACAMERA_LENS_OPTICAL_STABILIZATION_MODE is overridden. The camera sub-system may choose
-     * to turn on hardware based image stabilization in addition to software based stabilization
-     * if it deems that appropriate. This key's value in the capture result will reflect which
-     * OIS mode was chosen.</p>
      * <p>Not all devices will support OIS; see
      * ACAMERA_LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION for
      * available controls.</p>
      *
      * @see ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE
      * @see ACAMERA_LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION
-     * @see ACAMERA_LENS_OPTICAL_STABILIZATION_MODE
      */
     ACAMERA_LENS_OPTICAL_STABILIZATION_MODE =                   // byte (acamera_metadata_enum_android_lens_optical_stabilization_mode_t)
             ACAMERA_LENS_START + 4,
@@ -2724,9 +2678,6 @@ typedef enum acamera_metadata_tag {
      * with PRIMARY_CAMERA.</p>
      * <p>When ACAMERA_LENS_POSE_REFERENCE is UNDEFINED, this position cannot be accurately
      * represented by the camera device, and will be represented as <code>(0, 0, 0)</code>.</p>
-     * <p>When ACAMERA_LENS_POSE_REFERENCE is AUTOMOTIVE, then this position is relative to the
-     * origin of the automotive sensor coordinate system, which is at the center of the rear
-     * axle.</p>
      *
      * @see ACAMERA_LENS_DISTORTION
      * @see ACAMERA_LENS_INTRINSIC_CALIBRATION
@@ -2768,7 +2719,7 @@ typedef enum acamera_metadata_tag {
      * <p>When the state is STATIONARY, the lens parameters are not changing. This could be
      * either because the parameters are all fixed, or because the lens has had enough
      * time to reach the most recently-requested values.
-     * If all these lens parameters are not changeable for a camera device, as listed below:</p>
+     * If all these lens parameters are not changable for a camera device, as listed below:</p>
      * <ul>
      * <li>Fixed focus (<code>ACAMERA_LENS_INFO_MINIMUM_FOCUS_DISTANCE == 0</code>), which means
      * ACAMERA_LENS_FOCUS_DISTANCE parameter will always be 0.</li>
@@ -3220,7 +3171,7 @@ typedef enum acamera_metadata_tag {
      * the camera device. Using more streams simultaneously may require more hardware and
      * CPU resources that will consume more power. The image format for an output stream can
      * be any supported format provided by ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS.
-     * The formats defined in ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS can be categorized
+     * The formats defined in ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS can be catergorized
      * into the 3 stream types as below:</p>
      * <ul>
      * <li>Processed (but stalling): any non-RAW format with a stallDurations &gt; 0.
@@ -3447,7 +3398,7 @@ typedef enum acamera_metadata_tag {
      * but clients should be aware and expect delays during their application.
      * An example usage scenario could look like this:</p>
      * <ul>
-     * <li>The camera client starts by querying the session parameter key list via
+     * <li>The camera client starts by quering the session parameter key list via
      *   {@link ACameraManager_getCameraCharacteristics }.</li>
      * <li>Before triggering the capture session create sequence, a capture request
      *   must be built via
@@ -3486,36 +3437,16 @@ typedef enum acamera_metadata_tag {
      * </ul></p>
      *
      * <p>This is a subset of ACAMERA_REQUEST_AVAILABLE_REQUEST_KEYS which contains a list
-     * of keys that can be overridden using
-     * <a href="https://developer.android.com/reference/android/hardware/camera2/CaptureRequest.Builder.html#setPhysicalCameraKey">Builder#setPhysicalCameraKey</a>.
+     * of keys that can be overridden using <a href="https://developer.android.com/reference/CaptureRequest/Builder.html#setPhysicalCameraKey">Builder#setPhysicalCameraKey</a>.
      * The respective value of such request key can be obtained by calling
-     * <a href="https://developer.android.com/reference/android/hardware/camera2/CaptureRequest.Builder.html#getPhysicalCameraKey">Builder#getPhysicalCameraKey</a>.
-     * Capture requests that contain individual physical device requests must be built via
+     * <a href="https://developer.android.com/reference/CaptureRequest/Builder.html#getPhysicalCameraKey">Builder#getPhysicalCameraKey</a>. Capture requests that contain
+     * individual physical device requests must be built via
      * <a href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice.html#createCaptureRequest(int,">Set)</a>.</p>
      *
      * @see ACAMERA_REQUEST_AVAILABLE_REQUEST_KEYS
      */
     ACAMERA_REQUEST_AVAILABLE_PHYSICAL_CAMERA_REQUEST_KEYS =    // int32[n]
             ACAMERA_REQUEST_START + 17,
-    /**
-     * <p>A map of all available 10-bit dynamic range profiles along with their
-     * capture request constraints.</p>
-     *
-     * <p>Type: int64[n*3] (acamera_metadata_enum_android_request_available_dynamic_range_profiles_map_t)</p>
-     *
-     * <p>This tag may appear in:
-     * <ul>
-     *   <li>ACameraMetadata from ACameraManager_getCameraCharacteristics</li>
-     * </ul></p>
-     *
-     * <p>Devices supporting the 10-bit output capability
-     * <a href="https://developer.android.com/reference/android/hardware/camera2/CameraCharacteristics.html#REQUEST_AVAILABLE_CAPABILITIES_DYNAMIC_RANGE_TEN_BIT">CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_DYNAMIC_RANGE_TEN_BIT</a>
-     * must list their supported dynamic range profiles. In case the camera is not able to
-     * support every possible profile combination within a single capture request, then the
-     * constraints must be listed here as well.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP =      // int64[n*3] (acamera_metadata_enum_android_request_available_dynamic_range_profiles_map_t)
-            ACAMERA_REQUEST_START + 19,
     ACAMERA_REQUEST_END,
 
     /**
@@ -3713,8 +3644,7 @@ typedef enum acamera_metadata_tag {
      * YUV_420_888    | all output sizes available for JPEG, up to the maximum video size | LIMITED        |
      * IMPLEMENTATION_DEFINED | same as YUV_420_888                  | Any            |</p>
      * <p>For applications targeting SDK version 31 or newer, if the mobile device declares to be
-     * media performance class 12 or higher by setting
-     * <a href="https://developer.android.com/reference/android/os/Build.VERSION.html#MEDIA_PERFORMANCE_CLASS">VERSION#MEDIA_PERFORMANCE_CLASS</a> to be 31 or larger,
+     * <a href="https://developer.android.com/reference/android/os/Build/VERSION_CDOES/MEDIA_PERFORMANCE_CLASS.html">media performance class</a> S,
      * the primary camera devices (first rear/front camera in the camera ID list) will not
      * support JPEG sizes smaller than 1080p. If the application configures a JPEG stream
      * smaller than 1080p, the camera device will round up the JPEG image size to at least
@@ -3732,11 +3662,9 @@ typedef enum acamera_metadata_tag {
      * YUV_420_888    | all output sizes available for FULL hardware level, up to the maximum video size | LIMITED        |
      * IMPLEMENTATION_DEFINED | same as YUV_420_888                  | Any            |</p>
      * <p>For applications targeting SDK version 31 or newer, if the mobile device doesn't declare
-     * to be media performance class 12 or better by setting
-     * <a href="https://developer.android.com/reference/android/os/Build.VERSION.html#MEDIA_PERFORMANCE_CLASS">VERSION#MEDIA_PERFORMANCE_CLASS</a> to be 31 or larger,
-     * or if the camera device isn't a primary rear/front camera, the minimum required output
-     * stream configurations are the same as for applications targeting SDK version older than
-     * 31.</p>
+     * to be media performance class S, or if the camera device isn't a primary rear/front
+     * camera, the minimum required output stream configurations are the same as for applications
+     * targeting SDK version older than 31.</p>
      * <p>Refer to ACAMERA_REQUEST_AVAILABLE_CAPABILITIES for additional
      * mandatory stream configurations on a per-capability basis.</p>
      * <p>Exception on 176x144 (QCIF) resolution: camera devices usually have a fixed capability for
@@ -4227,70 +4155,19 @@ typedef enum acamera_metadata_tag {
      * to output different resolution images depending on the current active physical camera or
      * pixel mode. With multi-resolution input streams, the camera device can reprocess images
      * of different resolutions from different physical cameras or sensor pixel modes.</p>
-     * <p>When set to TRUE:</p>
-     * <ul>
-     * <li>For a logical multi-camera, the camera framework derives
+     * <p>When set to TRUE:
+     * * For a logical multi-camera, the camera framework derives
      * android.scaler.multiResolutionStreamConfigurationMap by combining the
      * ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS from its physical
-     * cameras.</li>
-     * <li>For an ultra-high resolution sensor camera, the camera framework directly copies
+     * cameras.
+     * * For an ultra-high resolution sensor camera, the camera framework directly copies
      * the value of ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS to
-     * android.scaler.multiResolutionStreamConfigurationMap.</li>
-     * </ul>
+     * android.scaler.multiResolutionStreamConfigurationMap.</p>
      *
      * @see ACAMERA_SCALER_PHYSICAL_CAMERA_MULTI_RESOLUTION_STREAM_CONFIGURATIONS
      */
     ACAMERA_SCALER_MULTI_RESOLUTION_STREAM_SUPPORTED =          // byte (acamera_metadata_enum_android_scaler_multi_resolution_stream_supported_t)
             ACAMERA_SCALER_START + 24,
-    /**
-     * <p>The stream use cases supported by this camera device.</p>
-     *
-     * <p>Type: int64[n] (acamera_metadata_enum_android_scaler_available_stream_use_cases_t)</p>
-     *
-     * <p>This tag may appear in:
-     * <ul>
-     *   <li>ACameraMetadata from ACameraManager_getCameraCharacteristics</li>
-     * </ul></p>
-     *
-     * <p>The stream use case indicates the purpose of a particular camera stream from
-     * the end-user perspective. Some examples of camera use cases are: preview stream for
-     * live viewfinder shown to the user, still capture for generating high quality photo
-     * capture, video record for encoding the camera output for the purpose of future playback,
-     * and video call for live realtime video conferencing.</p>
-     * <p>With this flag, the camera device can optimize the image processing pipeline
-     * parameters, such as tuning, sensor mode, and ISP settings, independent of
-     * the properties of the immediate camera output surface. For example, if the output
-     * surface is a SurfaceTexture, the stream use case flag can be used to indicate whether
-     * the camera frames eventually go to display, video encoder,
-     * still image capture, or all of them combined.</p>
-     * <p>The application sets the use case of a camera stream by calling
-     * <a href="https://developer.android.com/reference/android/hardware/camera2/params/OutputConfiguration.html#setStreamUseCase">OutputConfiguration#setStreamUseCase</a>.</p>
-     * <p>A camera device with
-     * <a href="https://developer.android.com/reference/android/hardware/camera2/CameraCharacteristics.html#REQUEST_AVAILABLE_CAPABILITIES_STREAM_USE_CASE">CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_STREAM_USE_CASE</a>
-     * capability must support the following stream use cases:</p>
-     * <ul>
-     * <li>DEFAULT</li>
-     * <li>PREVIEW</li>
-     * <li>STILL_CAPTURE</li>
-     * <li>VIDEO_RECORD</li>
-     * <li>PREVIEW_VIDEO_STILL</li>
-     * <li>VIDEO_CALL</li>
-     * </ul>
-     * <p>The guaranteed stream combinations related to stream use case for a camera device with
-     * <a href="https://developer.android.com/reference/android/hardware/camera2/CameraCharacteristics.html#REQUEST_AVAILABLE_CAPABILITIES_STREAM_USE_CASE">CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_STREAM_USE_CASE</a>
-     * capability is documented in the camera device
-     * <a href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice.html#createCaptureSession">guideline</a>. The
-     * application is strongly recommended to use one of the guaranteed stream combinations.
-     * If the application creates a session with a stream combination not in the guaranteed
-     * list, or with mixed DEFAULT and non-DEFAULT use cases within the same session,
-     * the camera device may ignore some stream use cases due to hardware constraints
-     * and implementation details.</p>
-     * <p>For stream combinations not covered by the stream use case mandatory lists, such as
-     * reprocessable session, constrained high speed session, or RAW stream combinations, the
-     * application should leave stream use cases within the session as DEFAULT.</p>
-     */
-    ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES =                 // int64[n] (acamera_metadata_enum_android_scaler_available_stream_use_cases_t)
-            ACAMERA_SCALER_START + 25,
     ACAMERA_SCALER_END,
 
     /**
@@ -4844,7 +4721,7 @@ typedef enum acamera_metadata_tag {
      * noise model used here is:</p>
      * <p>N(x) = sqrt(Sx + O)</p>
      * <p>Where x represents the recorded signal of a CFA channel normalized to
-     * the range [0, 1], and S and O are the noise model coefficients for
+     * the range [0, 1], and S and O are the noise model coeffiecients for
      * that channel.</p>
      * <p>A more detailed description of the noise model can be found in the
      * Adobe DNG specification for the NoiseProfile tag.</p>
@@ -4893,7 +4770,7 @@ typedef enum acamera_metadata_tag {
      * <li>1.20 &lt;= R &gt;= 1.03 will require some software
      * correction to avoid demosaic errors (3-20% divergence).</li>
      * <li>R &gt; 1.20 will require strong software correction to produce
-     * a usable image (&gt;20% divergence).</li>
+     * a usuable image (&gt;20% divergence).</li>
      * </ul>
      * <p>Starting from Android Q, this key will not be present for a MONOCHROME camera, even if
      * the camera device has RAW capability.</p>
@@ -5150,7 +5027,7 @@ typedef enum acamera_metadata_tag {
      *   <li>ACameraMetadata from ACameraCaptureSession_captureCallback_result callbacks</li>
      * </ul></p>
      *
-     * <p>This key will only be present in devices advertising the
+     * <p>This key will only be present in devices advertisting the
      * <a href="https://developer.android.com/reference/android/hardware/camera2/CameraMetadata.html#REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR">CameraMetadata#REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR</a>
      * capability which also advertise <code>REMOSAIC_REPROCESSING</code> capability. On all other devices
      * RAW targets will have a regular bayer pattern.</p>
@@ -6335,11 +6212,9 @@ typedef enum acamera_metadata_tag {
      *   <li>ACaptureRequest</li>
      * </ul></p>
      *
-     * <p>The tonemap curve will be defined the following formula:</p>
-     * <ul>
-     * <li>OUT = pow(IN, 1.0 / gamma)</li>
-     * </ul>
-     * <p>where IN and OUT is the input pixel value scaled to range [0.0, 1.0],
+     * <p>The tonemap curve will be defined the following formula:
+     * * OUT = pow(IN, 1.0 / gamma)
+     * where IN and OUT is the input pixel value scaled to range [0.0, 1.0],
      * pow is the power function and gamma is the gamma value specified by this
      * key.</p>
      * <p>The same curve will be applied to all color channels. The camera device
@@ -7237,87 +7112,6 @@ typedef enum acamera_metadata_tag {
             ACAMERA_HEIC_START + 5,
     ACAMERA_HEIC_END,
 
-    /**
-     * <p>Location of the cameras on the automotive devices.</p>
-     *
-     * <p>Type: byte (acamera_metadata_enum_android_automotive_location_t)</p>
-     *
-     * <p>This tag may appear in:
-     * <ul>
-     *   <li>ACameraMetadata from ACameraManager_getCameraCharacteristics</li>
-     * </ul></p>
-     *
-     * <p>This enum defines the locations of the cameras relative to the vehicle body frame on
-     * <a href="https://source.android.com/devices/sensors/sensor-types#auto_axes">the automotive sensor coordinate system</a>.
-     * If the system has FEATURE_AUTOMOTIVE, the camera will have this entry in its static
-     * metadata.</p>
-     * <ul>
-     * <li>INTERIOR is the inside of the vehicle body frame (or the passenger cabin).</li>
-     * <li>EXTERIOR is the outside of the vehicle body frame.</li>
-     * <li>EXTRA is the extra vehicle such as a trailer.</li>
-     * </ul>
-     * <p>Each side of the vehicle body frame on this coordinate system is defined as below:</p>
-     * <ul>
-     * <li>FRONT is where the Y-axis increases toward.</li>
-     * <li>REAR is where the Y-axis decreases toward.</li>
-     * <li>LEFT is where the X-axis decreases toward.</li>
-     * <li>RIGHT is where the X-axis increases toward.</li>
-     * </ul>
-     * <p>If the camera has either EXTERIOR_OTHER or EXTRA_OTHER, its static metadata will list
-     * the following entries, so that applications can determine the camera's exact location:</p>
-     * <ul>
-     * <li>ACAMERA_LENS_POSE_REFERENCE</li>
-     * <li>ACAMERA_LENS_POSE_ROTATION</li>
-     * <li>ACAMERA_LENS_POSE_TRANSLATION</li>
-     * </ul>
-     *
-     * @see ACAMERA_LENS_POSE_REFERENCE
-     * @see ACAMERA_LENS_POSE_ROTATION
-     * @see ACAMERA_LENS_POSE_TRANSLATION
-     */
-    ACAMERA_AUTOMOTIVE_LOCATION =                               // byte (acamera_metadata_enum_android_automotive_location_t)
-            ACAMERA_AUTOMOTIVE_START,
-    ACAMERA_AUTOMOTIVE_END,
-
-    /**
-     * <p>The direction of the camera faces relative to the vehicle body frame and the
-     * passenger seats.</p>
-     *
-     * <p>Type: byte[n] (acamera_metadata_enum_android_automotive_lens_facing_t)</p>
-     *
-     * <p>This tag may appear in:
-     * <ul>
-     *   <li>ACameraMetadata from ACameraManager_getCameraCharacteristics</li>
-     * </ul></p>
-     *
-     * <p>This enum defines the lens facing characteristic of the cameras on the automotive
-     * devices with locations ACAMERA_AUTOMOTIVE_LOCATION defines.  If the system has
-     * FEATURE_AUTOMOTIVE, the camera will have this entry in its static metadata.</p>
-     * <p>When ACAMERA_AUTOMOTIVE_LOCATION is INTERIOR, this has one or more INTERIOR_*
-     * values or a single EXTERIOR_* value.  When this has more than one INTERIOR_*,
-     * the first value must be the one for the seat closest to the optical axis. If this
-     * contains INTERIOR_OTHER, all other values will be ineffective.</p>
-     * <p>When ACAMERA_AUTOMOTIVE_LOCATION is EXTERIOR_* or EXTRA, this has a single
-     * EXTERIOR_* value.</p>
-     * <p>If a camera has INTERIOR_OTHER or EXTERIOR_OTHER, or more than one camera is at the
-     * same location and facing the same direction, their static metadata will list the
-     * following entries, so that applications can determine their lenses' exact facing
-     * directions:</p>
-     * <ul>
-     * <li>ACAMERA_LENS_POSE_REFERENCE</li>
-     * <li>ACAMERA_LENS_POSE_ROTATION</li>
-     * <li>ACAMERA_LENS_POSE_TRANSLATION</li>
-     * </ul>
-     *
-     * @see ACAMERA_AUTOMOTIVE_LOCATION
-     * @see ACAMERA_LENS_POSE_REFERENCE
-     * @see ACAMERA_LENS_POSE_ROTATION
-     * @see ACAMERA_LENS_POSE_TRANSLATION
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING =                            // byte[n] (acamera_metadata_enum_android_automotive_lens_facing_t)
-            ACAMERA_AUTOMOTIVE_LENS_START,
-    ACAMERA_AUTOMOTIVE_LENS_END,
-
 } acamera_metadata_tag_t;
 
 /**
@@ -8219,17 +8013,6 @@ typedef enum acamera_metadata_enum_acamera_control_video_stabilization_mode {
      */
     ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE_ON                      = 1,
 
-    /**
-     * <p>Preview stabilization, where the preview in addition to all other non-RAW streams are
-     * stabilized with the same quality of stabilization, is enabled. This mode aims to give
-     * clients a 'what you see is what you get' effect. In this mode, the FoV reduction will
-     * be a maximum of 20 % both horizontally and vertically
-     * (10% from left, right, top, bottom) for the given zoom ratio / crop region.
-     * The resultant FoV will also be the same across all processed streams
-     * (that have the same aspect ratio).</p>
-     */
-    ACAMERA_CONTROL_VIDEO_STABILIZATION_MODE_PREVIEW_STABILIZATION   = 2,
-
 } acamera_metadata_enum_android_control_video_stabilization_mode_t;
 
 // ACAMERA_CONTROL_AE_STATE
@@ -8710,14 +8493,6 @@ typedef enum acamera_metadata_enum_acamera_lens_pose_reference {
      */
     ACAMERA_LENS_POSE_REFERENCE_UNDEFINED                            = 2,
 
-    /**
-     * <p>The value of ACAMERA_LENS_POSE_TRANSLATION is relative to the origin of the
-     * automotive sensor coordinate system, which is at the center of the rear axle.</p>
-     *
-     * @see ACAMERA_LENS_POSE_TRANSLATION
-     */
-    ACAMERA_LENS_POSE_REFERENCE_AUTOMOTIVE                           = 3,
-
 } acamera_metadata_enum_android_lens_pose_reference_t;
 
 
@@ -9031,7 +8806,7 @@ typedef enum acamera_metadata_enum_acamera_request_available_capabilities {
      * for the largest YUV_420_888 size.</p>
      * <p>If the device supports the {@link AIMAGE_FORMAT_RAW10 }, {@link AIMAGE_FORMAT_RAW12 }, {@link AIMAGE_FORMAT_Y8 }, then those can also be
      * captured at the same rate as the maximum-size YUV_420_888 resolution is.</p>
-     * <p>In addition, the ACAMERA_SYNC_MAX_LATENCY field is guaranteed to have a value between 0
+     * <p>In addition, the ACAMERA_SYNC_MAX_LATENCY field is guaranted to have a value between 0
      * and 4, inclusive. ACAMERA_CONTROL_AE_LOCK_AVAILABLE and ACAMERA_CONTROL_AWB_LOCK_AVAILABLE
      * are also guaranteed to be <code>true</code> so burst capture with these two locks ON yields
      * consistent image output.</p>
@@ -9197,7 +8972,7 @@ typedef enum acamera_metadata_enum_acamera_request_available_capabilities {
      * non-active physical cameras. For example, if the logical camera has a wide-ultrawide
      * configuration where the wide lens is the default, when the crop region is set to the
      * logical camera's active array size, (and the zoom ratio set to 1.0 starting from
-     * Android 11), a physical stream for the ultrawide camera may prefer outputting images
+     * Android 11), a physical stream for the ultrawide camera may prefer outputing images
      * with larger field-of-view than that of the wide camera for better stereo matching
      * margin or more robust motion tracking. At the same time, the physical non-RAW streams'
      * field of view must not be smaller than the requested crop region and zoom ratio, as
@@ -9318,132 +9093,8 @@ typedef enum acamera_metadata_enum_acamera_request_available_capabilities {
     ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR
                                                                       = 16,
 
-    /**
-     * <p>The camera device supports selecting a per-stream use case via
-     * <a href="https://developer.android.com/reference/android/hardware/camera2/params/OutputConfiguration.html#setStreamUseCase">OutputConfiguration#setStreamUseCase</a>
-     * so that the device can optimize camera pipeline parameters such as tuning, sensor
-     * mode, or ISP settings for a specific user scenario.
-     * Some sample usages of this capability are:</p>
-     * <ul>
-     * <li>Distinguish high quality YUV captures from a regular YUV stream where
-     *   the image quality may not be as good as the JPEG stream, or</li>
-     * <li>Use one stream to serve multiple purposes: viewfinder, video recording and
-     *   still capture. This is common with applications that wish to apply edits equally
-     *   to preview, saved images, and saved videos.</li>
-     * </ul>
-     * <p>This capability requires the camera device to support the following
-     * stream use cases:</p>
-     * <ul>
-     * <li>DEFAULT for backward compatibility where the application doesn't set
-     *   a stream use case</li>
-     * <li>PREVIEW for live viewfinder and in-app image analysis</li>
-     * <li>STILL_CAPTURE for still photo capture</li>
-     * <li>VIDEO_RECORD for recording video clips</li>
-     * <li>PREVIEW_VIDEO_STILL for one single stream used for viewfinder, video
-     *   recording, and still capture.</li>
-     * <li>VIDEO_CALL for long running video calls</li>
-     * </ul>
-     * <p><a href="https://developer.android.com/reference/android/hardware/camera2/CameraCharacteristics.html#SCALER_AVAILABLE_STREAM_USE_CASES">CameraCharacteristics#SCALER_AVAILABLE_STREAM_USE_CASES</a>
-     * lists all of the supported stream use cases.</p>
-     * <p>Refer to <a href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice.html#createCaptureSession">CameraDevice#createCaptureSession</a> for the
-     * mandatory stream combinations involving stream use cases, which can also be queried
-     * via <a href="https://developer.android.com/reference/android/hardware/camera2/params/MandatoryStreamCombination.html">MandatoryStreamCombination</a>.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_CAPABILITIES_STREAM_USE_CASE           = 19,
-
 } acamera_metadata_enum_android_request_available_capabilities_t;
 
-// ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP
-typedef enum acamera_metadata_enum_acamera_request_available_dynamic_range_profiles_map {
-    /**
-     * <p>8-bit SDR profile which is the default for all non 10-bit output capable devices.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD    = 0x1,
-
-    /**
-     * <p>10-bit pixel samples encoded using the Hybrid log-gamma transfer function.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HLG10       = 0x2,
-
-    /**
-     * <p>10-bit pixel samples encoded using the SMPTE ST 2084 transfer function.
-     * This profile utilizes internal static metadata to increase the quality
-     * of the capture.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10       = 0x4,
-
-    /**
-     * <p>10-bit pixel samples encoded using the SMPTE ST 2084 transfer function.
-     * In contrast to HDR10, this profile uses internal per-frame metadata
-     * to further enhance the quality of the capture.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10_PLUS  = 0x8,
-
-    /**
-     * <p>This is a camera mode for Dolby Vision capture optimized for a more scene
-     * accurate capture. This would typically differ from what a specific device
-     * might want to tune for a consumer optimized Dolby Vision general capture.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF
-                                                                      = 0x10,
-
-    /**
-     * <p>This is the power optimized mode for 10-bit Dolby Vision HDR Reference Mode.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF_PO
-                                                                      = 0x20,
-
-    /**
-     * <p>This is the camera mode for the default Dolby Vision capture mode for the
-     * specific device. This would be tuned by each specific device for consumer
-     * pleasing results that resonate with their particular audience. We expect
-     * that each specific device would have a different look for their default
-     * Dolby Vision capture.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM
-                                                                      = 0x40,
-
-    /**
-     * <p>This is the power optimized mode for 10-bit Dolby Vision HDR device specific
-     * capture Mode.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM_PO
-                                                                      = 0x80,
-
-    /**
-     * <p>This is the 8-bit version of the Dolby Vision reference capture mode optimized
-     * for scene accuracy.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF
-                                                                      = 0x100,
-
-    /**
-     * <p>This is the power optimized mode for 8-bit Dolby Vision HDR Reference Mode.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF_PO
-                                                                      = 0x200,
-
-    /**
-     * <p>This is the 8-bit version of device specific tuned and optimized Dolby Vision
-     * capture mode.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM
-                                                                      = 0x400,
-
-    /**
-     * <p>This is the power optimized mode for 8-bit Dolby Vision HDR device specific
-     * capture Mode.</p>
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM_PO
-                                                                      = 0x800,
-
-    /**
-     *
-     */
-    ACAMERA_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_MAX         = 0x1000,
-
-} acamera_metadata_enum_android_request_available_dynamic_range_profiles_map_t;
-
 
 // ACAMERA_SCALER_AVAILABLE_STREAM_CONFIGURATIONS
 typedef enum acamera_metadata_enum_acamera_scaler_available_stream_configurations {
@@ -9534,20 +9185,6 @@ typedef enum acamera_metadata_enum_acamera_scaler_available_recommended_stream_c
     ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_PUBLIC_END
                                                                       = 0x7,
 
-    /**
-     * <p>If supported, the recommended 10-bit output stream configurations must include
-     * a subset of the advertised <a href="https://developer.android.com/reference/android/graphics/ImageFormat.html#YCBCR_P010">ImageFormat#YCBCR_P010</a> and
-     * <a href="https://developer.android.com/reference/android/graphics/ImageFormat.html#PRIVATE">ImageFormat#PRIVATE</a> outputs that are optimized for power
-     * and performance when registered along with a supported 10-bit dynamic range profile.
-     * see android.hardware.camera2.params.OutputConfiguration#setDynamicRangeProfile for
-     * details.</p>
-     */
-    ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_10BIT_OUTPUT
-                                                                      = 0x8,
-
-    ACAMERA_SCALER_AVAILABLE_RECOMMENDED_STREAM_CONFIGURATIONS_PUBLIC_END_3_8
-                                                                      = 0x9,
-
     /**
      * <p>Vendor defined use cases. These depend on the vendor implementation.</p>
      */
@@ -9629,76 +9266,6 @@ typedef enum acamera_metadata_enum_acamera_scaler_multi_resolution_stream_suppor
 
 } acamera_metadata_enum_android_scaler_multi_resolution_stream_supported_t;
 
-// ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES
-typedef enum acamera_metadata_enum_acamera_scaler_available_stream_use_cases {
-    /**
-     * <p>Default stream use case.</p>
-     * <p>This use case is the same as when the application doesn't set any use case for
-     * the stream. The camera device uses the properties of the output target, such as
-     * format, dataSpace, or surface class type, to optimize the image processing pipeline.</p>
-     */
-    ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT                = 0x0,
-
-    /**
-     * <p>Live stream shown to the user.</p>
-     * <p>Optimized for performance and usability as a viewfinder, but not necessarily for
-     * image quality. The output is not meant to be persisted as saved images or video.</p>
-     * <p>No stall if ACAMERA_CONTROL_* are set to FAST. There may be stall if
-     * they are set to HIGH_QUALITY. This use case has the same behavior as the
-     * default SurfaceView and SurfaceTexture targets. Additionally, this use case can be
-     * used for in-app image analysis.</p>
-     */
-    ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW                = 0x1,
-
-    /**
-     * <p>Still photo capture.</p>
-     * <p>Optimized for high-quality high-resolution capture, and not expected to maintain
-     * preview-like frame rates.</p>
-     * <p>The stream may have stalls regardless of whether ACAMERA_CONTROL_* is HIGH_QUALITY.
-     * This use case has the same behavior as the default JPEG and RAW related formats.</p>
-     */
-    ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_STILL_CAPTURE          = 0x2,
-
-    /**
-     * <p>Recording video clips.</p>
-     * <p>Optimized for high-quality video capture, including high-quality image stabilization
-     * if supported by the device and enabled by the application. As a result, may produce
-     * output frames with a substantial lag from real time, to allow for highest-quality
-     * stabilization or other processing. As such, such an output is not suitable for drawing
-     * to screen directly, and is expected to be persisted to disk or similar for later
-     * playback or processing. Only streams that set the VIDEO_RECORD use case are guaranteed
-     * to have video stabilization applied when the video stabilization control is set
-     * to ON, as opposed to PREVIEW_STABILIZATION.</p>
-     * <p>This use case has the same behavior as the default MediaRecorder and MediaCodec
-     * targets.</p>
-     */
-    ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_VIDEO_RECORD           = 0x3,
-
-    /**
-     * <p>One single stream used for combined purposes of preview, video, and still capture.</p>
-     * <p>For such multi-purpose streams, the camera device aims to make the best tradeoff
-     * between the individual use cases. For example, the STILL_CAPTURE use case by itself
-     * may have stalls for achieving best image quality. But if combined with PREVIEW and
-     * VIDEO_RECORD, the camera device needs to trade off the additional image processing
-     * for speed so that preview and video recording aren't slowed down.</p>
-     * <p>Similarly, VIDEO_RECORD may produce frames with a substantial lag, but
-     * PREVIEW_VIDEO_STILL must have minimal output delay. This means that to enable video
-     * stabilization with this use case, the device must support and the app must select the
-     * PREVIEW_STABILIZATION mode for video stabilization.</p>
-     */
-    ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_PREVIEW_VIDEO_STILL    = 0x4,
-
-    /**
-     * <p>Long-running video call optimized for both power efficiency and video quality.</p>
-     * <p>The camera sensor may run in a lower-resolution mode to reduce power consumption
-     * at the cost of some image and digital zoom quality. Unlike VIDEO_RECORD, VIDEO_CALL
-     * outputs are expected to work in dark conditions, so are usually accompanied with
-     * variable frame rate settings to allow sufficient exposure time in low light.</p>
-     */
-    ACAMERA_SCALER_AVAILABLE_STREAM_USE_CASES_VIDEO_CALL             = 0x5,
-
-} acamera_metadata_enum_android_scaler_available_stream_use_cases_t;
-
 
 // ACAMERA_SENSOR_REFERENCE_ILLUMINANT1
 typedef enum acamera_metadata_enum_acamera_sensor_reference_illuminant1 {
@@ -10116,7 +9683,7 @@ typedef enum acamera_metadata_enum_acamera_tonemap_mode {
     ACAMERA_TONEMAP_MODE_HIGH_QUALITY                                = 2,
 
     /**
-     * <p>Use the gamma value specified in ACAMERA_TONEMAP_GAMMA to perform
+     * <p>Use the gamma value specified in ACAMERA_TONEMAP_GAMMA to peform
      * tonemapping.</p>
      * <p>All color enhancement and tonemapping must be disabled, except
      * for applying the tonemapping curve specified by ACAMERA_TONEMAP_GAMMA.</p>
@@ -10128,7 +9695,7 @@ typedef enum acamera_metadata_enum_acamera_tonemap_mode {
 
     /**
      * <p>Use the preset tonemapping curve specified in
-     * ACAMERA_TONEMAP_PRESET_CURVE to perform tonemapping.</p>
+     * ACAMERA_TONEMAP_PRESET_CURVE to peform tonemapping.</p>
      * <p>All color enhancement and tonemapping must be disabled, except
      * for applying the tonemapping curve specified by
      * ACAMERA_TONEMAP_PRESET_CURVE.</p>
@@ -10226,7 +9793,7 @@ typedef enum acamera_metadata_enum_acamera_info_supported_hardware_level {
      * fire the flash for flash power metering during precapture, and then fire the flash
      * for the final capture, if a flash is available on the device and the AE mode is set to
      * enable the flash.</p>
-     * <p>Devices that initially shipped with Android version <a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES.html#Q">Q</a> or newer will not include any LEGACY-level devices.</p>
+     * <p>Devices that initially shipped with Android version <a href="https://developer.android.com/reference/android/os/Build/VERSION_CODES.html#Q">Q</a> or newer will not include any LEGACY-level devices.</p>
      *
      * @see ACAMERA_CONTROL_AE_PRECAPTURE_TRIGGER
      * @see ACAMERA_REQUEST_AVAILABLE_CAPABILITIES
@@ -10460,167 +10027,6 @@ typedef enum acamera_metadata_enum_acamera_heic_available_heic_stream_configurat
 
 
 
-// ACAMERA_AUTOMOTIVE_LOCATION
-typedef enum acamera_metadata_enum_acamera_automotive_location {
-    /**
-     * <p>The camera device exists inside of the vehicle cabin.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LOCATION_INTERIOR                             = 0,
-
-    /**
-     * <p>The camera exists outside of the vehicle body frame but not exactly on one of the
-     * exterior locations this enum defines.  The applications should determine the exact
-     * location from ACAMERA_LENS_POSE_TRANSLATION.</p>
-     *
-     * @see ACAMERA_LENS_POSE_TRANSLATION
-     */
-    ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_OTHER                       = 1,
-
-    /**
-     * <p>The camera device exists outside of the vehicle body frame and on its front side.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_FRONT                       = 2,
-
-    /**
-     * <p>The camera device exists outside of the vehicle body frame and on its rear side.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_REAR                        = 3,
-
-    /**
-     * <p>The camera device exists outside and on left side of the vehicle body frame.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_LEFT                        = 4,
-
-    /**
-     * <p>The camera device exists outside and on right side of the vehicle body frame.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LOCATION_EXTERIOR_RIGHT                       = 5,
-
-    /**
-     * <p>The camera device exists on an extra vehicle, such as the trailer, but not exactly
-     * on one of front, rear, left, or right side.  Applications should determine the exact
-     * location from ACAMERA_LENS_POSE_TRANSLATION.</p>
-     *
-     * @see ACAMERA_LENS_POSE_TRANSLATION
-     */
-    ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_OTHER                          = 6,
-
-    /**
-     * <p>The camera device exists outside of the extra vehicle's body frame and on its front
-     * side.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_FRONT                          = 7,
-
-    /**
-     * <p>The camera device exists outside of the extra vehicle's body frame and on its rear
-     * side.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_REAR                           = 8,
-
-    /**
-     * <p>The camera device exists outside and on left side of the extra vehicle body.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_LEFT                           = 9,
-
-    /**
-     * <p>The camera device exists outside and on right side of the extra vehicle body.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LOCATION_EXTRA_RIGHT                          = 10,
-
-} acamera_metadata_enum_android_automotive_location_t;
-
-
-// ACAMERA_AUTOMOTIVE_LENS_FACING
-typedef enum acamera_metadata_enum_acamera_automotive_lens_facing {
-    /**
-     * <p>The camera device faces the outside of the vehicle body frame but not exactly
-     * one of the exterior sides defined by this enum.  Applications should determine
-     * the exact facing direction from ACAMERA_LENS_POSE_ROTATION and
-     * ACAMERA_LENS_POSE_TRANSLATION.</p>
-     *
-     * @see ACAMERA_LENS_POSE_ROTATION
-     * @see ACAMERA_LENS_POSE_TRANSLATION
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_OTHER                    = 0,
-
-    /**
-     * <p>The camera device faces the front of the vehicle body frame.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_FRONT                    = 1,
-
-    /**
-     * <p>The camera device faces the rear of the vehicle body frame.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_REAR                     = 2,
-
-    /**
-     * <p>The camera device faces the left side of the vehicle body frame.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_LEFT                     = 3,
-
-    /**
-     * <p>The camera device faces the right side of the vehicle body frame.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_EXTERIOR_RIGHT                    = 4,
-
-    /**
-     * <p>The camera device faces the inside of the vehicle body frame but not exactly
-     * one of seats described by this enum.  Applications should determine the exact
-     * facing direction from ACAMERA_LENS_POSE_ROTATION and ACAMERA_LENS_POSE_TRANSLATION.</p>
-     *
-     * @see ACAMERA_LENS_POSE_ROTATION
-     * @see ACAMERA_LENS_POSE_TRANSLATION
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_OTHER                    = 5,
-
-    /**
-     * <p>The camera device faces the left side seat of the first row.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_LEFT          = 6,
-
-    /**
-     * <p>The camera device faces the center seat of the first row.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_CENTER        = 7,
-
-    /**
-     * <p>The camera device faces the right seat of the first row.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_1_RIGHT         = 8,
-
-    /**
-     * <p>The camera device faces the left side seat of the second row.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_LEFT          = 9,
-
-    /**
-     * <p>The camera device faces the center seat of the second row.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_CENTER        = 10,
-
-    /**
-     * <p>The camera device faces the right side seat of the second row.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_2_RIGHT         = 11,
-
-    /**
-     * <p>The camera device faces the left side seat of the third row.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_LEFT          = 12,
-
-    /**
-     * <p>The camera device faces the center seat of the third row.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_CENTER        = 13,
-
-    /**
-     * <p>The camera device faces the right seat of the third row.</p>
-     */
-    ACAMERA_AUTOMOTIVE_LENS_FACING_INTERIOR_SEAT_ROW_3_RIGHT         = 14,
-
-} acamera_metadata_enum_android_automotive_lens_facing_t;
-
-
 
 __END_DECLS
 
diff --git a/camera/ndk/ndk_vendor/impl/ACameraDevice.cpp b/camera/ndk/ndk_vendor/impl/ACameraDevice.cpp
index 0a57590f8d..4cc1292a9b 100644
--- a/camera/ndk/ndk_vendor/impl/ACameraDevice.cpp
+++ b/camera/ndk/ndk_vendor/impl/ACameraDevice.cpp
@@ -330,8 +330,7 @@ camera_status_t CameraDevice::updateOutputConfigurationLocked(ACaptureSessionOut
                 return ACAMERA_ERROR_UNKNOWN;
     }
 
-    mConfiguredOutputs[streamId] =
-            std::move(std::make_pair(std::move(output->mWindow), std::move(outConfigW)));
+    mConfiguredOutputs[streamId] = std::make_pair(output->mWindow, outConfigW);
 
     return ACAMERA_OK;
 }
@@ -491,7 +490,6 @@ CameraDevice::disconnectLocked(sp<ACameraCaptureSession>& session) {
     }
 
     if (mRemote != nullptr) {
-        ALOGD("%s: binder disconnect reached", __FUNCTION__);
         auto ret = mRemote->disconnect();
         if (!ret.isOk()) {
             ALOGE("%s: Transaction error while disconnecting device %s", __FUNCTION__,
@@ -625,8 +623,7 @@ CameraDevice::configureStreamsLocked(const ACaptureSessionOutputContainer* outpu
         outConfigInsert.windowHandles[0] = anw;
         outConfigInsert.physicalCameraId = outConfig.mPhysicalCameraId;
         native_handle_ptr_wrapper wrap(anw);
-
-        outputSet.emplace(std::make_pair(std::move(anw), std::move(outConfigInsertW)));
+        outputSet.insert(std::make_pair(anw, outConfigInsertW));
     }
     std::set<std::pair<native_handle_ptr_wrapper, OutputConfigurationWrapper>> addSet = outputSet;
     std::vector<int32_t> deleteList;
@@ -683,7 +680,7 @@ CameraDevice::configureStreamsLocked(const ACaptureSessionOutputContainer* outpu
     }
 
     // add new streams
-    for (const auto &outputPair : addSet) {
+    for (auto outputPair : addSet) {
         int streamId;
         Status status = Status::UNKNOWN_ERROR;
         auto ret = mRemote->createStream(outputPair.second,
@@ -848,32 +845,12 @@ CameraDevice::onCaptureErrorLocked(
             return;
         }
 
-        // Get the surfaces corresponding to the error stream id, go through
-        // them and try to match the surfaces in the corresponding
-        // CaptureRequest.
-        const auto& errorWindowHandles =
-                outputPairIt->second.second.mOutputConfiguration.windowHandles;
-        for (const auto& errorWindowHandle : errorWindowHandles) {
-            for (const auto &requestStreamAndWindowId :
-                        request->mCaptureRequest.streamAndWindowIds) {
-                // Go through the surfaces in the capture request and see which
-                // ones match the surfaces in the error stream.
-                int32_t requestWindowId = requestStreamAndWindowId.windowId;
-                auto requestSurfacePairIt =
-                        mConfiguredOutputs.find(requestStreamAndWindowId.streamId);
-                if (requestSurfacePairIt == mConfiguredOutputs.end()) {
-                    ALOGE("%s: Error: request stream id %d does not exist", __FUNCTION__,
-                              requestStreamAndWindowId.streamId);
-                    setCameraDeviceErrorLocked(ACAMERA_ERROR_CAMERA_SERVICE);
-                    return;
-                }
-
-                const auto &requestWindowHandles =
-                        requestSurfacePairIt->second.second.mOutputConfiguration.windowHandles;
-                if (utils::isWindowNativeHandleEqual(
-                        requestWindowHandles[requestWindowId], errorWindowHandle)) {
-                    const native_handle_t* anw =
-                            requestWindowHandles[requestWindowId].getNativeHandle();
+        const auto& windowHandles = outputPairIt->second.second.mOutputConfiguration.windowHandles;
+        for (const auto& outHandle : windowHandles) {
+            for (auto streamAndWindowId : request->mCaptureRequest.streamAndWindowIds) {
+                int32_t windowId = streamAndWindowId.windowId;
+                if (utils::isWindowNativeHandleEqual(windowHandles[windowId],outHandle)) {
+                    const native_handle_t* anw = windowHandles[windowId].getNativeHandle();
                     ALOGV("Camera %s Lost output buffer for ANW %p frame %" PRId64,
                             getId(), anw, frameNumber);
 
diff --git a/camera/ndk/ndk_vendor/impl/utils.h b/camera/ndk/ndk_vendor/impl/utils.h
index 62779a4b02..6f5820ecee 100644
--- a/camera/ndk/ndk_vendor/impl/utils.h
+++ b/camera/ndk/ndk_vendor/impl/utils.h
@@ -109,30 +109,8 @@ struct OutputConfigurationWrapper {
         mOutputConfiguration.windowGroupId = -1;
     };
 
-    OutputConfigurationWrapper(const OutputConfigurationWrapper &other) {
-        *this = other;
-    }
-
-    // Needed to make sure that OutputConfiguration in
-    // OutputConfigurationWrapper, when copied doesn't call hidl_handle's
-    // assignment operator / copy constructor, which will lead to native handle
-    // cloning, which is not what we want for app callbacks which have the native
-    // handle as parameter.
-    OutputConfigurationWrapper &operator=(const OutputConfigurationWrapper &other) {
-        const OutputConfiguration &outputConfiguration = other.mOutputConfiguration;
-        mOutputConfiguration.rotation = outputConfiguration.rotation;
-        mOutputConfiguration.isDeferred = outputConfiguration.isDeferred;
-        mOutputConfiguration.width = outputConfiguration.width;
-        mOutputConfiguration.height = outputConfiguration.height;
-        mOutputConfiguration.windowGroupId = outputConfiguration.windowGroupId;
-        mOutputConfiguration.windowHandles.resize(outputConfiguration.windowHandles.size());
-        mOutputConfiguration.physicalCameraId = outputConfiguration.physicalCameraId;
-        size_t i = 0;
-        for (const auto &handle : outputConfiguration.windowHandles) {
-            mOutputConfiguration.windowHandles[i++] = handle.getNativeHandle();
-        }
-        return *this;
-    }
+    OutputConfigurationWrapper(OutputConfiguration &outputConfiguration)
+            : mOutputConfiguration((outputConfiguration)) { }
 
     bool operator ==(const OutputConfiguration &other) const {
         const OutputConfiguration &self = mOutputConfiguration;
diff --git a/camera/tests/CameraBinderTests.cpp b/camera/tests/CameraBinderTests.cpp
index 17ea51270c..9f2f430f62 100644
--- a/camera/tests/CameraBinderTests.cpp
+++ b/camera/tests/CameraBinderTests.cpp
@@ -96,12 +96,6 @@ public:
         return binder::Status::ok();
     };
 
-    virtual binder::Status onTorchStrengthLevelChanged(const String16& /*cameraId*/,
-            int32_t /*torchStrength*/) {
-        // No op
-        return binder::Status::ok();
-    }
-
     virtual binder::Status onCameraAccessPrioritiesChanged() {
         // No op
         return binder::Status::ok();
diff --git a/media/ndk/NdkImage.cpp b/media/ndk/NdkImage.cpp
index 12a0d53f7c..e9fe7615be 100644
--- a/media/ndk/NdkImage.cpp
+++ b/media/ndk/NdkImage.cpp
@@ -25,6 +25,7 @@
 #include <android_media_Utils.h>
 #include <private/android/AHardwareBufferHelpers.h>
 #include <utils/Log.h>
+#include "hardware/camera3.h"
 
 using namespace android;
 
@@ -374,9 +375,9 @@ AImage::getJpegSize() const {
     uint8_t* jpegBuffer = mLockedBuffer->data;
 
     // First check for JPEG transport header at the end of the buffer
-    uint8_t* header = jpegBuffer + (width - sizeof(struct camera3_jpeg_blob_v2));
-    struct camera3_jpeg_blob_v2* blob = (struct camera3_jpeg_blob_v2*)(header);
-    if (blob->jpeg_blob_id == CAMERA3_JPEG_BLOB_ID) {
+    uint8_t* header = jpegBuffer + (width - sizeof(struct camera3_jpeg_blob));
+    struct camera3_jpeg_blob* blob = (struct camera3_jpeg_blob*)(header);
+    if (blob->jpeg_blob_id == 0x00FF) {
         size = blob->jpeg_size;
         ALOGV("%s: Jpeg size = %d", __FUNCTION__, size);
     }
diff --git a/services/camera/libcameraservice/Android.bp b/services/camera/libcameraservice/Android.bp
index 981c56942c..999e6e6594 100644
--- a/services/camera/libcameraservice/Android.bp
+++ b/services/camera/libcameraservice/Android.bp
@@ -42,15 +42,13 @@ cc_library_shared {
 
     srcs: [
         "CameraService.cpp",
-        "CameraServiceWatchdog.cpp",
         "CameraFlashlight.cpp",
         "common/Camera2ClientBase.cpp",
         "common/CameraDeviceBase.cpp",
         "common/CameraOfflineSessionBase.cpp",
         "common/CameraProviderManager.cpp",
+        "common/DepthPhotoProcessor.cpp",
         "common/FrameProcessorBase.cpp",
-        "common/hidl/HidlProviderInfo.cpp",
-        "common/aidl/AidlProviderInfo.cpp",
         "api1/Camera2Client.cpp",
         "api1/client2/Parameters.cpp",
         "api1/client2/FrameProcessor.cpp",
@@ -78,17 +76,15 @@ cc_library_shared {
         "device3/StatusTracker.cpp",
         "device3/Camera3BufferManager.cpp",
         "device3/Camera3StreamSplitter.cpp",
+        "device3/CoordinateMapper.cpp",
+        "device3/DistortionMapper.cpp",
+        "device3/ZoomRatioMapper.cpp",
+        "device3/RotateAndCropMapper.cpp",
         "device3/Camera3OutputStreamInterface.cpp",
         "device3/Camera3OutputUtils.cpp",
         "device3/Camera3DeviceInjectionMethods.cpp",
         "device3/UHRCropAndMeteringRegionMapper.cpp",
-        "device3/PreviewFrameSpacer.cpp",
-        "device3/hidl/HidlCamera3Device.cpp",
-        "device3/hidl/HidlCamera3OfflineSession.cpp",
-        "device3/hidl/HidlCamera3OutputUtils.cpp",
-        "device3/aidl/AidlCamera3Device.cpp",
-        "device3/aidl/AidlCamera3OutputUtils.cpp",
-        "device3/aidl/AidlCamera3OfflineSession.cpp",
+        "device3/PreviewFrameScheduler.cpp",
         "gui/RingBufferConsumer.cpp",
         "hidl/AidlCameraDeviceCallbacks.cpp",
         "hidl/AidlCameraServiceListener.cpp",
@@ -100,20 +96,18 @@ cc_library_shared {
         "utils/CameraTraces.cpp",
         "utils/AutoConditionLock.cpp",
         "utils/SessionConfigurationUtils.cpp",
-        "utils/SessionConfigurationUtilsHidl.cpp",
         "utils/SessionStatsBuilder.cpp",
         "utils/TagMonitor.cpp",
         "utils/LatencyHistogram.cpp",
     ],
 
     header_libs: [
-        "libdynamic_depth-internal_headers",
-        "libdynamic_depth-public_headers",
         "libmediadrm_headers",
         "libmediametrics_headers",
     ],
 
     shared_libs: [
+        "libandroid",
         "libbase",
         "libdl",
         "libexif",
@@ -122,7 +116,6 @@ cc_library_shared {
         "libutilscallstack",
         "libutils",
         "libbinder",
-        "libbinder_ndk",
         "libactivitymanager_aidl",
         "libpermission",
         "libcutils",
@@ -156,23 +149,20 @@ cc_library_shared {
         "android.hardware.camera.provider@2.5",
         "android.hardware.camera.provider@2.6",
         "android.hardware.camera.provider@2.7",
-        "android.hardware.camera.provider-V1-ndk",
         "android.hardware.camera.device@3.2",
         "android.hardware.camera.device@3.3",
         "android.hardware.camera.device@3.4",
         "android.hardware.camera.device@3.5",
         "android.hardware.camera.device@3.6",
         "android.hardware.camera.device@3.7",
-        "android.hardware.camera.device-V1-ndk",
         "media_permission-aidl-cpp",
     ],
 
     static_libs: [
-        "libaidlcommonsupport",
         "libprocessinfoservice_aidl",
         "libbinderthreadstateutils",
         "media_permission-aidl-cpp",
-        "libcameraservice_device_independent",
+        "libcameraservice_host",
     ],
 
     export_shared_lib_headers: [
@@ -187,6 +177,8 @@ cc_library_shared {
     include_dirs: [
         "system/media/private/camera/include",
         "frameworks/native/include/media/openmax",
+        "external/dynamic_depth/includes",
+        "external/dynamic_depth/internal",
     ],
 
     export_include_dirs: ["."],
@@ -201,36 +193,22 @@ cc_library_shared {
 }
 
 cc_library_static {
-    name: "libcameraservice_device_independent",
+    name: "libcameraservice_host",
     host_supported: true,
 
     // Camera service source
 
     srcs: [
-        "common/DepthPhotoProcessor.cpp",
-        "device3/CoordinateMapper.cpp",
-        "device3/DistortionMapper.cpp",
-        "device3/RotateAndCropMapper.cpp",
-        "device3/ZoomRatioMapper.cpp",
         "utils/ExifUtils.cpp",
-        "utils/SessionConfigurationUtilsHost.cpp",
-    ],
-
-    header_libs: [
-        "libdynamic_depth-internal_headers",
-        "libdynamic_depth-public_headers",
     ],
 
     shared_libs: [
         "libbase",
         "libbinder",
         "libcamera_metadata",
-        "libdynamic_depth",
         "libexif",
-        "libjpeg",
         "liblog",
         "libutils",
-        "libxml2",
     ],
 
     include_dirs: [
diff --git a/services/camera/libcameraservice/CameraFlashlight.cpp b/services/camera/libcameraservice/CameraFlashlight.cpp
index ffd38be509..ccdd9e5c62 100644
--- a/services/camera/libcameraservice/CameraFlashlight.cpp
+++ b/services/camera/libcameraservice/CameraFlashlight.cpp
@@ -32,6 +32,8 @@
 
 namespace android {
 
+using hardware::camera::common::V1_0::TorchModeStatus;
+
 /////////////////////////////////////////////////////////////////////
 // CameraFlashlight implementation begins
 // used by camera service to control flashflight.
@@ -117,59 +119,6 @@ status_t CameraFlashlight::setTorchMode(const String8& cameraId, bool enabled) {
     return res;
 }
 
-status_t CameraFlashlight::turnOnTorchWithStrengthLevel(const String8& cameraId,
-            int32_t torchStrength) {
-    if (!mFlashlightMapInitialized) {
-        ALOGE("%s: findFlashUnits() must be called before this method.",
-               __FUNCTION__);
-        return NO_INIT;
-    }
-
-    ALOGV("%s: set torch strength of camera %s to %d", __FUNCTION__,
-            cameraId.string(), torchStrength);
-    status_t res = OK;
-    Mutex::Autolock l(mLock);
-
-    if (mOpenedCameraIds.indexOf(cameraId) != NAME_NOT_FOUND) {
-        ALOGE("%s: Camera device %s is in use, cannot be turned ON.",
-                __FUNCTION__, cameraId.string());
-        return -EBUSY;
-    }
-
-    if (mFlashControl == NULL) {
-        res = createFlashlightControl(cameraId);
-        if (res) {
-            return res;
-        }
-    }
-
-    res = mFlashControl->turnOnTorchWithStrengthLevel(cameraId, torchStrength);
-    return res;
-}
-
-
-status_t CameraFlashlight::getTorchStrengthLevel(const String8& cameraId,
-            int32_t* torchStrength) {
-    status_t res = OK;
-    if (!mFlashlightMapInitialized) {
-        ALOGE("%s: findFlashUnits() must be called before this method.",
-            __FUNCTION__);
-        return false;
-    }
-
-    Mutex::Autolock l(mLock);
-
-    if (mFlashControl == NULL) {
-        res = createFlashlightControl(cameraId);
-        if (res) {
-            return res;
-        }
-    }
-
-    res = mFlashControl->getTorchStrengthLevel(cameraId, torchStrength);
-    return res;
-}
-
 status_t CameraFlashlight::findFlashUnits() {
     Mutex::Autolock l(mLock);
     status_t res;
@@ -357,22 +306,6 @@ status_t ProviderFlashControl::setTorchMode(const String8& cameraId, bool enable
 
     return mProviderManager->setTorchMode(cameraId.string(), enabled);
 }
-
-status_t ProviderFlashControl::turnOnTorchWithStrengthLevel(const String8& cameraId,
-            int32_t torchStrength) {
-    ALOGV("%s: change torch strength level of camera %s to %d", __FUNCTION__,
-            cameraId.string(), torchStrength);
-
-    return mProviderManager->turnOnTorchWithStrengthLevel(cameraId.string(), torchStrength);
-}
-
-status_t ProviderFlashControl::getTorchStrengthLevel(const String8& cameraId,
-            int32_t* torchStrength) {
-    ALOGV("%s: get torch strength level of camera %s", __FUNCTION__,
-            cameraId.string());
-
-    return mProviderManager->getTorchStrengthLevel(cameraId.string(), torchStrength);
-}
 // ProviderFlashControl implementation ends
 
 }
diff --git a/services/camera/libcameraservice/CameraFlashlight.h b/services/camera/libcameraservice/CameraFlashlight.h
index 1703ddc4bb..b97fa5f340 100644
--- a/services/camera/libcameraservice/CameraFlashlight.h
+++ b/services/camera/libcameraservice/CameraFlashlight.h
@@ -44,14 +44,6 @@ class FlashControlBase : public virtual VirtualLightRefBase {
         // set the torch mode to on or off.
         virtual status_t setTorchMode(const String8& cameraId,
                     bool enabled) = 0;
-
-        // Change the brightness level of the torch. If the torch is OFF and
-        // torchStrength >= 1, then the torch will also be turned ON.
-        virtual status_t turnOnTorchWithStrengthLevel(const String8& cameraId,
-                    int32_t torchStrength) = 0;
-
-        // Returns the torch strength level.
-        virtual status_t getTorchStrengthLevel(const String8& cameraId, int32_t* torchStrength) = 0;
 };
 
 /**
@@ -75,12 +67,6 @@ class CameraFlashlight : public virtual VirtualLightRefBase {
         // set the torch mode to on or off.
         status_t setTorchMode(const String8& cameraId, bool enabled);
 
-        // Change the torch strength level of the flash unit in torch mode.
-        status_t turnOnTorchWithStrengthLevel(const String8& cameraId, int32_t torchStrength);
-
-        // Get the torch strength level
-        status_t getTorchStrengthLevel(const String8& cameraId, int32_t* torchStrength);
-
         // Notify CameraFlashlight that camera service is going to open a camera
         // device. CameraFlashlight will free the resources that may cause the
         // camera open to fail. Camera service must call this function before
@@ -129,8 +115,6 @@ class ProviderFlashControl : public FlashControlBase {
         // FlashControlBase
         status_t hasFlashUnit(const String8& cameraId, bool *hasFlash);
         status_t setTorchMode(const String8& cameraId, bool enabled);
-        status_t turnOnTorchWithStrengthLevel(const String8& cameraId, int32_t torchStrength);
-        status_t getTorchStrengthLevel(const String8& cameraId, int32_t* torchStrength);
 
     private:
         sp<CameraProviderManager> mProviderManager;
diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
index 80410ab463..71262cef67 100644
--- a/services/camera/libcameraservice/CameraService.cpp
+++ b/services/camera/libcameraservice/CameraService.cpp
@@ -86,13 +86,13 @@ namespace android {
 
 using base::StringPrintf;
 using binder::Status;
-using namespace camera3;
+using camera3::SessionConfigurationUtils;
 using frameworks::cameraservice::service::V2_0::implementation::HidlCameraService;
 using hardware::ICamera;
 using hardware::ICameraClient;
 using hardware::ICameraServiceListener;
-using hardware::camera2::ICameraInjectionCallback;
-using hardware::camera2::ICameraInjectionSession;
+using hardware::camera::common::V1_0::CameraDeviceStatus;
+using hardware::camera::common::V1_0::TorchModeStatus;
 using hardware::camera2::utils::CameraIdAndSessionConfiguration;
 using hardware::camera2::utils::ConcurrentCameraIdCombination;
 
@@ -129,12 +129,10 @@ static const String16
         sCameraSendSystemEventsPermission("android.permission.CAMERA_SEND_SYSTEM_EVENTS");
 static const String16 sCameraOpenCloseListenerPermission(
         "android.permission.CAMERA_OPEN_CLOSE_LISTENER");
-static const String16
-        sCameraInjectExternalCameraPermission("android.permission.CAMERA_INJECT_EXTERNAL_CAMERA");
+
 const char *sFileName = "lastOpenSessionDumpFile";
-static constexpr int32_t kSystemNativeClientScore = resource_policy::PERCEPTIBLE_APP_ADJ;
-static constexpr int32_t kSystemNativeClientState =
-        ActivityManager::PROCESS_STATE_PERSISTENT_UI;
+static constexpr int32_t kVendorClientScore = resource_policy::PERCEPTIBLE_APP_ADJ;
+static constexpr int32_t kVendorClientState = ActivityManager::PROCESS_STATE_PERSISTENT_UI;
 
 const String8 CameraService::kOfflineDevice("offline-");
 const String16 CameraService::kWatchAllClientsFlag("all");
@@ -156,12 +154,6 @@ CameraService::CameraService() :
     }
 }
 
-// The word 'System' here does not refer to clients only on the system
-// partition. They just need to have a android system uid.
-static bool doesClientHaveSystemUid() {
-    return (CameraThreadState::getCallingUid() < AID_APP_START);
-}
-
 void CameraService::onFirstRef()
 {
 
@@ -185,7 +177,6 @@ void CameraService::onFirstRef()
     mUidPolicy->registerSelf();
     mSensorPrivacyPolicy = new SensorPrivacyPolicy(this);
     mSensorPrivacyPolicy->registerSelf();
-    mInjectionStatusListener = new InjectionStatusListener(this);
     mAppOps.setCameraAudioRestriction(mAudioRestriction);
     sp<HidlCameraService> hcs = HidlCameraService::getInstance(this);
     if (hcs->registerAsService() != android::OK) {
@@ -277,7 +268,6 @@ CameraService::~CameraService() {
     VendorTagDescriptor::clearGlobalVendorTagDescriptor();
     mUidPolicy->unregisterSelf();
     mSensorPrivacyPolicy->unregisterSelf();
-    mInjectionStatusListener->removeListener();
 }
 
 void CameraService::onNewProviderRegistered() {
@@ -368,20 +358,18 @@ void CameraService::filterSPerfClassCharacteristicsLocked() {
 
 void CameraService::addStates(const String8 id) {
     std::string cameraId(id.c_str());
-    CameraResourceCost cost;
+    hardware::camera::common::V1_0::CameraResourceCost cost;
     status_t res = mCameraProviderManager->getResourceCost(cameraId, &cost);
+    SystemCameraKind deviceKind = SystemCameraKind::PUBLIC;
     if (res != OK) {
         ALOGE("Failed to query device resource cost: %s (%d)", strerror(-res), res);
         return;
     }
-    SystemCameraKind deviceKind = SystemCameraKind::PUBLIC;
     res = mCameraProviderManager->getSystemCameraKind(cameraId, &deviceKind);
     if (res != OK) {
         ALOGE("Failed to query device kind: %s (%d)", strerror(-res), res);
         return;
     }
-    std::vector<std::string> physicalCameraIds;
-    mCameraProviderManager->isLogicalCamera(cameraId, &physicalCameraIds);
     std::set<String8> conflicting;
     for (size_t i = 0; i < cost.conflictingDevices.size(); i++) {
         conflicting.emplace(String8(cost.conflictingDevices[i].c_str()));
@@ -390,7 +378,7 @@ void CameraService::addStates(const String8 id) {
     {
         Mutex::Autolock lock(mCameraStatesLock);
         mCameraStates.emplace(id, std::make_shared<CameraState>(id, cost.resourceCost,
-                conflicting, deviceKind, physicalCameraIds));
+                                                                conflicting, deviceKind));
     }
 
     if (mFlashlight->hasFlashUnit(id)) {
@@ -569,22 +557,6 @@ void CameraService::onTorchStatusChanged(const String8& cameraId,
     onTorchStatusChangedLocked(cameraId, newStatus, systemCameraKind);
 }
 
-
-void CameraService::onTorchStatusChanged(const String8& cameraId,
-        TorchModeStatus newStatus, SystemCameraKind systemCameraKind) {
-    Mutex::Autolock al(mTorchStatusMutex);
-    onTorchStatusChangedLocked(cameraId, newStatus, systemCameraKind);
-}
-
-void CameraService::broadcastTorchStrengthLevel(const String8& cameraId,
-        int32_t newStrengthLevel) {
-    Mutex::Autolock lock(mStatusListenerLock);
-    for (auto& i : mListenerList) {
-        i->getListener()->onTorchStrengthLevelChanged(String16{cameraId},
-                newStrengthLevel);
-    }
-}
-
 void CameraService::onTorchStatusChangedLocked(const String8& cameraId,
         TorchModeStatus newStatus, SystemCameraKind systemCameraKind) {
     ALOGI("%s: Torch status changed for cameraId=%s, newStatus=%d",
@@ -820,31 +792,6 @@ Status CameraService::getCameraCharacteristics(const String16& cameraId,
     return ret;
 }
 
-Status CameraService::getTorchStrengthLevel(const String16& cameraId,
-        int32_t* torchStrength) {
-    ATRACE_CALL();
-    Mutex::Autolock l(mServiceLock);
-    if (!mInitialized) {
-        ALOGE("%s: Camera HAL couldn't be initialized.", __FUNCTION__);
-        return STATUS_ERROR(ERROR_DISCONNECTED, "Camera HAL couldn't be initialized.");
-    }
-
-    if(torchStrength == NULL) {
-        ALOGE("%s: strength level must not be null.", __FUNCTION__);
-        return STATUS_ERROR(ERROR_ILLEGAL_ARGUMENT, "Strength level should not be null.");
-    }
-
-    status_t res = mCameraProviderManager->getTorchStrengthLevel(String8(cameraId).string(),
-        torchStrength);
-    if (res != OK) {
-        return STATUS_ERROR_FMT(ERROR_INVALID_OPERATION, "Unable to retrieve torch "
-            "strength level for device %s: %s (%d)", String8(cameraId).string(),
-            strerror(-res), res);
-    }
-    ALOGI("%s: Torch strength level is: %d", __FUNCTION__, *torchStrength);
-    return Status::ok();
-}
-
 String8 CameraService::getFormattedCurrentTime() {
     time_t now = time(nullptr);
     char formattedTime[64];
@@ -887,37 +834,29 @@ void CameraService::clearCachedVariables() {
     BasicClient::BasicClient::sCameraService = nullptr;
 }
 
-std::pair<int, IPCTransport> CameraService::getDeviceVersion(const String8& cameraId, int* facing,
-        int* orientation) {
+int CameraService::getDeviceVersion(const String8& cameraId, int* facing, int* orientation) {
     ATRACE_CALL();
 
     int deviceVersion = 0;
 
     status_t res;
     hardware::hidl_version maxVersion{0,0};
-    IPCTransport transport = IPCTransport::INVALID;
     res = mCameraProviderManager->getHighestSupportedVersion(cameraId.string(),
-            &maxVersion, &transport);
-    if (res != OK || transport == IPCTransport::INVALID) {
-        ALOGE("%s: Unable to get highest supported version for camera id %s", __FUNCTION__,
-                cameraId.string());
-        return std::make_pair(-1, IPCTransport::INVALID) ;
-    }
+            &maxVersion);
+    if (res != OK) return -1;
     deviceVersion = HARDWARE_DEVICE_API_VERSION(maxVersion.get_major(), maxVersion.get_minor());
 
     hardware::CameraInfo info;
     if (facing) {
         res = mCameraProviderManager->getCameraInfo(cameraId.string(), &info);
-        if (res != OK) {
-            return std::make_pair(-1, IPCTransport::INVALID);
-        }
+        if (res != OK) return -1;
         *facing = info.facing;
         if (orientation) {
             *orientation = info.orientation;
         }
     }
 
-    return std::make_pair(deviceVersion, transport);
+    return deviceVersion;
 }
 
 Status CameraService::filterGetInfoErrorCode(status_t err) {
@@ -938,50 +877,48 @@ Status CameraService::filterGetInfoErrorCode(status_t err) {
 }
 
 Status CameraService::makeClient(const sp<CameraService>& cameraService,
-        const sp<IInterface>& cameraCb, const String16& packageName, bool systemNativeClient,
+        const sp<IInterface>& cameraCb, const String16& packageName,
         const std::optional<String16>& featureId,  const String8& cameraId,
         int api1CameraId, int facing, int sensorOrientation, int clientPid, uid_t clientUid,
-        int servicePid, std::pair<int, IPCTransport> deviceVersionAndTransport,
-        apiLevel effectiveApiLevel, bool overrideForPerfClass, /*out*/sp<BasicClient>* client) {
-    // For HIDL devices
-    if (deviceVersionAndTransport.second == IPCTransport::HIDL) {
-        // Create CameraClient based on device version reported by the HAL.
-        int deviceVersion = deviceVersionAndTransport.first;
-        switch(deviceVersion) {
-            case CAMERA_DEVICE_API_VERSION_1_0:
-                ALOGE("Camera using old HAL version: %d", deviceVersion);
-                return STATUS_ERROR_FMT(ERROR_DEPRECATED_HAL,
-                        "Camera device \"%s\" HAL version %d no longer supported",
-                        cameraId.string(), deviceVersion);
-                break;
-            case CAMERA_DEVICE_API_VERSION_3_0:
-            case CAMERA_DEVICE_API_VERSION_3_1:
-            case CAMERA_DEVICE_API_VERSION_3_2:
-            case CAMERA_DEVICE_API_VERSION_3_3:
-            case CAMERA_DEVICE_API_VERSION_3_4:
-            case CAMERA_DEVICE_API_VERSION_3_5:
-            case CAMERA_DEVICE_API_VERSION_3_6:
-            case CAMERA_DEVICE_API_VERSION_3_7:
-                break;
-            default:
-                // Should not be reachable
-                ALOGE("Unknown camera device HAL version: %d", deviceVersion);
-                return STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,
-                        "Camera device \"%s\" has unknown HAL version %d",
-                        cameraId.string(), deviceVersion);
-        }
-    }
-    if (effectiveApiLevel == API_1) { // Camera1 API route
-        sp<ICameraClient> tmp = static_cast<ICameraClient*>(cameraCb.get());
-        *client = new Camera2Client(cameraService, tmp, packageName, featureId,
-                cameraId, api1CameraId, facing, sensorOrientation, clientPid, clientUid,
-                servicePid, overrideForPerfClass);
-    } else { // Camera2 API route
-        sp<hardware::camera2::ICameraDeviceCallbacks> tmp =
-                static_cast<hardware::camera2::ICameraDeviceCallbacks*>(cameraCb.get());
-        *client = new CameraDeviceClient(cameraService, tmp, packageName,
-                systemNativeClient, featureId, cameraId, facing, sensorOrientation,
-                clientPid, clientUid, servicePid, overrideForPerfClass);
+        int servicePid, int deviceVersion, apiLevel effectiveApiLevel, bool overrideForPerfClass,
+        /*out*/sp<BasicClient>* client) {
+
+    // Create CameraClient based on device version reported by the HAL.
+    switch(deviceVersion) {
+        case CAMERA_DEVICE_API_VERSION_1_0:
+            ALOGE("Camera using old HAL version: %d", deviceVersion);
+            return STATUS_ERROR_FMT(ERROR_DEPRECATED_HAL,
+                    "Camera device \"%s\" HAL version %d no longer supported",
+                    cameraId.string(), deviceVersion);
+            break;
+        case CAMERA_DEVICE_API_VERSION_3_0:
+        case CAMERA_DEVICE_API_VERSION_3_1:
+        case CAMERA_DEVICE_API_VERSION_3_2:
+        case CAMERA_DEVICE_API_VERSION_3_3:
+        case CAMERA_DEVICE_API_VERSION_3_4:
+        case CAMERA_DEVICE_API_VERSION_3_5:
+        case CAMERA_DEVICE_API_VERSION_3_6:
+        case CAMERA_DEVICE_API_VERSION_3_7:
+            if (effectiveApiLevel == API_1) { // Camera1 API route
+                sp<ICameraClient> tmp = static_cast<ICameraClient*>(cameraCb.get());
+                *client = new Camera2Client(cameraService, tmp, packageName, featureId,
+                        cameraId, api1CameraId,
+                        facing, sensorOrientation, clientPid, clientUid,
+                        servicePid, overrideForPerfClass);
+            } else { // Camera2 API route
+                sp<hardware::camera2::ICameraDeviceCallbacks> tmp =
+                        static_cast<hardware::camera2::ICameraDeviceCallbacks*>(cameraCb.get());
+                *client = new CameraDeviceClient(cameraService, tmp, packageName, featureId,
+                        cameraId, facing, sensorOrientation, clientPid, clientUid, servicePid,
+                        overrideForPerfClass);
+            }
+            break;
+        default:
+            // Should not be reachable
+            ALOGE("Unknown camera device HAL version: %d", deviceVersion);
+            return STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,
+                    "Camera device \"%s\" has unknown HAL version %d",
+                    cameraId.string(), deviceVersion);
     }
     return Status::ok();
 }
@@ -1069,7 +1006,7 @@ Status CameraService::initializeShimMetadata(int cameraId) {
     sp<Client> tmp = nullptr;
     if (!(ret = connectHelper<ICameraClient,Client>(
             sp<ICameraClient>{nullptr}, id, cameraId,
-            internalPackageName, /*systemNativeClient*/ false, {}, uid, USE_CALLING_PID,
+            internalPackageName, {}, uid, USE_CALLING_PID,
             API_1, /*shimUpdateOnly*/ true, /*oomScoreOffset*/ 0,
             /*targetSdkVersion*/ __ANDROID_API_FUTURE__, /*out*/ tmp)
             ).isOk()) {
@@ -1304,9 +1241,9 @@ Status CameraService::validateClientPermissionsLocked(const String8& cameraId,
 
     userid_t clientUserId = multiuser_get_user_id(clientUid);
 
-    // For non-system clients : Only allow clients who are being used by the current foreground
-    // device user, unless calling from our own process.
-    if (!doesClientHaveSystemUid() && callingPid != getpid() &&
+    // Only allow clients who are being used by the current foreground device user, unless calling
+    // from our own process OR the caller is using the cameraserver's HIDL interface.
+    if (getCurrentServingCall() != BinderCallType::HWBINDER && callingPid != getpid() &&
             (mAllowedUsers.find(clientUserId) == mAllowedUsers.end())) {
         ALOGE("CameraService::connect X (PID %d) rejected (cannot connect from "
                 "device user %d, currently allowed device users: %s)", callingPid, clientUserId,
@@ -1343,12 +1280,12 @@ status_t CameraService::checkIfDeviceIsUsable(const String8& cameraId) const {
 }
 
 void CameraService::finishConnectLocked(const sp<BasicClient>& client,
-        const CameraService::DescriptorPtr& desc, int oomScoreOffset, bool systemNativeClient) {
+        const CameraService::DescriptorPtr& desc, int oomScoreOffset) {
 
     // Make a descriptor for the incoming client
     auto clientDescriptor =
             CameraService::CameraClientManager::makeClientDescriptor(client, desc,
-                    oomScoreOffset, systemNativeClient);
+                    oomScoreOffset);
     auto evicted = mActiveClientManager.addAndEvict(clientDescriptor);
 
     logConnected(desc->getKey(), static_cast<int>(desc->getOwnerId()),
@@ -1378,7 +1315,7 @@ void CameraService::finishConnectLocked(const sp<BasicClient>& client,
 
 status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clientPid,
         apiLevel effectiveApiLevel, const sp<IBinder>& remoteCallback, const String8& packageName,
-        int oomScoreOffset, bool systemNativeClient,
+        int oomScoreOffset,
         /*out*/
         sp<BasicClient>* client,
         std::shared_ptr<resource_policy::ClientDescriptor<String8, sp<BasicClient>>>* partial) {
@@ -1453,7 +1390,7 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
         clientDescriptor = CameraClientManager::makeClientDescriptor(cameraId,
                 sp<BasicClient>{nullptr}, static_cast<int32_t>(state->getCost()),
                 state->getConflicting(), actualScore, clientPid, actualState,
-                oomScoreOffset, systemNativeClient);
+                oomScoreOffset);
 
         resource_policy::ClientPriority clientPriority = clientDescriptor->getPriority();
 
@@ -1596,7 +1533,7 @@ Status CameraService::connect(
     String8 id = cameraIdIntToStr(api1CameraId);
     sp<Client> client = nullptr;
     ret = connectHelper<ICameraClient,Client>(cameraClient, id, api1CameraId,
-            clientPackageName,/*systemNativeClient*/ false, {}, clientUid, clientPid, API_1,
+            clientPackageName, {}, clientUid, clientPid, API_1,
             /*shimUpdateOnly*/ false, /*oomScoreOffset*/ 0, targetSdkVersion, /*out*/client);
 
     if(!ret.isOk()) {
@@ -1628,14 +1565,14 @@ bool CameraService::shouldRejectSystemCameraConnection(const String8& cameraId)
     // 1) If cameraserver tries to access this camera device, accept the
     //    connection.
     // 2) The camera device is a publicly hidden secure camera device AND some
-    //    non system component is trying to access it.
+    //    component is trying to access it on a non-hwbinder thread (generally a non HAL client),
+    //    reject it.
     // 3) if the camera device is advertised by the camera HAL as SYSTEM_ONLY
     //    and the serving thread is a non hwbinder thread, the client must have
     //    android.permission.SYSTEM_CAMERA permissions to connect.
 
     int cPid = CameraThreadState::getCallingPid();
     int cUid = CameraThreadState::getCallingUid();
-    bool systemClient = doesClientHaveSystemUid();
     SystemCameraKind systemCameraKind = SystemCameraKind::PUBLIC;
     if (getSystemCameraKind(cameraId, &systemCameraKind) != OK) {
         // This isn't a known camera ID, so it's not a system camera
@@ -1648,7 +1585,8 @@ bool CameraService::shouldRejectSystemCameraConnection(const String8& cameraId)
         return false;
     }
     // (2)
-    if (!systemClient && systemCameraKind == SystemCameraKind::HIDDEN_SECURE_CAMERA) {
+    if (getCurrentServingCall() != BinderCallType::HWBINDER &&
+            systemCameraKind == SystemCameraKind::HIDDEN_SECURE_CAMERA) {
         ALOGW("Rejecting access to secure hidden camera %s", cameraId.c_str());
         return true;
     }
@@ -1656,7 +1594,8 @@ bool CameraService::shouldRejectSystemCameraConnection(const String8& cameraId)
     //     getCameraCharacteristics() allows for calls to succeed (albeit after hiding some
     //     characteristics) even if clients don't have android.permission.CAMERA. We do not want the
     //     same behavior for system camera devices.
-    if (!systemClient && systemCameraKind == SystemCameraKind::SYSTEM_ONLY_CAMERA &&
+    if (getCurrentServingCall() != BinderCallType::HWBINDER &&
+            systemCameraKind == SystemCameraKind::SYSTEM_ONLY_CAMERA &&
             !hasPermissionsForSystemCamera(cPid, cUid, /*logPermissionFailure*/true)) {
         ALOGW("Rejecting access to system only camera %s, inadequete permissions",
                 cameraId.c_str());
@@ -1681,12 +1620,11 @@ Status CameraService::connectDevice(
     sp<CameraDeviceClient> client = nullptr;
     String16 clientPackageNameAdj = clientPackageName;
     int callingPid = CameraThreadState::getCallingPid();
-    bool systemNativeClient = false;
-    if (doesClientHaveSystemUid() && (clientPackageNameAdj.size() == 0)) {
-        std::string systemClient =
-                StringPrintf("client.pid<%d>", CameraThreadState::getCallingPid());
-        clientPackageNameAdj = String16(systemClient.c_str());
-        systemNativeClient = true;
+
+    if (getCurrentServingCall() == BinderCallType::HWBINDER) {
+        std::string vendorClient =
+                StringPrintf("vendor.client.pid<%d>", CameraThreadState::getCallingPid());
+        clientPackageNameAdj = String16(vendorClient.c_str());
     }
 
     if (oomScoreOffset < 0) {
@@ -1717,7 +1655,7 @@ Status CameraService::connectDevice(
     }
 
     ret = connectHelper<hardware::camera2::ICameraDeviceCallbacks,CameraDeviceClient>(cameraCb, id,
-            /*api1CameraId*/-1, clientPackageNameAdj, systemNativeClient,clientFeatureId,
+            /*api1CameraId*/-1, clientPackageNameAdj, clientFeatureId,
             clientUid, USE_CALLING_PID, API_2, /*shimUpdateOnly*/ false, oomScoreOffset,
             targetSdkVersion, /*out*/client);
 
@@ -1748,7 +1686,7 @@ Status CameraService::connectDevice(
 
 template<class CALLBACK, class CLIENT>
 Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8& cameraId,
-        int api1CameraId, const String16& clientPackageName, bool systemNativeClient,
+        int api1CameraId, const String16& clientPackageName,
         const std::optional<String16>& clientFeatureId, int clientUid, int clientPid,
         apiLevel effectiveApiLevel, bool shimUpdateOnly, int oomScoreOffset, int targetSdkVersion,
         /*out*/sp<CLIENT>& device) {
@@ -1767,7 +1705,7 @@ Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8&
     sp<CLIENT> client = nullptr;
     int facing = -1;
     int orientation = 0;
-    bool isNonSystemNdk = (clientPackageName.size() == 0);
+    bool isNdk = (clientPackageName.size() == 0);
     {
         // Acquire mServiceLock and prevent other clients from connecting
         std::unique_ptr<AutoConditionLock> lock =
@@ -1801,8 +1739,8 @@ Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8&
         sp<BasicClient> clientTmp = nullptr;
         std::shared_ptr<resource_policy::ClientDescriptor<String8, sp<BasicClient>>> partial;
         if ((err = handleEvictionsLocked(cameraId, originalClientPid, effectiveApiLevel,
-                IInterface::asBinder(cameraCb), clientName8, oomScoreOffset, systemNativeClient,
-                /*out*/&clientTmp, /*out*/&partial)) != NO_ERROR) {
+                IInterface::asBinder(cameraCb), clientName8, oomScoreOffset, /*out*/&clientTmp,
+                /*out*/&partial)) != NO_ERROR) {
             switch (err) {
                 case -ENODEV:
                     return STATUS_ERROR_FMT(ERROR_DISCONNECTED,
@@ -1832,8 +1770,7 @@ Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8&
         // give flashlight a chance to close devices if necessary.
         mFlashlight->prepareDeviceOpen(cameraId);
 
-        auto deviceVersionAndTransport =
-                getDeviceVersion(cameraId, /*out*/&facing, /*out*/&orientation);
+        int deviceVersion = getDeviceVersion(cameraId, /*out*/&facing, /*out*/&orientation);
         if (facing == -1) {
             ALOGE("%s: Unable to get camera device \"%s\"  facing", __FUNCTION__, cameraId.string());
             return STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,
@@ -1843,10 +1780,10 @@ Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8&
         sp<BasicClient> tmp = nullptr;
         bool overrideForPerfClass = SessionConfigurationUtils::targetPerfClassPrimaryCamera(
                 mPerfClassPrimaryCameraIds, cameraId.string(), targetSdkVersion);
-        if(!(ret = makeClient(this, cameraCb, clientPackageName, systemNativeClient,
-                clientFeatureId, cameraId, api1CameraId, facing, orientation,
+        if(!(ret = makeClient(this, cameraCb, clientPackageName, clientFeatureId,
+                cameraId, api1CameraId, facing, orientation,
                 clientPid, clientUid, getpid(),
-                deviceVersionAndTransport, effectiveApiLevel, overrideForPerfClass,
+                deviceVersion, effectiveApiLevel, overrideForPerfClass,
                 /*out*/&tmp)).isOk()) {
             return ret;
         }
@@ -1904,7 +1841,8 @@ Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8&
         // Set rotate-and-crop override behavior
         if (mOverrideRotateAndCropMode != ANDROID_SCALER_ROTATE_AND_CROP_AUTO) {
             client->setRotateAndCropOverride(mOverrideRotateAndCropMode);
-        } else {
+        } else if (effectiveApiLevel == API_2) {
+
           client->setRotateAndCropOverride(
               CameraServiceProxyWrapper::getRotateAndCropOverride(
                   clientPackageName, facing, multiuser_get_user_id(clientUid)));
@@ -1945,7 +1883,7 @@ Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8&
             mServiceLock.lock();
         } else {
             // Otherwise, add client to active clients list
-            finishConnectLocked(client, partial, oomScoreOffset, systemNativeClient);
+            finishConnectLocked(client, partial, oomScoreOffset);
         }
 
         client->setImageDumpMask(mImageDumpMask);
@@ -1957,34 +1895,7 @@ Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8&
 
     int32_t openLatencyMs = ns2ms(systemTime() - openTimeNs);
     CameraServiceProxyWrapper::logOpen(cameraId, facing, clientPackageName,
-            effectiveApiLevel, isNonSystemNdk, openLatencyMs);
-
-    {
-        Mutex::Autolock lock(mInjectionParametersLock);
-        if (cameraId == mInjectionInternalCamId && mInjectionInitPending) {
-            mInjectionInitPending = false;
-            status_t res = NO_ERROR;
-            auto clientDescriptor = mActiveClientManager.get(mInjectionInternalCamId);
-            if (clientDescriptor != nullptr) {
-                sp<BasicClient> clientSp = clientDescriptor->getValue();
-                res = checkIfInjectionCameraIsPresent(mInjectionExternalCamId, clientSp);
-                if(res != OK) {
-                    return STATUS_ERROR_FMT(ERROR_DISCONNECTED,
-                            "No camera device with ID \"%s\" currently available",
-                            mInjectionExternalCamId.string());
-                }
-                res = clientSp->injectCamera(mInjectionExternalCamId, mCameraProviderManager);
-                if (res != OK) {
-                    mInjectionStatusListener->notifyInjectionError(mInjectionExternalCamId, res);
-                }
-            } else {
-                ALOGE("%s: Internal camera ID = %s 's client does not exist!",
-                        __FUNCTION__, mInjectionInternalCamId.string());
-                res = NO_INIT;
-                mInjectionStatusListener->notifyInjectionError(mInjectionExternalCamId, res);
-            }
-        }
-    }
+            effectiveApiLevel, isNdk, openLatencyMs);
 
     return ret;
 }
@@ -2020,8 +1931,7 @@ status_t CameraService::addOfflineClient(String8 cameraId, sp<BasicClient> offli
                 kOfflineDevice + onlineClientDesc->getKey(), offlineClient, /*cost*/ 0,
                 /*conflictingKeys*/ std::set<String8>(), onlinePriority.getScore(),
                 onlineClientDesc->getOwnerId(), onlinePriority.getState(),
-                // native clients don't have offline processing support.
-                /*ommScoreOffset*/ 0, /*systemNativeClient*/false);
+                /*ommScoreOffset*/ 0);
 
         // Allow only one offline device per camera
         auto incompatibleClients = mActiveClientManager.getIncompatibleClients(offlineClientDesc);
@@ -2063,136 +1973,6 @@ status_t CameraService::addOfflineClient(String8 cameraId, sp<BasicClient> offli
     return OK;
 }
 
-Status CameraService::turnOnTorchWithStrengthLevel(const String16& cameraId, int32_t torchStrength,
-        const sp<IBinder>& clientBinder) {
-    Mutex::Autolock lock(mServiceLock);
-
-    ATRACE_CALL();
-    if (clientBinder == nullptr) {
-        ALOGE("%s: torch client binder is NULL", __FUNCTION__);
-        return STATUS_ERROR(ERROR_ILLEGAL_ARGUMENT,
-                "Torch client binder in null.");
-    }
-
-    String8 id = String8(cameraId.string());
-    int uid = CameraThreadState::getCallingUid();
-
-    if (shouldRejectSystemCameraConnection(id)) {
-        return STATUS_ERROR_FMT(ERROR_ILLEGAL_ARGUMENT, "Unable to change the strength level"
-                "for system only device %s: ", id.string());
-    }
-
-    // verify id is valid
-    auto state = getCameraState(id);
-    if (state == nullptr) {
-        ALOGE("%s: camera id is invalid %s", __FUNCTION__, id.string());
-        return STATUS_ERROR_FMT(ERROR_ILLEGAL_ARGUMENT,
-            "Camera ID \"%s\" is a not valid camera ID", id.string());
-    }
-
-    StatusInternal cameraStatus = state->getStatus();
-    if (cameraStatus != StatusInternal::NOT_AVAILABLE &&
-            cameraStatus != StatusInternal::PRESENT) {
-        ALOGE("%s: camera id is invalid %s, status %d", __FUNCTION__, id.string(),
-            (int)cameraStatus);
-        return STATUS_ERROR_FMT(ERROR_ILLEGAL_ARGUMENT,
-                "Camera ID \"%s\" is a not valid camera ID", id.string());
-    }
-
-    {
-        Mutex::Autolock al(mTorchStatusMutex);
-        TorchModeStatus status;
-        status_t err = getTorchStatusLocked(id, &status);
-        if (err != OK) {
-            if (err == NAME_NOT_FOUND) {
-             return STATUS_ERROR_FMT(ERROR_ILLEGAL_ARGUMENT,
-                    "Camera \"%s\" does not have a flash unit", id.string());
-            }
-            ALOGE("%s: getting current torch status failed for camera %s",
-                    __FUNCTION__, id.string());
-            return STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,
-                    "Error changing torch strength level for camera \"%s\": %s (%d)",
-                    id.string(), strerror(-err), err);
-        }
-
-        if (status == TorchModeStatus::NOT_AVAILABLE) {
-            if (cameraStatus == StatusInternal::NOT_AVAILABLE) {
-                ALOGE("%s: torch mode of camera %s is not available because "
-                        "camera is in use.", __FUNCTION__, id.string());
-                return STATUS_ERROR_FMT(ERROR_CAMERA_IN_USE,
-                        "Torch for camera \"%s\" is not available due to an existing camera user",
-                        id.string());
-            } else {
-                ALOGE("%s: torch mode of camera %s is not available due to "
-                       "insufficient resources", __FUNCTION__, id.string());
-                return STATUS_ERROR_FMT(ERROR_MAX_CAMERAS_IN_USE,
-                        "Torch for camera \"%s\" is not available due to insufficient resources",
-                        id.string());
-            }
-        }
-    }
-
-    {
-        Mutex::Autolock al(mTorchUidMapMutex);
-        updateTorchUidMapLocked(cameraId, uid);
-    }
-    // Check if the current torch strength level is same as the new one.
-    bool shouldSkipTorchStrengthUpdates = mCameraProviderManager->shouldSkipTorchStrengthUpdate(
-            id.string(), torchStrength);
-
-    status_t err = mFlashlight->turnOnTorchWithStrengthLevel(id, torchStrength);
-
-    if (err != OK) {
-        int32_t errorCode;
-        String8 msg;
-        switch (err) {
-            case -ENOSYS:
-                msg = String8::format("Camera \"%s\" has no flashlight.",
-                    id.string());
-                errorCode = ERROR_ILLEGAL_ARGUMENT;
-                break;
-            case -EBUSY:
-                msg = String8::format("Camera \"%s\" is in use",
-                    id.string());
-                errorCode = ERROR_CAMERA_IN_USE;
-                break;
-            case -EINVAL:
-                msg = String8::format("Torch strength level %d is not within the "
-                        "valid range.", torchStrength);
-                errorCode = ERROR_ILLEGAL_ARGUMENT;
-                break;
-            default:
-                msg = String8::format("Changing torch strength level failed.");
-                errorCode = ERROR_INVALID_OPERATION;
-        }
-        ALOGE("%s: %s", __FUNCTION__, msg.string());
-        return STATUS_ERROR(errorCode, msg.string());
-    }
-
-    {
-        // update the link to client's death
-        // Store the last client that turns on each camera's torch mode.
-        Mutex::Autolock al(mTorchClientMapMutex);
-        ssize_t index = mTorchClientMap.indexOfKey(id);
-        if (index == NAME_NOT_FOUND) {
-            mTorchClientMap.add(id, clientBinder);
-        } else {
-            mTorchClientMap.valueAt(index)->unlinkToDeath(this);
-            mTorchClientMap.replaceValueAt(index, clientBinder);
-        }
-        clientBinder->linkToDeath(this);
-    }
-
-    int clientPid = CameraThreadState::getCallingPid();
-    const char *id_cstr = id.c_str();
-    ALOGI("%s: Torch strength for camera id %s changed to %d for client PID %d",
-            __FUNCTION__, id_cstr, torchStrength, clientPid);
-    if (!shouldSkipTorchStrengthUpdates) {
-        broadcastTorchStrengthLevel(id, torchStrength);
-    }
-    return Status::ok();
-}
-
 Status CameraService::setTorchMode(const String16& cameraId, bool enabled,
         const sp<IBinder>& clientBinder) {
     Mutex::Autolock lock(mServiceLock);
@@ -2264,7 +2044,13 @@ Status CameraService::setTorchMode(const String16& cameraId, bool enabled,
         // Update UID map - this is used in the torch status changed callbacks, so must be done
         // before setTorchMode
         Mutex::Autolock al(mTorchUidMapMutex);
-        updateTorchUidMapLocked(cameraId, uid);
+        if (mTorchUidMap.find(id) == mTorchUidMap.end()) {
+            mTorchUidMap[id].first = uid;
+            mTorchUidMap[id].second = uid;
+        } else {
+            // Set the pending UID
+            mTorchUidMap[id].first = uid;
+        }
     }
 
     status_t err = mFlashlight->setTorchMode(id, enabled);
@@ -2319,17 +2105,6 @@ Status CameraService::setTorchMode(const String16& cameraId, bool enabled,
     return Status::ok();
 }
 
-void CameraService::updateTorchUidMapLocked(const String16& cameraId, int uid) {
-    String8 id = String8(cameraId.string());
-    if (mTorchUidMap.find(id) == mTorchUidMap.end()) {
-        mTorchUidMap[id].first = uid;
-        mTorchUidMap[id].second = uid;
-    } else {
-        // Set the pending UID
-        mTorchUidMap[id].first = uid;
-    }
-}
-
 Status CameraService::notifySystemEvent(int32_t eventId,
         const std::vector<int32_t>& args) {
     const int pid = CameraThreadState::getCallingPid();
@@ -2360,13 +2135,6 @@ Status CameraService::notifySystemEvent(int32_t eventId,
             doUserSwitch(/*newUserIds*/ args);
             break;
         }
-        case ICameraService::EVENT_USB_DEVICE_ATTACHED:
-        case ICameraService::EVENT_USB_DEVICE_DETACHED: {
-            // Notify CameraProviderManager for lazy HALs
-            mCameraProviderManager->notifyUsbDeviceEvent(eventId,
-                                                        std::to_string(args[0]));
-            break;
-        }
         case ICameraService::EVENT_NONE:
         default: {
             ALOGW("%s: Received invalid system event from system_server: %d", __FUNCTION__,
@@ -2409,7 +2177,23 @@ Status CameraService::notifyDeviceStateChange(int64_t newState) {
 
     ATRACE_CALL();
 
-    mCameraProviderManager->notifyDeviceStateChange(newState);
+    using hardware::camera::provider::V2_5::DeviceState;
+    hardware::hidl_bitfield<DeviceState> newDeviceState{};
+    if (newState & ICameraService::DEVICE_STATE_BACK_COVERED) {
+        newDeviceState |= DeviceState::BACK_COVERED;
+    }
+    if (newState & ICameraService::DEVICE_STATE_FRONT_COVERED) {
+        newDeviceState |= DeviceState::FRONT_COVERED;
+    }
+    if (newState & ICameraService::DEVICE_STATE_FOLDED) {
+        newDeviceState |= DeviceState::FOLDED;
+    }
+    // Only map vendor bits directly
+    uint64_t vendorBits = static_cast<uint64_t>(newState) & 0xFFFFFFFF00000000l;
+    newDeviceState |= vendorBits;
+
+    ALOGV("%s: New device state 0x%" PRIx64, __FUNCTION__, newDeviceState);
+    mCameraProviderManager->notifyDeviceStateChange(newDeviceState);
 
     return Status::ok();
 }
@@ -2442,7 +2226,7 @@ Status CameraService::notifyDisplayConfigurationChange() {
     for (auto& current : clients) {
         if (current != nullptr) {
             const auto basicClient = current->getValue();
-            if (basicClient.get() != nullptr) {
+            if (basicClient.get() != nullptr && basicClient->canCastToApiClient(API_2)) {
               basicClient->setRotateAndCropOverride(
                   CameraServiceProxyWrapper::getRotateAndCropOverride(
                       basicClient->getPackageName(),
@@ -2719,48 +2503,44 @@ Status CameraService::supportsCameraApi(const String16& cameraId, int apiVersion
             return STATUS_ERROR(ERROR_ILLEGAL_ARGUMENT, msg.string());
     }
 
-    auto deviceVersionAndTransport = getDeviceVersion(id);
-    if (deviceVersionAndTransport.first == -1) {
-        String8 msg = String8::format("Unknown camera ID %s", id.string());
-        ALOGE("%s: %s", __FUNCTION__, msg.string());
-        return STATUS_ERROR(ERROR_ILLEGAL_ARGUMENT, msg.string());
-    }
-    if (deviceVersionAndTransport.second == IPCTransport::HIDL) {
-        int deviceVersion = deviceVersionAndTransport.first;
-        switch (deviceVersion) {
-            case CAMERA_DEVICE_API_VERSION_1_0:
-            case CAMERA_DEVICE_API_VERSION_3_0:
-            case CAMERA_DEVICE_API_VERSION_3_1:
-                if (apiVersion == API_VERSION_2) {
-                    ALOGV("%s: Camera id %s uses HAL version %d <3.2, doesn't support api2 without "
-                            "shim", __FUNCTION__, id.string(), deviceVersion);
-                    *isSupported = false;
-                } else { // if (apiVersion == API_VERSION_1) {
-                    ALOGV("%s: Camera id %s uses older HAL before 3.2, but api1 is always "
-                            "supported", __FUNCTION__, id.string());
-                    *isSupported = true;
-                }
-                break;
-            case CAMERA_DEVICE_API_VERSION_3_2:
-            case CAMERA_DEVICE_API_VERSION_3_3:
-            case CAMERA_DEVICE_API_VERSION_3_4:
-            case CAMERA_DEVICE_API_VERSION_3_5:
-            case CAMERA_DEVICE_API_VERSION_3_6:
-            case CAMERA_DEVICE_API_VERSION_3_7:
-                ALOGV("%s: Camera id %s uses HAL3.2 or newer, supports api1/api2 directly",
+    int deviceVersion = getDeviceVersion(id);
+    switch (deviceVersion) {
+        case CAMERA_DEVICE_API_VERSION_1_0:
+        case CAMERA_DEVICE_API_VERSION_3_0:
+        case CAMERA_DEVICE_API_VERSION_3_1:
+            if (apiVersion == API_VERSION_2) {
+                ALOGV("%s: Camera id %s uses HAL version %d <3.2, doesn't support api2 without shim",
+                        __FUNCTION__, id.string(), deviceVersion);
+                *isSupported = false;
+            } else { // if (apiVersion == API_VERSION_1) {
+                ALOGV("%s: Camera id %s uses older HAL before 3.2, but api1 is always supported",
                         __FUNCTION__, id.string());
                 *isSupported = true;
-                break;
-            default: {
-                String8 msg = String8::format("Unknown device version %x for device %s",
-                        deviceVersion, id.string());
-                ALOGE("%s: %s", __FUNCTION__, msg.string());
-                return STATUS_ERROR(ERROR_INVALID_OPERATION, msg.string());
             }
+            break;
+        case CAMERA_DEVICE_API_VERSION_3_2:
+        case CAMERA_DEVICE_API_VERSION_3_3:
+        case CAMERA_DEVICE_API_VERSION_3_4:
+        case CAMERA_DEVICE_API_VERSION_3_5:
+        case CAMERA_DEVICE_API_VERSION_3_6:
+        case CAMERA_DEVICE_API_VERSION_3_7:
+            ALOGV("%s: Camera id %s uses HAL3.2 or newer, supports api1/api2 directly",
+                    __FUNCTION__, id.string());
+            *isSupported = true;
+            break;
+        case -1: {
+            String8 msg = String8::format("Unknown camera ID %s", id.string());
+            ALOGE("%s: %s", __FUNCTION__, msg.string());
+            return STATUS_ERROR(ERROR_ILLEGAL_ARGUMENT, msg.string());
+        }
+        default: {
+            String8 msg = String8::format("Unknown device version %x for device %s",
+                    deviceVersion, id.string());
+            ALOGE("%s: %s", __FUNCTION__, msg.string());
+            return STATUS_ERROR(ERROR_INVALID_OPERATION, msg.string());
         }
-    } else {
-        *isSupported = true;
     }
+
     return Status::ok();
 }
 
@@ -2776,60 +2556,6 @@ Status CameraService::isHiddenPhysicalCamera(const String16& cameraId,
     return Status::ok();
 }
 
-Status CameraService::injectCamera(
-        const String16& packageName, const String16& internalCamId,
-        const String16& externalCamId,
-        const sp<ICameraInjectionCallback>& callback,
-        /*out*/
-        sp<ICameraInjectionSession>* cameraInjectionSession) {
-    ATRACE_CALL();
-
-    if (!checkCallingPermission(sCameraInjectExternalCameraPermission)) {
-        const int pid = CameraThreadState::getCallingPid();
-        const int uid = CameraThreadState::getCallingUid();
-        ALOGE("Permission Denial: can't inject camera pid=%d, uid=%d", pid, uid);
-        return STATUS_ERROR(ERROR_PERMISSION_DENIED,
-                        "Permission Denial: no permission to inject camera");
-    }
-
-    ALOGV(
-        "%s: Package name = %s, Internal camera ID = %s, External camera ID = "
-        "%s",
-        __FUNCTION__, String8(packageName).string(),
-        String8(internalCamId).string(), String8(externalCamId).string());
-
-    {
-        Mutex::Autolock lock(mInjectionParametersLock);
-        mInjectionInternalCamId = String8(internalCamId);
-        mInjectionExternalCamId = String8(externalCamId);
-        mInjectionStatusListener->addListener(callback);
-        *cameraInjectionSession = new CameraInjectionSession(this);
-        status_t res = NO_ERROR;
-        auto clientDescriptor = mActiveClientManager.get(mInjectionInternalCamId);
-        // If the client already exists, we can directly connect to the camera device through the
-        // client's injectCamera(), otherwise we need to wait until the client is established
-        // (execute connectHelper()) before injecting the camera to the camera device.
-        if (clientDescriptor != nullptr) {
-            mInjectionInitPending = false;
-            sp<BasicClient> clientSp = clientDescriptor->getValue();
-            res = checkIfInjectionCameraIsPresent(mInjectionExternalCamId, clientSp);
-            if(res != OK) {
-                return STATUS_ERROR_FMT(ERROR_DISCONNECTED,
-                        "No camera device with ID \"%s\" currently available",
-                        mInjectionExternalCamId.string());
-            }
-            res = clientSp->injectCamera(mInjectionExternalCamId, mCameraProviderManager);
-            if(res != OK) {
-                mInjectionStatusListener->notifyInjectionError(mInjectionExternalCamId, res);
-            }
-        } else {
-            mInjectionInitPending = true;
-        }
-    }
-
-    return binder::Status::ok();
-}
-
 void CameraService::removeByClient(const BasicClient* client) {
     Mutex::Autolock lock(mServiceLock);
     for (auto& i : mActiveClientManager.getAll()) {
@@ -3199,7 +2925,7 @@ void CameraService::playSound(sound_kind kind) {
 
 CameraService::Client::Client(const sp<CameraService>& cameraService,
         const sp<ICameraClient>& cameraClient,
-        const String16& clientPackageName, bool systemNativeClient,
+        const String16& clientPackageName,
         const std::optional<String16>& clientFeatureId,
         const String8& cameraIdStr,
         int api1CameraId, int cameraFacing, int sensorOrientation,
@@ -3207,7 +2933,7 @@ CameraService::Client::Client(const sp<CameraService>& cameraService,
         int servicePid) :
         CameraService::BasicClient(cameraService,
                 IInterface::asBinder(cameraClient),
-                clientPackageName, systemNativeClient, clientFeatureId,
+                clientPackageName, clientFeatureId,
                 cameraIdStr, cameraFacing, sensorOrientation,
                 clientPid, clientUid,
                 servicePid),
@@ -3237,14 +2963,13 @@ sp<CameraService> CameraService::BasicClient::BasicClient::sCameraService;
 
 CameraService::BasicClient::BasicClient(const sp<CameraService>& cameraService,
         const sp<IBinder>& remoteCallback,
-        const String16& clientPackageName, bool nativeClient,
-        const std::optional<String16>& clientFeatureId, const String8& cameraIdStr,
-        int cameraFacing, int sensorOrientation, int clientPid, uid_t clientUid,
+        const String16& clientPackageName, const std::optional<String16>& clientFeatureId,
+        const String8& cameraIdStr, int cameraFacing, int sensorOrientation,
+        int clientPid, uid_t clientUid,
         int servicePid):
         mDestructionStarted(false),
         mCameraIdStr(cameraIdStr), mCameraFacing(cameraFacing), mOrientation(sensorOrientation),
-        mClientPackageName(clientPackageName), mSystemNativeClient(nativeClient),
-        mClientFeatureId(clientFeatureId),
+        mClientPackageName(clientPackageName), mClientFeatureId(clientFeatureId),
         mClientPid(clientPid), mClientUid(clientUid),
         mServicePid(servicePid),
         mDisconnected(false), mUidIsTrusted(false),
@@ -3287,19 +3012,7 @@ CameraService::BasicClient::BasicClient(const sp<CameraService>& cameraService,
         }
         mClientPackageName = packages[0];
     }
-
-    // There are 2 scenarios in which a client won't have AppOps operations
-    // (both scenarios : native clients)
-    //    1) It's an system native client*, the package name will be empty
-    //       and it will return from this function in the previous if condition
-    //       (This is the same as the previously existing behavior).
-    //    2) It is a system native client, but its package name has been
-    //       modified for debugging, however it still must not use AppOps since
-    //       the package name is not a real one.
-    //
-    //       * system native client - native client with UID < AID_APP_START. It
-    //         doesn't exclude clients not on the system partition.
-    if (!mSystemNativeClient) {
+    if (getCurrentServingCall() != BinderCallType::HWBINDER) {
         mAppOpsManager = std::make_unique<AppOpsManager>();
     }
 
@@ -3983,10 +3696,9 @@ bool CameraService::SensorPrivacyPolicy::hasCameraPrivacyFeature() {
 // ----------------------------------------------------------------------------
 
 CameraService::CameraState::CameraState(const String8& id, int cost,
-        const std::set<String8>& conflicting, SystemCameraKind systemCameraKind,
-        const std::vector<std::string>& physicalCameras) : mId(id),
+        const std::set<String8>& conflicting, SystemCameraKind systemCameraKind) : mId(id),
         mStatus(StatusInternal::NOT_PRESENT), mCost(cost), mConflicting(conflicting),
-        mSystemCameraKind(systemCameraKind), mPhysicalCameras(physicalCameras) {}
+        mSystemCameraKind(systemCameraKind) {}
 
 CameraService::CameraState::~CameraState() {}
 
@@ -4025,11 +3737,6 @@ SystemCameraKind CameraService::CameraState::getSystemCameraKind() const {
     return mSystemCameraKind;
 }
 
-bool CameraService::CameraState::containsPhysicalCamera(const std::string& physicalCameraId) const {
-    return std::find(mPhysicalCameras.begin(), mPhysicalCameras.end(), physicalCameraId)
-            != mPhysicalCameras.end();
-}
-
 bool CameraService::CameraState::addUnavailablePhysicalId(const String8& physicalId) {
     Mutex::Autolock lock(mStatusLock);
     auto result = mUnavailablePhysicalIds.insert(physicalId);
@@ -4142,140 +3849,25 @@ String8 CameraService::CameraClientManager::toString() const {
 CameraService::DescriptorPtr CameraService::CameraClientManager::makeClientDescriptor(
         const String8& key, const sp<BasicClient>& value, int32_t cost,
         const std::set<String8>& conflictingKeys, int32_t score, int32_t ownerId,
-        int32_t state, int32_t oomScoreOffset, bool systemNativeClient) {
+        int32_t state, int32_t oomScoreOffset) {
 
-    int32_t score_adj = systemNativeClient ? kSystemNativeClientScore : score;
-    int32_t state_adj = systemNativeClient ? kSystemNativeClientState: state;
+    bool isVendorClient = getCurrentServingCall() == BinderCallType::HWBINDER;
+    int32_t score_adj = isVendorClient ? kVendorClientScore : score;
+    int32_t state_adj = isVendorClient ? kVendorClientState: state;
 
     return std::make_shared<resource_policy::ClientDescriptor<String8, sp<BasicClient>>>(
-            key, value, cost, conflictingKeys, score_adj, ownerId, state_adj,
-            systemNativeClient, oomScoreOffset);
+            key, value, cost, conflictingKeys, score_adj, ownerId, state_adj, isVendorClient,
+            oomScoreOffset);
 }
 
 CameraService::DescriptorPtr CameraService::CameraClientManager::makeClientDescriptor(
         const sp<BasicClient>& value, const CameraService::DescriptorPtr& partial,
-        int32_t oomScoreOffset, bool systemNativeClient) {
+        int32_t oomScoreOffset) {
     return makeClientDescriptor(partial->getKey(), value, partial->getCost(),
             partial->getConflicting(), partial->getPriority().getScore(),
-            partial->getOwnerId(), partial->getPriority().getState(), oomScoreOffset,
-            systemNativeClient);
-}
-
-// ----------------------------------------------------------------------------
-//                  InjectionStatusListener
-// ----------------------------------------------------------------------------
-
-void CameraService::InjectionStatusListener::addListener(
-        const sp<ICameraInjectionCallback>& callback) {
-    Mutex::Autolock lock(mListenerLock);
-    if (mCameraInjectionCallback) return;
-    status_t res = IInterface::asBinder(callback)->linkToDeath(this);
-    if (res == OK) {
-        mCameraInjectionCallback = callback;
-    }
-}
-
-void CameraService::InjectionStatusListener::removeListener() {
-    Mutex::Autolock lock(mListenerLock);
-    if (mCameraInjectionCallback == nullptr) {
-        ALOGW("InjectionStatusListener: mCameraInjectionCallback == nullptr");
-        return;
-    }
-    IInterface::asBinder(mCameraInjectionCallback)->unlinkToDeath(this);
-    mCameraInjectionCallback = nullptr;
+            partial->getOwnerId(), partial->getPriority().getState(), oomScoreOffset);
 }
 
-void CameraService::InjectionStatusListener::notifyInjectionError(
-        String8 injectedCamId, status_t err) {
-    if (mCameraInjectionCallback == nullptr) {
-        ALOGW("InjectionStatusListener: mCameraInjectionCallback == nullptr");
-        return;
-    }
-
-    switch (err) {
-        case -ENODEV:
-            mCameraInjectionCallback->onInjectionError(
-                    ICameraInjectionCallback::ERROR_INJECTION_SESSION);
-            ALOGE("No camera device with ID \"%s\" currently available!",
-                    injectedCamId.string());
-            break;
-        case -EBUSY:
-            mCameraInjectionCallback->onInjectionError(
-                    ICameraInjectionCallback::ERROR_INJECTION_SESSION);
-            ALOGE("Higher-priority client using camera, ID \"%s\" currently unavailable!",
-                    injectedCamId.string());
-            break;
-        case DEAD_OBJECT:
-            mCameraInjectionCallback->onInjectionError(
-                    ICameraInjectionCallback::ERROR_INJECTION_SESSION);
-            ALOGE("Camera ID \"%s\" object is dead!",
-                    injectedCamId.string());
-            break;
-        case INVALID_OPERATION:
-            mCameraInjectionCallback->onInjectionError(
-                    ICameraInjectionCallback::ERROR_INJECTION_SESSION);
-            ALOGE("Camera ID \"%s\" encountered an operating or internal error!",
-                    injectedCamId.string());
-            break;
-        case UNKNOWN_TRANSACTION:
-            mCameraInjectionCallback->onInjectionError(
-                    ICameraInjectionCallback::ERROR_INJECTION_UNSUPPORTED);
-            ALOGE("Camera ID \"%s\" method doesn't support!",
-                    injectedCamId.string());
-            break;
-        default:
-            mCameraInjectionCallback->onInjectionError(
-                    ICameraInjectionCallback::ERROR_INJECTION_INVALID_ERROR);
-            ALOGE("Unexpected error %s (%d) opening camera \"%s\"!",
-                    strerror(-err), err, injectedCamId.string());
-    }
-}
-
-void CameraService::InjectionStatusListener::binderDied(
-        const wp<IBinder>& /*who*/) {
-    ALOGV("InjectionStatusListener: ICameraInjectionCallback has died");
-    auto parent = mParent.promote();
-    if (parent != nullptr) {
-        auto clientDescriptor = parent->mActiveClientManager.get(parent->mInjectionInternalCamId);
-        if (clientDescriptor != nullptr) {
-            BasicClient* baseClientPtr = clientDescriptor->getValue().get();
-            baseClientPtr->stopInjection();
-        }
-        parent->clearInjectionParameters();
-    }
-}
-
-// ----------------------------------------------------------------------------
-//                  CameraInjectionSession
-// ----------------------------------------------------------------------------
-
-binder::Status CameraService::CameraInjectionSession::stopInjection() {
-    Mutex::Autolock lock(mInjectionSessionLock);
-    auto parent = mParent.promote();
-    if (parent == nullptr) {
-        ALOGE("CameraInjectionSession: Parent is gone");
-        return STATUS_ERROR(ICameraInjectionCallback::ERROR_INJECTION_SERVICE,
-                "Camera service encountered error");
-    }
-
-    status_t res = NO_ERROR;
-    auto clientDescriptor = parent->mActiveClientManager.get(parent->mInjectionInternalCamId);
-    if (clientDescriptor != nullptr) {
-        BasicClient* baseClientPtr = clientDescriptor->getValue().get();
-        res = baseClientPtr->stopInjection();
-        if (res != OK) {
-            ALOGE("CameraInjectionSession: Failed to stop the injection camera!"
-                " ret != NO_ERROR: %d", res);
-            return STATUS_ERROR(ICameraInjectionCallback::ERROR_INJECTION_SESSION,
-                "Camera session encountered error");
-        }
-    }
-    parent->clearInjectionParameters();
-    return binder::Status::ok();
-}
-
-// ----------------------------------------------------------------------------
-
 static const int kDumpLockRetries = 50;
 static const int kDumpLockSleep = 60000;
 
@@ -4515,20 +4107,12 @@ void CameraService::cacheClientTagDumpIfNeeded(const char *cameraId, BasicClient
 
     if (dumpVector.empty()) { return; }
 
-    std::string dumpString;
-
-    String8 currentTime = getFormattedCurrentTime();
-    dumpString += "Cached @ ";
-    dumpString += currentTime.string();
-    dumpString += "\n"; // First line is the timestamp of when client is cached.
-
-
     const String16 &packageName = client->getPackageName();
 
     String8 packageName8 = String8(packageName);
     const char *printablePackageName = packageName8.lockBuffer(packageName.size());
 
-
+    std::string dumpString;
     size_t i = dumpVector.size();
 
     // Store the string in reverse order (latest last)
@@ -4763,9 +4347,18 @@ std::list<String16> CameraService::getLogicalCameras(
     std::list<String16> retList;
     Mutex::Autolock lock(mCameraStatesLock);
     for (const auto& state : mCameraStates) {
-        if (state.second->containsPhysicalCamera(physicalCameraId.c_str())) {
-            retList.emplace_back(String16(state.first));
+        std::vector<std::string> physicalCameraIds;
+        if (!mCameraProviderManager->isLogicalCamera(state.first.c_str(), &physicalCameraIds)) {
+            // This is not a logical multi-camera.
+            continue;
+        }
+        if (std::find(physicalCameraIds.begin(), physicalCameraIds.end(), physicalCameraId.c_str())
+                == physicalCameraIds.end()) {
+            // cameraId is not a physical camera of this logical multi-camera.
+            continue;
         }
+
+        retList.emplace_back(String16(state.first));
     }
     return retList;
 }
@@ -5377,43 +4970,4 @@ int32_t CameraService::updateAudioRestrictionLocked() {
     return mode;
 }
 
-status_t CameraService::checkIfInjectionCameraIsPresent(const String8& externalCamId,
-        sp<BasicClient> clientSp) {
-    std::unique_ptr<AutoConditionLock> lock =
-            AutoConditionLock::waitAndAcquire(mServiceLockWrapper);
-    status_t res = NO_ERROR;
-    if ((res = checkIfDeviceIsUsable(externalCamId)) != NO_ERROR) {
-        ALOGW("Device %s is not usable!", externalCamId.string());
-        mInjectionStatusListener->notifyInjectionError(
-                externalCamId, UNKNOWN_TRANSACTION);
-        clientSp->notifyError(
-                hardware::camera2::ICameraDeviceCallbacks::ERROR_CAMERA_DISCONNECTED,
-                CaptureResultExtras());
-
-        // Do not hold mServiceLock while disconnecting clients, but retain the condition blocking
-        // other clients from connecting in mServiceLockWrapper if held
-        mServiceLock.unlock();
-
-        // Clear caller identity temporarily so client disconnect PID checks work correctly
-        int64_t token = CameraThreadState::clearCallingIdentity();
-        clientSp->disconnect();
-        CameraThreadState::restoreCallingIdentity(token);
-
-        // Reacquire mServiceLock
-        mServiceLock.lock();
-    }
-
-    return res;
-}
-
-void CameraService::clearInjectionParameters() {
-    {
-        Mutex::Autolock lock(mInjectionParametersLock);
-        mInjectionInitPending = false;
-        mInjectionInternalCamId = "";
-    }
-    mInjectionExternalCamId = "";
-    mInjectionStatusListener->removeListener();
-}
-
 }; // namespace android
diff --git a/services/camera/libcameraservice/CameraService.h b/services/camera/libcameraservice/CameraService.h
index d96ea008bc..49141647a7 100644
--- a/services/camera/libcameraservice/CameraService.h
+++ b/services/camera/libcameraservice/CameraService.h
@@ -20,8 +20,6 @@
 #include <android/hardware/BnCameraService.h>
 #include <android/hardware/BnSensorPrivacyListener.h>
 #include <android/hardware/ICameraServiceListener.h>
-#include <android/hardware/camera2/BnCameraInjectionSession.h>
-#include <android/hardware/camera2/ICameraInjectionCallback.h>
 
 #include <cutils/multiuser.h>
 #include <utils/Vector.h>
@@ -47,7 +45,6 @@
 #include "media/RingBuffer.h"
 #include "utils/AutoConditionLock.h"
 #include "utils/ClientManager.h"
-#include "utils/IPCTransport.h"
 
 #include <set>
 #include <string>
@@ -107,20 +104,12 @@ public:
     // HAL Callbacks - implements CameraProviderManager::StatusListener
 
     virtual void        onDeviceStatusChanged(const String8 &cameraId,
-            CameraDeviceStatus newHalStatus) override;
+            hardware::camera::common::V1_0::CameraDeviceStatus newHalStatus) override;
     virtual void        onDeviceStatusChanged(const String8 &cameraId,
             const String8 &physicalCameraId,
-            CameraDeviceStatus newHalStatus) override;
-    // This method may hold CameraProviderManager::mInterfaceMutex as a part
-    // of calling getSystemCameraKind() internally. Care should be taken not to
-    // directly / indirectly call this from callers who also hold
-    // mInterfaceMutex.
+            hardware::camera::common::V1_0::CameraDeviceStatus newHalStatus) override;
     virtual void        onTorchStatusChanged(const String8& cameraId,
-            TorchModeStatus newStatus) override;
-    // Does not hold CameraProviderManager::mInterfaceMutex.
-    virtual void        onTorchStatusChanged(const String8& cameraId,
-            TorchModeStatus newStatus,
-            SystemCameraKind kind) override;
+            hardware::camera::common::V1_0::TorchModeStatus newStatus) override;
     virtual void        onNewProviderRegistered() override;
 
     /////////////////////////////////////////////////////////////////////
@@ -173,12 +162,6 @@ public:
     virtual binder::Status    setTorchMode(const String16& cameraId, bool enabled,
             const sp<IBinder>& clientBinder);
 
-    virtual binder::Status    turnOnTorchWithStrengthLevel(const String16& cameraId,
-            int32_t torchStrength, const sp<IBinder>& clientBinder);
-
-    virtual binder::Status    getTorchStrengthLevel(const String16& cameraId,
-            int32_t* torchStrength);
-
     virtual binder::Status    notifySystemEvent(int32_t eventId,
             const std::vector<int32_t>& args);
 
@@ -197,13 +180,6 @@ public:
             /*out*/
             bool *isSupported);
 
-    virtual binder::Status injectCamera(
-            const String16& packageName, const String16& internalCamId,
-            const String16& externalCamId,
-            const sp<hardware::camera2::ICameraInjectionCallback>& callback,
-            /*out*/
-            sp<hardware::camera2::ICameraInjectionSession>* cameraInjectionSession);
-
     // Extra permissions checks
     virtual status_t    onTransact(uint32_t code, const Parcel& data,
                                    Parcel* reply, uint32_t flags);
@@ -243,7 +219,7 @@ public:
 
     /////////////////////////////////////////////////////////////////////
     // CameraDeviceFactory functionality
-    std::pair<int, IPCTransport>    getDeviceVersion(const String8& cameraId, int* facing = nullptr,
+    int                 getDeviceVersion(const String8& cameraId, int* facing = nullptr,
             int* orientation = nullptr);
 
     /////////////////////////////////////////////////////////////////////
@@ -339,19 +315,10 @@ public:
         // Set/reset camera mute
         virtual status_t setCameraMute(bool enabled) = 0;
 
-        // The injection camera session to replace the internal camera
-        // session.
-        virtual status_t injectCamera(const String8& injectedCamId,
-                sp<CameraProviderManager> manager) = 0;
-
-        // Stop the injection camera and restore to internal camera session.
-        virtual status_t stopInjection() = 0;
-
     protected:
         BasicClient(const sp<CameraService>& cameraService,
                 const sp<IBinder>& remoteCallback,
                 const String16& clientPackageName,
-                bool nativeClient,
                 const std::optional<String16>& clientFeatureId,
                 const String8& cameraIdStr,
                 int cameraFacing,
@@ -374,7 +341,6 @@ public:
         const int                       mCameraFacing;
         const int                       mOrientation;
         String16                        mClientPackageName;
-        bool                            mSystemNativeClient;
         std::optional<String16>         mClientFeatureId;
         pid_t                           mClientPid;
         const uid_t                     mClientUid;
@@ -462,7 +428,6 @@ public:
         Client(const sp<CameraService>& cameraService,
                 const sp<hardware::ICameraClient>& cameraClient,
                 const String16& clientPackageName,
-                bool systemNativeClient,
                 const std::optional<String16>& clientFeatureId,
                 const String8& cameraIdStr,
                 int api1CameraId,
@@ -546,15 +511,14 @@ public:
          */
         static DescriptorPtr makeClientDescriptor(const String8& key, const sp<BasicClient>& value,
                 int32_t cost, const std::set<String8>& conflictingKeys, int32_t score,
-                int32_t ownerId, int32_t state, int oomScoreOffset, bool systemNativeClient);
+                int32_t ownerId, int32_t state, int oomScoreOffset);
 
         /**
          * Make a ClientDescriptor object wrapping the given BasicClient strong pointer with
          * values intialized from a prior ClientDescriptor.
          */
         static DescriptorPtr makeClientDescriptor(const sp<BasicClient>& value,
-                const CameraService::DescriptorPtr& partial, int oomScoreOffset,
-                bool systemNativeClient);
+                const CameraService::DescriptorPtr& partial, int oomScoreOffset);
 
     }; // class CameraClientManager
 
@@ -563,6 +527,8 @@ public:
 
 private:
 
+    typedef hardware::camera::common::V1_0::CameraDeviceStatus CameraDeviceStatus;
+
     /**
      * Typesafe version of device status, containing both the HAL-layer and the service interface-
      * layer values.
@@ -592,7 +558,7 @@ private:
          * returned in the HAL's camera_info struct for each device.
          */
         CameraState(const String8& id, int cost, const std::set<String8>& conflicting,
-                SystemCameraKind deviceKind, const std::vector<std::string>& physicalCameras);
+                SystemCameraKind deviceKind);
         virtual ~CameraState();
 
         /**
@@ -649,12 +615,6 @@ private:
          */
         SystemCameraKind getSystemCameraKind() const;
 
-        /**
-         * Return whether this camera is a logical multi-camera and has a
-         * particular physical sub-camera.
-         */
-        bool containsPhysicalCamera(const std::string& physicalCameraId) const;
-
         /**
          * Add/Remove the unavailable physical camera ID.
          */
@@ -683,7 +643,6 @@ private:
         mutable Mutex mStatusLock;
         CameraParameters mShimParams;
         const SystemCameraKind mSystemCameraKind;
-        const std::vector<std::string> mPhysicalCameras; // Empty if not a logical multi-camera
     }; // class CameraState
 
     // Observer for UID lifecycle enforcing that UIDs in idle
@@ -796,7 +755,7 @@ private:
     // Only call with with mServiceLock held.
     status_t handleEvictionsLocked(const String8& cameraId, int clientPid,
         apiLevel effectiveApiLevel, const sp<IBinder>& remoteCallback, const String8& packageName,
-        int scoreOffset, bool systemNativeClient,
+        int scoreOffset,
         /*out*/
         sp<BasicClient>* client,
         std::shared_ptr<resource_policy::ClientDescriptor<String8, sp<BasicClient>>>* partial);
@@ -828,7 +787,7 @@ private:
     // Single implementation shared between the various connect calls
     template<class CALLBACK, class CLIENT>
     binder::Status connectHelper(const sp<CALLBACK>& cameraCb, const String8& cameraId,
-            int api1CameraId, const String16& clientPackageName, bool systemNativeClient,
+            int api1CameraId, const String16& clientPackageName,
             const std::optional<String16>& clientFeatureId, int clientUid, int clientPid,
             apiLevel effectiveApiLevel, bool shimUpdateOnly, int scoreOffset, int targetSdkVersion,
             /*out*/sp<CLIENT>& device);
@@ -905,7 +864,7 @@ private:
      * This method must be called with mServiceLock held.
      */
     void finishConnectLocked(const sp<BasicClient>& client, const DescriptorPtr& desc,
-            int oomScoreOffset, bool systemNativeClient);
+            int oomScoreOffset);
 
     /**
      * Returns the underlying camera Id string mapped to a camera id int
@@ -1113,7 +1072,7 @@ private:
     // guard mTorchUidMap
     Mutex                mTorchUidMapMutex;
     // camera id -> torch status
-    KeyedVector<String8, TorchModeStatus>
+    KeyedVector<String8, hardware::camera::common::V1_0::TorchModeStatus>
             mTorchStatusMap;
     // camera id -> torch client binder
     // only store the last client that turns on each camera's torch mode
@@ -1127,16 +1086,16 @@ private:
     // handle torch mode status change and invoke callbacks. mTorchStatusMutex
     // should be locked.
     void onTorchStatusChangedLocked(const String8& cameraId,
-            TorchModeStatus newStatus,
+            hardware::camera::common::V1_0::TorchModeStatus newStatus,
             SystemCameraKind systemCameraKind);
 
     // get a camera's torch status. mTorchStatusMutex should be locked.
     status_t getTorchStatusLocked(const String8 &cameraId,
-             TorchModeStatus *status) const;
+             hardware::camera::common::V1_0::TorchModeStatus *status) const;
 
     // set a camera's torch status. mTorchStatusMutex should be locked.
     status_t setTorchStatusLocked(const String8 &cameraId,
-            TorchModeStatus status);
+            hardware::camera::common::V1_0::TorchModeStatus status);
 
     // notify physical camera status when the physical camera is public.
     // Expects mStatusListenerLock to be locked.
@@ -1239,24 +1198,22 @@ private:
 
     static binder::Status makeClient(const sp<CameraService>& cameraService,
             const sp<IInterface>& cameraCb, const String16& packageName,
-            bool systemNativeClient, const std::optional<String16>& featureId,
-            const String8& cameraId, int api1CameraId, int facing, int sensorOrientation,
-            int clientPid, uid_t clientUid, int servicePid,
-            std::pair<int, IPCTransport> deviceVersionAndIPCTransport, apiLevel effectiveApiLevel,
-            bool overrideForPerfClass, /*out*/sp<BasicClient>* client);
+            const std::optional<String16>& featureId, const String8& cameraId, int api1CameraId,
+            int facing, int sensorOrientation, int clientPid, uid_t clientUid, int servicePid,
+            int deviceVersion, apiLevel effectiveApiLevel, bool overrideForPerfClass,
+            /*out*/sp<BasicClient>* client);
 
     status_t checkCameraAccess(const String16& opPackageName);
 
     static String8 toString(std::set<userid_t> intSet);
-    static int32_t mapToInterface(TorchModeStatus status);
-    static StatusInternal mapToInternal(CameraDeviceStatus status);
+    static int32_t mapToInterface(hardware::camera::common::V1_0::TorchModeStatus status);
+    static StatusInternal mapToInternal(hardware::camera::common::V1_0::CameraDeviceStatus status);
     static int32_t mapToInterface(StatusInternal status);
 
 
     void broadcastTorchModeStatus(const String8& cameraId,
-            TorchModeStatus status, SystemCameraKind systemCameraKind);
-
-    void broadcastTorchStrengthLevel(const String8& cameraId, int32_t newTorchStrengthLevel);
+            hardware::camera::common::V1_0::TorchModeStatus status,
+            SystemCameraKind systemCameraKind);
 
     void disconnectClient(const String8& id, sp<BasicClient> clientToDisconnect);
 
@@ -1283,61 +1240,6 @@ private:
 
     // Current camera mute mode
     bool mOverrideCameraMuteMode = false;
-
-    /**
-     * A listener class that implements the IBinder::DeathRecipient interface
-     * for use to call back the error state injected by the external camera, and
-     * camera service can kill the injection when binder signals process death.
-     */
-    class InjectionStatusListener : public virtual IBinder::DeathRecipient {
-        public:
-            InjectionStatusListener(sp<CameraService> parent) : mParent(parent) {}
-
-            void addListener(const sp<hardware::camera2::ICameraInjectionCallback>& callback);
-            void removeListener();
-            void notifyInjectionError(String8 injectedCamId, status_t err);
-
-            // IBinder::DeathRecipient implementation
-            virtual void binderDied(const wp<IBinder>& who);
-
-        private:
-            Mutex mListenerLock;
-            wp<CameraService> mParent;
-            sp<hardware::camera2::ICameraInjectionCallback> mCameraInjectionCallback;
-    };
-
-    sp<InjectionStatusListener> mInjectionStatusListener;
-
-    /**
-     * A class that implements the hardware::camera2::BnCameraInjectionSession interface
-     */
-    class CameraInjectionSession : public hardware::camera2::BnCameraInjectionSession {
-        public:
-            CameraInjectionSession(sp<CameraService> parent) : mParent(parent) {}
-            virtual ~CameraInjectionSession() {}
-            binder::Status stopInjection() override;
-
-        private:
-            Mutex mInjectionSessionLock;
-            wp<CameraService> mParent;
-    };
-
-    // When injecting the camera, it will check whether the injecting camera status is unavailable.
-    // If it is, the disconnect function will be called to to prevent camera access on the device.
-    status_t checkIfInjectionCameraIsPresent(const String8& externalCamId,
-            sp<BasicClient> clientSp);
-
-    void clearInjectionParameters();
-
-    // This is the existing camera id being replaced.
-    String8 mInjectionInternalCamId;
-    // This is the external camera Id replacing the internalId.
-    String8 mInjectionExternalCamId;
-    bool mInjectionInitPending = false;
-    // Guard mInjectionInternalCamId and mInjectionInitPending.
-    Mutex mInjectionParametersLock;
-
-    void updateTorchUidMapLocked(const String16& cameraId, int uid);
 };
 
 } // namespace android
diff --git a/services/camera/libcameraservice/CameraServiceWatchdog.cpp b/services/camera/libcameraservice/CameraServiceWatchdog.cpp
deleted file mode 100644
index a1696678c0..0000000000
--- a/services/camera/libcameraservice/CameraServiceWatchdog.cpp
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "CameraServiceWatchdog"
-
-#include "CameraServiceWatchdog.h"
-
-namespace android {
-
-bool CameraServiceWatchdog::threadLoop()
-{
-    {
-        AutoMutex _l(mWatchdogLock);
-
-        while (mPause) {
-            mWatchdogCondition.wait(mWatchdogLock);
-        }
-    }
-
-    std::this_thread::sleep_for(std::chrono::milliseconds(mCycleLengthMs));
-
-    {
-        AutoMutex _l(mWatchdogLock);
-
-        for (auto it = tidToCycleCounterMap.begin(); it != tidToCycleCounterMap.end(); it++) {
-            uint32_t currentThreadId = it->first;
-
-            tidToCycleCounterMap[currentThreadId]++;
-
-            if (tidToCycleCounterMap[currentThreadId] >= mMaxCycles) {
-                ALOGW("CameraServiceWatchdog triggering abort for pid: %d", getpid());
-                // We use abort here so we can get a tombstone for better
-                // debugging.
-                abort();
-            }
-        }
-    }
-
-    return true;
-}
-
-void CameraServiceWatchdog::requestExit()
-{
-    Thread::requestExit();
-
-    AutoMutex _l(mWatchdogLock);
-
-    tidToCycleCounterMap.clear();
-
-    if (mPause) {
-        mPause = false;
-        mWatchdogCondition.signal();
-    }
-}
-
-void CameraServiceWatchdog::stop(uint32_t tid)
-{
-    AutoMutex _l(mWatchdogLock);
-
-    tidToCycleCounterMap.erase(tid);
-
-    if (tidToCycleCounterMap.empty()) {
-        mPause = true;
-    }
-}
-
-void CameraServiceWatchdog::start(uint32_t tid)
-{
-    AutoMutex _l(mWatchdogLock);
-
-    tidToCycleCounterMap[tid] = 0;
-
-    if (mPause) {
-        mPause = false;
-        mWatchdogCondition.signal();
-    }
-}
-
-}   // namespace android
diff --git a/services/camera/libcameraservice/CameraServiceWatchdog.h b/services/camera/libcameraservice/CameraServiceWatchdog.h
deleted file mode 100644
index f4955e2d15..0000000000
--- a/services/camera/libcameraservice/CameraServiceWatchdog.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * The CameraService watchdog is used to help detect bad states in the
- * Camera HAL. The threadloop uses cycle counters, assigned to each calling
- * thread, to monitor the elapsing time and kills the process when the
- * expected duration has exceeded.
- * Notes on multi-threaded behaviors:
- *    - The threadloop is blocked/paused when there are no calls being
- *   monitored.
- *   - The start and stop functions handle simultaneous call monitoring
- *   and single call monitoring differently. See function documentation for
- *   more details.
- */
-
-#include <chrono>
-#include <thread>
-#include <time.h>
-#include <utils/Thread.h>
-#include <utils/Log.h>
-#include <unordered_map>
-
-// Used to wrap the call of interest in start and stop calls
-#define WATCH(toMonitor) watchThread([&]() { return toMonitor;}, gettid())
-#define WATCH_CUSTOM_TIMER(toMonitor, cycles, cycleLength) \
-        watchThread([&]() { return toMonitor;}, gettid(), cycles, cycleLength);
-
-// Default cycles and cycle length values used to calculate permitted elapsed time
-const static size_t   kMaxCycles     = 100;
-const static uint32_t kCycleLengthMs = 100;
-
-namespace android {
-
-class CameraServiceWatchdog : public Thread {
-
-public:
-    explicit CameraServiceWatchdog() : mPause(true), mMaxCycles(kMaxCycles),
-            mCycleLengthMs(kCycleLengthMs) {};
-
-    explicit CameraServiceWatchdog (size_t maxCycles, uint32_t cycleLengthMs) :
-            mPause(true), mMaxCycles(maxCycles), mCycleLengthMs(cycleLengthMs) {};
-
-    virtual ~CameraServiceWatchdog() {};
-
-    virtual void requestExit();
-
-    /** Used to wrap monitored calls in start and stop functions using custom timer values */
-    template<typename T>
-    auto watchThread(T func, uint32_t tid, uint32_t cycles, uint32_t cycleLength) {
-        auto res = NULL;
-
-        if (cycles != mMaxCycles || cycleLength != mCycleLengthMs) {
-            // Create another instance of the watchdog to prevent disruption
-            // of timer for current monitored calls
-            sp<CameraServiceWatchdog> tempWatchdog =
-                    new CameraServiceWatchdog(cycles, cycleLength);
-            tempWatchdog->run("CameraServiceWatchdog");
-            res = tempWatchdog->watchThread(func, tid);
-            tempWatchdog->requestExit();
-            tempWatchdog.clear();
-        } else {
-            // If custom timer values are equivalent to set class timer values, use
-            // current thread
-            res = watchThread(func, tid);
-        }
-
-        return res;
-    }
-
-    /** Used to wrap monitored calls in start and stop functions using class timer values */
-    template<typename T>
-    auto watchThread(T func, uint32_t tid) {
-        auto res = NULL;
-
-        start(tid);
-        res = func();
-        stop(tid);
-
-        return res;
-    }
-
-private:
-
-    /**
-     * Start adds a cycle counter for the calling thread. When threadloop is blocked/paused,
-     * start() unblocks and starts the watchdog
-     */
-    void start(uint32_t tid);
-
-    /**
-     * If there are no calls left to be monitored, stop blocks/pauses threadloop
-     * otherwise stop() erases the cycle counter to end watchdog for the calling thread
-     */
-    void stop(uint32_t tid);
-
-    virtual bool    threadLoop();
-
-    Mutex           mWatchdogLock;        // Lock for condition variable
-    Condition       mWatchdogCondition;   // Condition variable for stop/start
-    bool            mPause;               // True if thread is currently paused
-    uint32_t        mMaxCycles;           // Max cycles
-    uint32_t        mCycleLengthMs;       // Length of time elapsed per cycle
-
-    std::unordered_map<uint32_t, uint32_t> tidToCycleCounterMap; // Thread Id to cycle counter map
-};
-
-}   // namespace android
diff --git a/services/camera/libcameraservice/api1/Camera2Client.cpp b/services/camera/libcameraservice/api1/Camera2Client.cpp
index 68dc7f8900..8c72bd7213 100644
--- a/services/camera/libcameraservice/api1/Camera2Client.cpp
+++ b/services/camera/libcameraservice/api1/Camera2Client.cpp
@@ -22,7 +22,6 @@
 #include <utils/Log.h>
 #include <utils/Trace.h>
 
-#include <camera/CameraUtils.h>
 #include <cutils/properties.h>
 #include <gui/Surface.h>
 #include <android/hardware/camera2/ICameraDeviceCallbacks.h>
@@ -34,7 +33,6 @@
 #include "api1/client2/CaptureSequencer.h"
 #include "api1/client2/CallbackProcessor.h"
 #include "api1/client2/ZslProcessor.h"
-#include "device3/RotateAndCropMapper.h"
 #include "utils/CameraThreadState.h"
 #include "utils/CameraServiceProxyWrapper.h"
 
@@ -62,18 +60,13 @@ Camera2Client::Camera2Client(const sp<CameraService>& cameraService,
         uid_t clientUid,
         int servicePid,
         bool overrideForPerfClass):
-        Camera2ClientBase(cameraService, cameraClient, clientPackageName,
-                false/*systemNativeClient - since no ndk for api1*/, clientFeatureId,
-                cameraDeviceId, api1CameraId, cameraFacing, sensorOrientation, clientPid,
-                clientUid, servicePid, overrideForPerfClass, /*legacyClient*/ true),
+        Camera2ClientBase(cameraService, cameraClient, clientPackageName, clientFeatureId,
+                cameraDeviceId, api1CameraId, cameraFacing, sensorOrientation,
+                clientPid, clientUid, servicePid, overrideForPerfClass, /*legacyClient*/ true),
         mParameters(api1CameraId, cameraFacing)
 {
     ATRACE_CALL();
 
-    mRotateAndCropMode = ANDROID_SCALER_ROTATE_AND_CROP_NONE;
-    mRotateAndCropIsSupported = false;
-    mRotateAndCropPreviewTransform = 0;
-
     SharedParameters::Lock l(mParameters);
     l.mParameters.state = Parameters::DISCONNECTED;
 }
@@ -112,7 +105,7 @@ status_t Camera2Client::initializeImpl(TProviderPtr providerPtr, const String8&
     {
         SharedParameters::Lock l(mParameters);
 
-        res = l.mParameters.initialize(mDevice.get());
+        res = l.mParameters.initialize(mDevice.get(), mDeviceVersion);
         if (res != OK) {
             ALOGE("%s: Camera %d: unable to build defaults: %s (%d)",
                     __FUNCTION__, mCameraId, strerror(-res), res);
@@ -122,14 +115,6 @@ status_t Camera2Client::initializeImpl(TProviderPtr providerPtr, const String8&
         l.mParameters.isDeviceZslSupported = isZslEnabledInStillTemplate();
     }
 
-    const CameraMetadata& staticInfo = mDevice->info();
-    mRotateAndCropIsSupported = camera3::RotateAndCropMapper::isNeeded(&staticInfo);
-    // The 'mRotateAndCropMode' value only accounts for the necessary adjustment
-    // when the display rotates. The sensor orientation still needs to be calculated
-    // and applied similar to the Camera2 path.
-    CameraUtils::getRotationTransform(staticInfo, OutputConfiguration::MIRROR_MODE_AUTO,
-            &mRotateAndCropPreviewTransform);
-
     String8 threadName;
 
     mStreamingProcessor = new StreamingProcessor(this);
@@ -1689,14 +1674,6 @@ status_t Camera2Client::commandSetDisplayOrientationL(int degrees) {
                 __FUNCTION__, mCameraId, degrees);
         return BAD_VALUE;
     }
-    {
-        Mutex::Autolock icl(mRotateAndCropLock);
-        if (mRotateAndCropMode != ANDROID_SCALER_ROTATE_AND_CROP_NONE) {
-            ALOGI("%s: Rotate and crop set to: %d, skipping display orientation!", __FUNCTION__,
-                    mRotateAndCropMode);
-            transform = mRotateAndCropPreviewTransform;
-        }
-    }
     SharedParameters::Lock l(mParameters);
     if (transform != l.mParameters.previewTransform &&
             getPreviewStreamId() != NO_STREAM) {
@@ -2319,16 +2296,6 @@ int32_t Camera2Client::getGlobalAudioRestriction() {
 status_t Camera2Client::setRotateAndCropOverride(uint8_t rotateAndCrop) {
     if (rotateAndCrop > ANDROID_SCALER_ROTATE_AND_CROP_AUTO) return BAD_VALUE;
 
-    {
-        Mutex::Autolock icl(mRotateAndCropLock);
-        if (mRotateAndCropIsSupported) {
-            mRotateAndCropMode = rotateAndCrop;
-        } else {
-            mRotateAndCropMode = ANDROID_SCALER_ROTATE_AND_CROP_NONE;
-            return OK;
-        }
-    }
-
     return mDevice->setRotateAndCropAutoBehavior(
         static_cast<camera_metadata_enum_android_scaler_rotate_and_crop_t>(rotateAndCrop));
 }
diff --git a/services/camera/libcameraservice/api1/Camera2Client.h b/services/camera/libcameraservice/api1/Camera2Client.h
index c8dfc46625..64ab8ff7c2 100644
--- a/services/camera/libcameraservice/api1/Camera2Client.h
+++ b/services/camera/libcameraservice/api1/Camera2Client.h
@@ -238,15 +238,6 @@ private:
     status_t initializeImpl(TProviderPtr providerPtr, const String8& monitorTags);
 
     bool isZslEnabledInStillTemplate();
-    // The current rotate & crop mode passed by camera service
-    uint8_t mRotateAndCropMode;
-    // Synchronize access to 'mRotateAndCropMode'
-    mutable Mutex mRotateAndCropLock;
-    // Contains the preview stream transformation that would normally be applied
-    // when the display rotation is 0
-    int mRotateAndCropPreviewTransform;
-    // Flag indicating camera device support for the rotate & crop interface
-    bool mRotateAndCropIsSupported;
 
     mutable Mutex mLatestRequestMutex;
     Condition mLatestRequestSignal;
diff --git a/services/camera/libcameraservice/api1/client2/JpegProcessor.cpp b/services/camera/libcameraservice/api1/client2/JpegProcessor.cpp
index 467108dcc1..eed2654476 100755
--- a/services/camera/libcameraservice/api1/client2/JpegProcessor.cpp
+++ b/services/camera/libcameraservice/api1/client2/JpegProcessor.cpp
@@ -20,9 +20,6 @@
 
 #include <netinet/in.h>
 
-#include <aidl/android/hardware/camera/device/CameraBlob.h>
-#include <aidl/android/hardware/camera/device/CameraBlobId.h>
-
 #include <binder/MemoryBase.h>
 #include <binder/MemoryHeapBase.h>
 #include <utils/Log.h>
@@ -39,8 +36,6 @@ namespace android {
 namespace camera2 {
 
 using android::camera3::CAMERA_STREAM_ROTATION_0;
-using aidl::android::hardware::camera::device::CameraBlob;
-using aidl::android::hardware::camera::device::CameraBlobId;
 
 JpegProcessor::JpegProcessor(
     sp<Camera2Client> client,
@@ -83,8 +78,7 @@ status_t JpegProcessor::updateStream(const Parameters &params) {
     }
 
     // Find out buffer size for JPEG
-    ssize_t maxJpegSize = device->getJpegBufferSize(device->infoPhysical(String8("")),
-            params.pictureWidth, params.pictureHeight);
+    ssize_t maxJpegSize = device->getJpegBufferSize(params.pictureWidth, params.pictureHeight);
     if (maxJpegSize <= 0) {
         ALOGE("%s: Camera %d: Jpeg buffer size (%zu) is invalid ",
                 __FUNCTION__, mId, maxJpegSize);
@@ -355,11 +349,11 @@ size_t JpegProcessor::findJpegSize(uint8_t* jpegBuffer, size_t maxSize) {
     size_t size;
 
     // First check for JPEG transport header at the end of the buffer
-    uint8_t *header = jpegBuffer + (maxSize - sizeof(CameraBlob));
-    CameraBlob *blob = (CameraBlob*)(header);
-    if (blob->blobId == CameraBlobId::JPEG) {
-        size = blob->blobSizeBytes;
-        if (size > 0 && size <= maxSize - sizeof(CameraBlob)) {
+    uint8_t *header = jpegBuffer + (maxSize - sizeof(struct camera2_jpeg_blob));
+    struct camera2_jpeg_blob *blob = (struct camera2_jpeg_blob*)(header);
+    if (blob->jpeg_blob_id == CAMERA2_JPEG_BLOB_ID) {
+        size = blob->jpeg_size;
+        if (size > 0 && size <= maxSize - sizeof(struct camera2_jpeg_blob)) {
             // Verify SOI and EOI markers
             size_t offset = size - MARKER_LENGTH;
             uint8_t *end = jpegBuffer + offset;
diff --git a/services/camera/libcameraservice/api1/client2/Parameters.cpp b/services/camera/libcameraservice/api1/client2/Parameters.cpp
index 123cd757e8..a406e62863 100644
--- a/services/camera/libcameraservice/api1/client2/Parameters.cpp
+++ b/services/camera/libcameraservice/api1/client2/Parameters.cpp
@@ -50,7 +50,7 @@ Parameters::Parameters(int cameraId,
 Parameters::~Parameters() {
 }
 
-status_t Parameters::initialize(CameraDeviceBase *device) {
+status_t Parameters::initialize(CameraDeviceBase *device, int deviceVersion) {
     status_t res;
     if (device == nullptr) {
         ALOGE("%s: device is null!", __FUNCTION__);
@@ -63,6 +63,7 @@ status_t Parameters::initialize(CameraDeviceBase *device) {
         return BAD_VALUE;
     }
     Parameters::info = &info;
+    mDeviceVersion = deviceVersion;
 
     res = buildFastInfo(device);
     if (res != OK) return res;
@@ -74,43 +75,23 @@ status_t Parameters::initialize(CameraDeviceBase *device) {
     // Treat the H.264 max size as the max supported video size.
     MediaProfiles *videoEncoderProfiles = MediaProfiles::getInstance();
     Vector<video_encoder> encoders = videoEncoderProfiles->getVideoEncoders();
-    int32_t minVideoWidth = MAX_PREVIEW_WIDTH;
-    int32_t minVideoHeight = MAX_PREVIEW_HEIGHT;
     int32_t maxVideoWidth = 0;
     int32_t maxVideoHeight = 0;
     for (size_t i = 0; i < encoders.size(); i++) {
-        int w0 = videoEncoderProfiles->getVideoEncoderParamByName(
-                "enc.vid.width.min", encoders[i]);
-        int h0 = videoEncoderProfiles->getVideoEncoderParamByName(
-                "enc.vid.height.min", encoders[i]);
-        int w1 = videoEncoderProfiles->getVideoEncoderParamByName(
+        int width = videoEncoderProfiles->getVideoEncoderParamByName(
                 "enc.vid.width.max", encoders[i]);
-        int h1 = videoEncoderProfiles->getVideoEncoderParamByName(
+        int height = videoEncoderProfiles->getVideoEncoderParamByName(
                 "enc.vid.height.max", encoders[i]);
-        // Assume the min size is 0 if it's not reported by encoder
-        if (w0 == -1) {
-            w0 = 0;
-        }
-        if (h0 == -1) {
-            h0 = 0;
-        }
         // Treat width/height separately here to handle the case where different
-        // profile might report min/max size of different aspect ratio
-        if (w0 < minVideoWidth) {
-            minVideoWidth = w0;
-        }
-        if (h0 < minVideoHeight) {
-            minVideoHeight = h0;
-        }
-        if (w1 > maxVideoWidth) {
-            maxVideoWidth = w1;
+        // profile might report max size of different aspect ratio
+        if (width > maxVideoWidth) {
+            maxVideoWidth = width;
         }
-        if (h1 > maxVideoHeight) {
-            maxVideoHeight = h1;
+        if (height > maxVideoHeight) {
+            maxVideoHeight = height;
         }
     }
-    // These are upper/lower bounds and may not be an actually valid video size
-    const Size VIDEO_SIZE_LOWER_BOUND = {minVideoWidth, minVideoHeight};
+    // This is just an upper bound and may not be an actually valid video size
     Size videoSizeUpperBound = {maxVideoWidth, maxVideoHeight};
 
     if (fastInfo.supportsPreferredConfigs) {
@@ -118,10 +99,9 @@ status_t Parameters::initialize(CameraDeviceBase *device) {
         videoSizeUpperBound = getMaxSize(getPreferredVideoSizes());
     }
 
-    res = getFilteredSizes(Size{0, 0}, maxPreviewSize, &availablePreviewSizes);
+    res = getFilteredSizes(maxPreviewSize, &availablePreviewSizes);
     if (res != OK) return res;
-    res = getFilteredSizes(
-        VIDEO_SIZE_LOWER_BOUND, videoSizeUpperBound, &availableVideoSizes);
+    res = getFilteredSizes(videoSizeUpperBound, &availableVideoSizes);
     if (res != OK) return res;
 
     // Select initial preview and video size that's under the initial bound and
@@ -1075,8 +1055,7 @@ status_t Parameters::buildFastInfo(CameraDeviceBase *device) {
     if (fastInfo.supportsPreferredConfigs) {
         previewSizeBound = getMaxSize(getPreferredPreviewSizes());
     }
-    status_t res = getFilteredSizes(
-        Size{0, 0}, previewSizeBound, &supportedPreviewSizes);
+    status_t res = getFilteredSizes(previewSizeBound, &supportedPreviewSizes);
     if (res != OK) return res;
     for (size_t i=0; i < availableFpsRanges.count; i += 2) {
         if (!isFpsSupported(supportedPreviewSizes,
@@ -3019,8 +2998,7 @@ int Parameters::arrayYToNormalizedWithCrop(int y,
     }
 }
 
-status_t Parameters::getFilteredSizes(const Size &lower, const Size &upper,
-        Vector<Size> *sizes) {
+status_t Parameters::getFilteredSizes(Size limit, Vector<Size> *sizes) {
     if (info == NULL) {
         ALOGE("%s: Static metadata is not initialized", __FUNCTION__);
         return NO_INIT;
@@ -3036,8 +3014,7 @@ status_t Parameters::getFilteredSizes(const Size &lower, const Size &upper,
         const StreamConfiguration &sc = scs[i];
         if (sc.isInput == ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT &&
                 sc.format == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED &&
-                ((sc.width * sc.height) >= (lower.width * lower.height)) &&
-                ((sc.width * sc.height) <= (upper.width * upper.height))) {
+                ((sc.width * sc.height) <= (limit.width * limit.height))) {
             int64_t minFrameDuration = getMinFrameDurationNs(
                     {sc.width, sc.height}, HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED);
             if (minFrameDuration > MAX_PREVIEW_RECORD_DURATION_NS) {
diff --git a/services/camera/libcameraservice/api1/client2/Parameters.h b/services/camera/libcameraservice/api1/client2/Parameters.h
index cbe62a7754..1b2cedad90 100644
--- a/services/camera/libcameraservice/api1/client2/Parameters.h
+++ b/services/camera/libcameraservice/api1/client2/Parameters.h
@@ -269,7 +269,7 @@ struct Parameters {
     ~Parameters();
 
     // Sets up default parameters
-    status_t initialize(CameraDeviceBase *device);
+    status_t initialize(CameraDeviceBase *device, int deviceVersion);
 
     // Build fast-access device static info from static info
     status_t buildFastInfo(CameraDeviceBase *device);
@@ -396,10 +396,9 @@ private:
 
     Vector<Size> availablePreviewSizes;
     Vector<Size> availableVideoSizes;
-    // Get size list (that fall within lower/upper bounds) from static metadata.
+    // Get size list (that are no larger than limit) from static metadata.
     // This method filtered size with minFrameDuration < MAX_PREVIEW_RECORD_DURATION_NS
-    status_t getFilteredSizes(const Size &lower, const Size &upper,
-            Vector<Size> *sizes);
+    status_t getFilteredSizes(Size limit, Vector<Size> *sizes);
     // Get max size (from the size array) that matches the given aspect ratio.
     Size getMaxSizeForRatio(float ratio, const int32_t* sizeArray, size_t count);
 
@@ -459,6 +458,7 @@ private:
     // Helper function to get the suggested video sizes
     Vector<Size> getPreferredVideoSizes() const;
 
+    int mDeviceVersion;
     uint8_t mDefaultSceneMode;
 };
 
diff --git a/services/camera/libcameraservice/api2/CameraDeviceClient.cpp b/services/camera/libcameraservice/api2/CameraDeviceClient.cpp
index 5e9150143a..075e2d734a 100644
--- a/services/camera/libcameraservice/api2/CameraDeviceClient.cpp
+++ b/services/camera/libcameraservice/api2/CameraDeviceClient.cpp
@@ -51,14 +51,13 @@
 
 namespace android {
 using namespace camera2;
-using namespace camera3;
 using camera3::camera_stream_rotation_t::CAMERA_STREAM_ROTATION_0;
+using camera3::SessionConfigurationUtils;
 
 CameraDeviceClientBase::CameraDeviceClientBase(
         const sp<CameraService>& cameraService,
         const sp<hardware::camera2::ICameraDeviceCallbacks>& remoteCallback,
         const String16& clientPackageName,
-        bool systemNativeClient,
         const std::optional<String16>& clientFeatureId,
         const String8& cameraId,
         int api1CameraId,
@@ -70,7 +69,6 @@ CameraDeviceClientBase::CameraDeviceClientBase(
     BasicClient(cameraService,
             IInterface::asBinder(remoteCallback),
             clientPackageName,
-            systemNativeClient,
             clientFeatureId,
             cameraId,
             cameraFacing,
@@ -88,7 +86,6 @@ CameraDeviceClientBase::CameraDeviceClientBase(
 CameraDeviceClient::CameraDeviceClient(const sp<CameraService>& cameraService,
         const sp<hardware::camera2::ICameraDeviceCallbacks>& remoteCallback,
         const String16& clientPackageName,
-        bool systemNativeClient,
         const std::optional<String16>& clientFeatureId,
         const String8& cameraId,
         int cameraFacing,
@@ -97,8 +94,8 @@ CameraDeviceClient::CameraDeviceClient(const sp<CameraService>& cameraService,
         uid_t clientUid,
         int servicePid,
         bool overrideForPerfClass) :
-    Camera2ClientBase(cameraService, remoteCallback, clientPackageName, systemNativeClient,
-                clientFeatureId, cameraId, /*API1 camera ID*/ -1, cameraFacing, sensorOrientation,
+    Camera2ClientBase(cameraService, remoteCallback, clientPackageName, clientFeatureId,
+                cameraId, /*API1 camera ID*/ -1, cameraFacing, sensorOrientation,
                 clientPid, clientUid, servicePid, overrideForPerfClass),
     mInputStream(),
     mStreamingRequestId(REQUEST_ID_NONE),
@@ -143,40 +140,6 @@ status_t CameraDeviceClient::initializeImpl(TProviderPtr providerPtr, const Stri
                 physicalKeysEntry.data.i32 + physicalKeysEntry.count);
     }
 
-    auto entry = deviceInfo.find(ANDROID_REQUEST_AVAILABLE_CAPABILITIES);
-    mDynamicProfileMap.emplace(
-            ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD,
-            ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD);
-    if (entry.count > 0) {
-        const auto it = std::find(entry.data.u8, entry.data.u8 + entry.count,
-                ANDROID_REQUEST_AVAILABLE_CAPABILITIES_DYNAMIC_RANGE_TEN_BIT);
-        if (it != entry.data.u8 + entry.count) {
-            entry = deviceInfo.find(ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP);
-            if (entry.count > 0 || ((entry.count % 3) != 0)) {
-                int64_t standardBitmap =
-                        ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD;
-                for (size_t i = 0; i < entry.count; i += 3) {
-                    if (entry.data.i64[i] !=
-                            ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD) {
-                        mDynamicProfileMap.emplace(entry.data.i64[i], entry.data.i64[i+1]);
-                        if ((entry.data.i64[i+1] == 0) || (entry.data.i64[i+1] &
-                                ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD)) {
-                            standardBitmap |= entry.data.i64[i];
-                        }
-                    } else {
-                        ALOGE("%s: Device %s includes unexpected profile entry: 0x%" PRIx64 "!",
-                                __FUNCTION__, mCameraIdStr.c_str(), entry.data.i64[i]);
-                    }
-                }
-                mDynamicProfileMap[ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD] =
-                        standardBitmap;
-            } else {
-                ALOGE("%s: Device %s supports 10-bit output but doesn't include a dynamic range"
-                        " profile map!", __FUNCTION__, mCameraIdStr.c_str());
-            }
-        }
-    }
-
     mProviderManager = providerPtr;
     // Cache physical camera ids corresponding to this device and also the high
     // resolution sensors in this device + physical camera ids
@@ -209,7 +172,6 @@ binder::Status CameraDeviceClient::insertGbpLocked(const sp<IGraphicBufferProduc
     int compositeIdx;
     int idx = mStreamMap.indexOfKey(IInterface::asBinder(gbp));
 
-    Mutex::Autolock l(mCompositeLock);
     // Trying to submit request with surface that wasn't created
     if (idx == NAME_NOT_FOUND) {
         ALOGE("%s: Camera %s: Tried to submit a request with a surface that"
@@ -335,7 +297,6 @@ binder::Status CameraDeviceClient::submitRequestList(
         SurfaceMap surfaceMap;
         Vector<int32_t> outputStreamIds;
         std::vector<std::string> requestedPhysicalIds;
-        int64_t dynamicProfileBitmap = 0;
         if (request.mSurfaceList.size() > 0) {
             for (const sp<Surface>& surface : request.mSurfaceList) {
                 if (surface == 0) continue;
@@ -352,8 +313,6 @@ binder::Status CameraDeviceClient::submitRequestList(
                     String8 requestedPhysicalId(
                             mConfiguredOutputs.valueAt(index).getPhysicalCameraId());
                     requestedPhysicalIds.push_back(requestedPhysicalId.string());
-                    dynamicProfileBitmap |=
-                            mConfiguredOutputs.valueAt(index).getDynamicRangeProfile();
                 } else {
                     ALOGW("%s: Output stream Id not found among configured outputs!", __FUNCTION__);
                 }
@@ -389,41 +348,6 @@ binder::Status CameraDeviceClient::submitRequestList(
                 String8 requestedPhysicalId(
                         mConfiguredOutputs.valueAt(index).getPhysicalCameraId());
                 requestedPhysicalIds.push_back(requestedPhysicalId.string());
-                dynamicProfileBitmap |=
-                        mConfiguredOutputs.valueAt(index).getDynamicRangeProfile();
-            }
-        }
-
-        if (dynamicProfileBitmap !=
-                    ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD) {
-            for (int i = ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD;
-                    i < ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_MAX; i <<= 1) {
-                if ((dynamicProfileBitmap & i) == 0) {
-                    continue;
-                }
-
-                const auto& it = mDynamicProfileMap.find(i);
-                if (it != mDynamicProfileMap.end()) {
-                    if ((it->second == 0) ||
-                            ((it->second & dynamicProfileBitmap) == dynamicProfileBitmap)) {
-                        continue;
-                    } else {
-                        ALOGE("%s: Camera %s: Tried to submit a request with a surfaces that"
-                                " reference an unsupported dynamic range profile combination"
-                                " 0x%" PRIx64 "!", __FUNCTION__, mCameraIdStr.string(),
-                                dynamicProfileBitmap);
-                        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,
-                                "Request targets an unsupported dynamic range profile"
-                                " combination");
-                    }
-                } else {
-                    ALOGE("%s: Camera %s: Tried to submit a request with a surface that"
-                            " references unsupported dynamic range profile 0x%x!",
-                            __FUNCTION__, mCameraIdStr.string(), i);
-                    return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,
-                            "Request targets 10-bit Surface with unsupported dynamic range"
-                            " profile");
-                }
             }
         }
 
@@ -455,12 +379,6 @@ binder::Status CameraDeviceClient::submitRequestList(
             }
 
             String8 physicalId(it.id.c_str());
-            bool hasTestPatternModePhysicalKey = std::find(mSupportedPhysicalRequestKeys.begin(),
-                    mSupportedPhysicalRequestKeys.end(), ANDROID_SENSOR_TEST_PATTERN_MODE) !=
-                    mSupportedPhysicalRequestKeys.end();
-            bool hasTestPatternDataPhysicalKey = std::find(mSupportedPhysicalRequestKeys.begin(),
-                    mSupportedPhysicalRequestKeys.end(), ANDROID_SENSOR_TEST_PATTERN_DATA) !=
-                    mSupportedPhysicalRequestKeys.end();
             if (physicalId != mDevice->getId()) {
                 auto found = std::find(requestedPhysicalIds.begin(), requestedPhysicalIds.end(),
                         it.id);
@@ -486,8 +404,7 @@ binder::Status CameraDeviceClient::submitRequestList(
                         }
                     }
 
-                    physicalSettingsList.push_back({it.id, filteredParams,
-                            hasTestPatternModePhysicalKey, hasTestPatternDataPhysicalKey});
+                    physicalSettingsList.push_back({it.id, filteredParams});
                 }
             } else {
                 physicalSettingsList.push_back({it.id, it.settings});
@@ -517,17 +434,6 @@ binder::Status CameraDeviceClient::submitRequestList(
 
         metadataRequestList.push_back(physicalSettingsList);
         surfaceMapList.push_back(surfaceMap);
-
-        // Save certain CaptureRequest settings
-        if (!request.mUserTag.empty()) {
-            mUserTag = request.mUserTag;
-        }
-        camera_metadata_entry entry =
-                physicalSettingsList.begin()->metadata.find(
-                        ANDROID_CONTROL_VIDEO_STABILIZATION_MODE);
-        if (entry.count == 1) {
-            mVideoStabilizationMode = entry.data.u8[0];
-        }
     }
     mRequestIdCounter++;
 
@@ -655,7 +561,6 @@ binder::Status CameraDeviceClient::endConfigure(int operatingMode,
         offlineStreamIds->clear();
         mDevice->getOfflineStreamIds(offlineStreamIds);
 
-        Mutex::Autolock l(mCompositeLock);
         for (size_t i = 0; i < mCompositeStreamMap.size(); ++i) {
             err = mCompositeStreamMap.valueAt(i)->configureStream();
             if (err != OK) {
@@ -726,11 +631,27 @@ binder::Status CameraDeviceClient::isSessionConfigurationSupported(
         return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());
     }
 
-    *status = false;
+    hardware::camera::device::V3_7::StreamConfiguration streamConfiguration;
+    bool earlyExit = false;
     camera3::metadataGetter getMetadata = [this](const String8 &id, bool /*overrideForPerfClass*/) {
           return mDevice->infoPhysical(id);};
+    std::vector<std::string> physicalCameraIds;
+    mProviderManager->isLogicalCamera(mCameraIdStr.string(), &physicalCameraIds);
+    res = SessionConfigurationUtils::convertToHALStreamCombination(sessionConfiguration,
+            mCameraIdStr, mDevice->info(), getMetadata, physicalCameraIds, streamConfiguration,
+            mOverrideForPerfClass, &earlyExit);
+    if (!res.isOk()) {
+        return res;
+    }
+
+    if (earlyExit) {
+        *status = false;
+        return binder::Status::ok();
+    }
+
+    *status = false;
     ret = mProviderManager->isSessionConfigurationSupported(mCameraIdStr.string(),
-            sessionConfiguration, mOverrideForPerfClass, getMetadata, status);
+            streamConfiguration, status);
     switch (ret) {
         case OK:
             // Expected, do nothing.
@@ -792,7 +713,6 @@ binder::Status CameraDeviceClient::deleteStream(int streamId) {
             }
         }
 
-        Mutex::Autolock l(mCompositeLock);
         for (size_t i = 0; i < mCompositeStreamMap.size(); ++i) {
             if (streamId == mCompositeStreamMap.valueAt(i)->getStreamId()) {
                 compositeIndex = i;
@@ -831,7 +751,6 @@ binder::Status CameraDeviceClient::deleteStream(int streamId) {
             }
 
             if (compositeIndex != NAME_NOT_FOUND) {
-                Mutex::Autolock l(mCompositeLock);
                 status_t ret;
                 if ((ret = mCompositeStreamMap.valueAt(compositeIndex)->deleteStream())
                         != OK) {
@@ -875,10 +794,6 @@ binder::Status CameraDeviceClient::createStream(
     String8 physicalCameraId = String8(outputConfiguration.getPhysicalCameraId());
     bool deferredConsumerOnly = deferredConsumer && numBufferProducers == 0;
     bool isMultiResolution = outputConfiguration.isMultiResolution();
-    int64_t dynamicRangeProfile = outputConfiguration.getDynamicRangeProfile();
-    int64_t streamUseCase = outputConfiguration.getStreamUseCase();
-    int timestampBase = outputConfiguration.getTimestampBase();
-    int mirrorMode = outputConfiguration.getMirrorMode();
 
     res = SessionConfigurationUtils::checkSurfaceType(numBufferProducers, deferredConsumer,
             outputConfiguration.getSurfaceType());
@@ -922,8 +837,7 @@ binder::Status CameraDeviceClient::createStream(
         sp<Surface> surface;
         res = SessionConfigurationUtils::createSurfaceFromGbp(streamInfo,
                 isStreamInfoValid, surface, bufferProducer, mCameraIdStr,
-                mDevice->infoPhysical(physicalCameraId), sensorPixelModesUsed, dynamicRangeProfile,
-                streamUseCase, timestampBase, mirrorMode);
+                mDevice->infoPhysical(physicalCameraId), sensorPixelModesUsed);
 
         if (!res.isOk())
             return res;
@@ -959,7 +873,6 @@ binder::Status CameraDeviceClient::createStream(
                 &streamId, physicalCameraId, streamInfo.sensorPixelModesUsed, &surfaceIds,
                 outputConfiguration.getSurfaceSetID(), isShared, isMultiResolution);
         if (err == OK) {
-            Mutex::Autolock l(mCompositeLock);
             mCompositeStreamMap.add(IInterface::asBinder(surfaces[0]->getIGraphicBufferProducer()),
                     compositeStream);
         }
@@ -968,9 +881,7 @@ binder::Status CameraDeviceClient::createStream(
                 streamInfo.height, streamInfo.format, streamInfo.dataSpace,
                 static_cast<camera_stream_rotation_t>(outputConfiguration.getRotation()),
                 &streamId, physicalCameraId, streamInfo.sensorPixelModesUsed, &surfaceIds,
-                outputConfiguration.getSurfaceSetID(), isShared, isMultiResolution,
-                /*consumerUsage*/0, streamInfo.dynamicRangeProfile, streamInfo.streamUseCase,
-                streamInfo.timestampBase, streamInfo.mirrorMode);
+                outputConfiguration.getSurfaceSetID(), isShared, isMultiResolution);
     }
 
     if (err != OK) {
@@ -996,7 +907,7 @@ binder::Status CameraDeviceClient::createStream(
                   streamInfo.height, streamInfo.format);
 
         // Set transform flags to ensure preview to be rotated correctly.
-        res = setStreamTransformLocked(streamId, streamInfo.mirrorMode);
+        res = setStreamTransformLocked(streamId);
 
         // Fill in mHighResolutionCameraIdToStreamIdSet map
         const String8 &cameraIdUsed =
@@ -1064,10 +975,7 @@ binder::Status CameraDeviceClient::createDeferredSurfaceStreamLocked(
             overriddenSensorPixelModesUsed,
             &surfaceIds,
             outputConfiguration.getSurfaceSetID(), isShared,
-            outputConfiguration.isMultiResolution(), consumerUsage,
-            outputConfiguration.getDynamicRangeProfile(),
-            outputConfiguration.getStreamUseCase(),
-            outputConfiguration.getMirrorMode());
+            outputConfiguration.isMultiResolution(), consumerUsage);
 
     if (err != OK) {
         res = STATUS_ERROR_FMT(CameraService::ERROR_INVALID_OPERATION,
@@ -1080,18 +988,14 @@ binder::Status CameraDeviceClient::createDeferredSurfaceStreamLocked(
         mDeferredStreams.push_back(streamId);
         mStreamInfoMap.emplace(std::piecewise_construct, std::forward_as_tuple(streamId),
                 std::forward_as_tuple(width, height, format, dataSpace, consumerUsage,
-                        overriddenSensorPixelModesUsed,
-                        outputConfiguration.getDynamicRangeProfile(),
-                        outputConfiguration.getStreamUseCase(),
-                        outputConfiguration.getTimestampBase(),
-                        outputConfiguration.getMirrorMode()));
+                        overriddenSensorPixelModesUsed));
 
         ALOGV("%s: Camera %s: Successfully created a new stream ID %d for a deferred surface"
                 " (%d x %d) stream with format 0x%x.",
               __FUNCTION__, mCameraIdStr.string(), streamId, width, height, format);
 
         // Set transform flags to ensure preview to be rotated correctly.
-        res = setStreamTransformLocked(streamId, outputConfiguration.getMirrorMode());
+        res = setStreamTransformLocked(streamId);
 
         *newStreamId = streamId;
         // Fill in mHighResolutionCameraIdToStreamIdSet
@@ -1105,7 +1009,7 @@ binder::Status CameraDeviceClient::createDeferredSurfaceStreamLocked(
     return res;
 }
 
-binder::Status CameraDeviceClient::setStreamTransformLocked(int streamId, int mirrorMode) {
+binder::Status CameraDeviceClient::setStreamTransformLocked(int streamId) {
     int32_t transform = 0;
     status_t err;
     binder::Status res;
@@ -1114,7 +1018,7 @@ binder::Status CameraDeviceClient::setStreamTransformLocked(int streamId, int mi
         return STATUS_ERROR(CameraService::ERROR_DISCONNECTED, "Camera device no longer alive");
     }
 
-    err = getRotationTransformLocked(mirrorMode, &transform);
+    err = getRotationTransformLocked(&transform);
     if (err != OK) {
         // Error logged by getRotationTransformLocked.
         return STATUS_ERROR(CameraService::ERROR_INVALID_OPERATION,
@@ -1272,18 +1176,13 @@ binder::Status CameraDeviceClient::updateOutputConfiguration(int streamId,
     }
     const std::vector<int32_t> &sensorPixelModesUsed =
             outputConfiguration.getSensorPixelModesUsed();
-    int64_t streamUseCase = outputConfiguration.getStreamUseCase();
-    int timestampBase = outputConfiguration.getTimestampBase();
-    int64_t dynamicRangeProfile = outputConfiguration.getDynamicRangeProfile();
-    int mirrorMode = outputConfiguration.getMirrorMode();
 
     for (size_t i = 0; i < newOutputsMap.size(); i++) {
         OutputStreamInfo outInfo;
         sp<Surface> surface;
         res = SessionConfigurationUtils::createSurfaceFromGbp(outInfo,
                 /*isStreamInfoValid*/ false, surface, newOutputsMap.valueAt(i), mCameraIdStr,
-                mDevice->infoPhysical(physicalCameraId), sensorPixelModesUsed, dynamicRangeProfile,
-                streamUseCase, timestampBase, mirrorMode);
+                mDevice->infoPhysical(physicalCameraId), sensorPixelModesUsed);
         if (!res.isOk())
             return res;
 
@@ -1640,10 +1539,6 @@ binder::Status CameraDeviceClient::finalizeOutputConfigurations(int32_t streamId
     std::vector<sp<Surface>> consumerSurfaces;
     const std::vector<int32_t> &sensorPixelModesUsed =
             outputConfiguration.getSensorPixelModesUsed();
-    int64_t dynamicRangeProfile = outputConfiguration.getDynamicRangeProfile();
-    int64_t streamUseCase= outputConfiguration.getStreamUseCase();
-    int timestampBase = outputConfiguration.getTimestampBase();
-    int mirrorMode = outputConfiguration.getMirrorMode();
     for (auto& bufferProducer : bufferProducers) {
         // Don't create multiple streams for the same target surface
         ssize_t index = mStreamMap.indexOfKey(IInterface::asBinder(bufferProducer));
@@ -1656,8 +1551,7 @@ binder::Status CameraDeviceClient::finalizeOutputConfigurations(int32_t streamId
         sp<Surface> surface;
         res = SessionConfigurationUtils::createSurfaceFromGbp(mStreamInfoMap[streamId],
                 true /*isStreamInfoValid*/, surface, bufferProducer, mCameraIdStr,
-                mDevice->infoPhysical(physicalId), sensorPixelModesUsed, dynamicRangeProfile,
-                streamUseCase, timestampBase, mirrorMode);
+                mDevice->infoPhysical(physicalId), sensorPixelModesUsed);
 
         if (!res.isOk())
             return res;
@@ -1792,9 +1686,8 @@ binder::Status CameraDeviceClient::switchToOffline(
             return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());
         }
 
-        Mutex::Autolock l(mCompositeLock);
         bool isCompositeStream = false;
-        for (const auto& gbp : mConfiguredOutputs.valueAt(index).getGraphicBufferProducers()) {
+        for (const auto& gbp : mConfiguredOutputs[streamId].getGraphicBufferProducers()) {
             sp<Surface> s = new Surface(gbp, false /*controlledByApp*/);
             isCompositeStream = camera3::DepthCompositeStream::isDepthCompositeStream(s) ||
                 camera3::HeicCompositeStream::isHeicCompositeStream(s);
@@ -1843,7 +1736,6 @@ binder::Status CameraDeviceClient::switchToOffline(
         mConfiguredOutputs.clear();
         mDeferredStreams.clear();
         mStreamInfoMap.clear();
-        Mutex::Autolock l(mCompositeLock);
         mCompositeStreamMap.clear();
         mInputStream = {false, 0, 0, 0, 0};
     } else {
@@ -1939,16 +1831,11 @@ void CameraDeviceClient::notifyError(int32_t errorCode,
     // Thread safe. Don't bother locking.
     sp<hardware::camera2::ICameraDeviceCallbacks> remoteCb = getRemoteCallback();
 
+    // Composites can have multiple internal streams. Error notifications coming from such internal
+    // streams may need to remain within camera service.
     bool skipClientNotification = false;
-    {
-        // Access to the composite stream map must be synchronized
-        Mutex::Autolock l(mCompositeLock);
-        // Composites can have multiple internal streams. Error notifications coming from such
-        // internal streams may need to remain within camera service.
-        for (size_t i = 0; i < mCompositeStreamMap.size(); i++) {
-            skipClientNotification |= mCompositeStreamMap.valueAt(i)->onError(errorCode,
-                    resultExtras);
-        }
+    for (size_t i = 0; i < mCompositeStreamMap.size(); i++) {
+        skipClientNotification |= mCompositeStreamMap.valueAt(i)->onError(errorCode, resultExtras);
     }
 
     if ((remoteCb != 0) && (!skipClientNotification)) {
@@ -1976,8 +1863,7 @@ void CameraDeviceClient::notifyIdle(
     if (remoteCb != 0) {
         remoteCb->onDeviceIdle();
     }
-    Camera2ClientBase::notifyIdleWithUserTag(requestCount, resultErrorCount, deviceError,
-            streamStats, mUserTag, mVideoStabilizationMode);
+    Camera2ClientBase::notifyIdle(requestCount, resultErrorCount, deviceError, streamStats);
 }
 
 void CameraDeviceClient::notifyShutter(const CaptureResultExtras& resultExtras,
@@ -1989,8 +1875,6 @@ void CameraDeviceClient::notifyShutter(const CaptureResultExtras& resultExtras,
     }
     Camera2ClientBase::notifyShutter(resultExtras, timestamp);
 
-    // Access to the composite stream map must be synchronized
-    Mutex::Autolock l(mCompositeLock);
     for (size_t i = 0; i < mCompositeStreamMap.size(); i++) {
         mCompositeStreamMap.valueAt(i)->onShutter(resultExtras, timestamp);
     }
@@ -2018,15 +1902,13 @@ void CameraDeviceClient::detachDevice() {
     nsecs_t startTime = systemTime();
     ALOGV("Camera %s: Stopping processors", mCameraIdStr.string());
 
-    if (mFrameProcessor.get() != nullptr) {
-        mFrameProcessor->removeListener(
-                camera2::FrameProcessorBase::FRAME_PROCESSOR_LISTENER_MIN_ID,
-                camera2::FrameProcessorBase::FRAME_PROCESSOR_LISTENER_MAX_ID, /*listener*/this);
-        mFrameProcessor->requestExit();
-        ALOGV("Camera %s: Waiting for threads", mCameraIdStr.string());
-        mFrameProcessor->join();
-        ALOGV("Camera %s: Disconnecting device", mCameraIdStr.string());
-    }
+    mFrameProcessor->removeListener(camera2::FrameProcessorBase::FRAME_PROCESSOR_LISTENER_MIN_ID,
+                                    camera2::FrameProcessorBase::FRAME_PROCESSOR_LISTENER_MAX_ID,
+                                    /*listener*/this);
+    mFrameProcessor->requestExit();
+    ALOGV("Camera %s: Waiting for threads", mCameraIdStr.string());
+    mFrameProcessor->join();
+    ALOGV("Camera %s: Disconnecting device", mCameraIdStr.string());
 
     // WORKAROUND: HAL refuses to disconnect while there's streams in flight
     {
@@ -2042,17 +1924,14 @@ void CameraDeviceClient::detachDevice() {
         }
     }
 
-    {
-        Mutex::Autolock l(mCompositeLock);
-        for (size_t i = 0; i < mCompositeStreamMap.size(); i++) {
-            auto ret = mCompositeStreamMap.valueAt(i)->deleteInternalStreams();
-            if (ret != OK) {
-                ALOGE("%s: Failed removing composite stream  %s (%d)", __FUNCTION__,
-                        strerror(-ret), ret);
-            }
+    for (size_t i = 0; i < mCompositeStreamMap.size(); i++) {
+        auto ret = mCompositeStreamMap.valueAt(i)->deleteInternalStreams();
+        if (ret != OK) {
+            ALOGE("%s: Failed removing composite stream  %s (%d)", __FUNCTION__,
+                    strerror(-ret), ret);
         }
-        mCompositeStreamMap.clear();
     }
+    mCompositeStreamMap.clear();
 
     Camera2ClientBase::detachDevice();
 
@@ -2072,8 +1951,6 @@ void CameraDeviceClient::onResultAvailable(const CaptureResult& result) {
                 result.mPhysicalMetadatas);
     }
 
-    // Access to the composite stream map must be synchronized
-    Mutex::Autolock l(mCompositeLock);
     for (size_t i = 0; i < mCompositeStreamMap.size(); i++) {
         mCompositeStreamMap.valueAt(i)->onResultAvailable(result);
     }
@@ -2142,12 +2019,11 @@ bool CameraDeviceClient::enforceRequestPermissions(CameraMetadata& metadata) {
     return true;
 }
 
-status_t CameraDeviceClient::getRotationTransformLocked(int mirrorMode,
-        int32_t* transform) {
+status_t CameraDeviceClient::getRotationTransformLocked(int32_t* transform) {
     ALOGV("%s: begin", __FUNCTION__);
 
     const CameraMetadata& staticInfo = mDevice->info();
-    return CameraUtils::getRotationTransform(staticInfo, mirrorMode, transform);
+    return CameraUtils::getRotationTransform(staticInfo, transform);
 }
 
 binder::Status CameraDeviceClient::mapRequestTemplate(int templateId,
diff --git a/services/camera/libcameraservice/api2/CameraDeviceClient.h b/services/camera/libcameraservice/api2/CameraDeviceClient.h
index c5aad6b222..288f2d7cdc 100644
--- a/services/camera/libcameraservice/api2/CameraDeviceClient.h
+++ b/services/camera/libcameraservice/api2/CameraDeviceClient.h
@@ -22,7 +22,6 @@
 #include <camera/camera2/OutputConfiguration.h>
 #include <camera/camera2/SessionConfiguration.h>
 #include <camera/camera2/SubmitInfo.h>
-#include <unordered_map>
 
 #include "CameraOfflineSessionClient.h"
 #include "CameraService.h"
@@ -50,7 +49,6 @@ protected:
     CameraDeviceClientBase(const sp<CameraService>& cameraService,
             const sp<hardware::camera2::ICameraDeviceCallbacks>& remoteCallback,
             const String16& clientPackageName,
-            bool systemNativeClient,
             const std::optional<String16>& clientFeatureId,
             const String8& cameraId,
             int api1CameraId,
@@ -179,7 +177,6 @@ public:
     CameraDeviceClient(const sp<CameraService>& cameraService,
             const sp<hardware::camera2::ICameraDeviceCallbacks>& remoteCallback,
             const String16& clientPackageName,
-            bool clientPackageOverride,
             const std::optional<String16>& clientFeatureId,
             const String8& cameraId,
             int cameraFacing,
@@ -229,7 +226,7 @@ protected:
     virtual void          detachDevice();
 
     // Calculate the ANativeWindow transform from android.sensor.orientation
-    status_t              getRotationTransformLocked(int mirrorMode, /*out*/int32_t* transform);
+    status_t              getRotationTransformLocked(/*out*/int32_t* transform);
 
     bool isUltraHighResolutionSensor(const String8 &cameraId);
 
@@ -289,7 +286,7 @@ private:
 
     // Set the stream transform flags to automatically rotate the camera stream for preview use
     // cases.
-    binder::Status setStreamTransformLocked(int streamId, int mirrorMode);
+    binder::Status setStreamTransformLocked(int streamId);
 
     // Utility method to insert the surface into SurfaceMap
     binder::Status insertGbpLocked(const sp<IGraphicBufferProducer>& gbp,
@@ -306,10 +303,6 @@ private:
     // Stream ID -> OutputConfiguration. Used for looking up Surface by stream/surface index
     KeyedVector<int32_t, hardware::camera2::params::OutputConfiguration> mConfiguredOutputs;
 
-    // Dynamic range profile id -> Supported dynamic profiles bitmap within an single capture
-    // request
-    std::unordered_map<int64_t, int64_t> mDynamicProfileMap;
-
     struct InputStreamConfiguration {
         bool configured;
         int32_t width;
@@ -341,19 +334,12 @@ private:
     // set of high resolution camera id (logical / physical)
     std::unordered_set<std::string> mHighResolutionSensors;
 
-    // Synchronize access to 'mCompositeStreamMap'
-    Mutex mCompositeLock;
     KeyedVector<sp<IBinder>, sp<CompositeStream>> mCompositeStreamMap;
 
     sp<CameraProviderManager> mProviderManager;
 
     // Override the camera characteristics for performance class primary cameras.
     bool mOverrideForPerfClass;
-
-    // The string representation of object passed into CaptureRequest.setTag.
-    std::string mUserTag;
-    // The last set video stabilization mode
-    int mVideoStabilizationMode = -1;
 };
 
 }; // namespace android
diff --git a/services/camera/libcameraservice/api2/CameraOfflineSessionClient.cpp b/services/camera/libcameraservice/api2/CameraOfflineSessionClient.cpp
index 9303fd2f2f..d76f492973 100644
--- a/services/camera/libcameraservice/api2/CameraOfflineSessionClient.cpp
+++ b/services/camera/libcameraservice/api2/CameraOfflineSessionClient.cpp
@@ -287,7 +287,7 @@ void CameraOfflineSessionClient::notifyShutter(const CaptureResultExtras& result
     }
 }
 
-status_t CameraOfflineSessionClient::notifyActive(float maxPreviewFps __unused) {
+status_t CameraOfflineSessionClient::notifyActive() {
     return startCameraStreamingOps();
 }
 
@@ -342,19 +342,5 @@ void CameraOfflineSessionClient::notifyRepeatingRequestError(long /*lastFrameNum
                 CaptureResultExtras());
 }
 
-status_t CameraOfflineSessionClient::injectCamera(const String8& injectedCamId,
-            sp<CameraProviderManager> manager) {
-    ALOGV("%s: This client doesn't support the injection camera. injectedCamId: %s providerPtr: %p",
-            __FUNCTION__, injectedCamId.string(), manager.get());
-
-    return OK;
-}
-
-status_t CameraOfflineSessionClient::stopInjection() {
-    ALOGV("%s: This client doesn't support the injection camera.", __FUNCTION__);
-
-    return OK;
-}
-
 // ----------------------------------------------------------------------------
 }; // namespace android
diff --git a/services/camera/libcameraservice/api2/CameraOfflineSessionClient.h b/services/camera/libcameraservice/api2/CameraOfflineSessionClient.h
index f2c42d8544..707bca4a7e 100644
--- a/services/camera/libcameraservice/api2/CameraOfflineSessionClient.h
+++ b/services/camera/libcameraservice/api2/CameraOfflineSessionClient.h
@@ -54,8 +54,7 @@ public:
             CameraService::BasicClient(
                     cameraService,
                     IInterface::asBinder(remoteCallback),
-                    // (v)ndk doesn't have offline session support
-                    clientPackageName, /*overridePackageName*/false, clientFeatureId,
+                    clientPackageName, clientFeatureId,
                     cameraIdStr, cameraFacing, sensorOrientation, clientPid, clientUid, servicePid),
             mRemoteCallback(remoteCallback), mOfflineSession(session),
             mCompositeStreamMap(offlineCompositeStreamMap) {}
@@ -94,7 +93,7 @@ public:
     // NotificationListener API
     void notifyError(int32_t errorCode, const CaptureResultExtras& resultExtras) override;
     void notifyShutter(const CaptureResultExtras& resultExtras, nsecs_t timestamp) override;
-    status_t notifyActive(float maxPreviewFps) override;
+    status_t notifyActive() override;
     void notifyIdle(int64_t requestCount, int64_t resultErrorCount, bool deviceError,
             const std::vector<hardware::CameraStreamStats>& streamStats) override;
     void notifyAutoFocus(uint8_t newState, int triggerId) override;
@@ -103,9 +102,6 @@ public:
     void notifyPrepared(int streamId) override;
     void notifyRequestQueueEmpty() override;
     void notifyRepeatingRequestError(long lastFrameNumber) override;
-    status_t injectCamera(const String8& injectedCamId,
-            sp<CameraProviderManager> manager) override;
-    status_t stopInjection() override;
 
 private:
     mutable Mutex mBinderSerializationLock;
diff --git a/services/camera/libcameraservice/api2/DepthCompositeStream.cpp b/services/camera/libcameraservice/api2/DepthCompositeStream.cpp
index 048d85dcfa..a66a5921fc 100644
--- a/services/camera/libcameraservice/api2/DepthCompositeStream.cpp
+++ b/services/camera/libcameraservice/api2/DepthCompositeStream.cpp
@@ -18,9 +18,6 @@
 #define ATRACE_TAG ATRACE_TAG_CAMERA
 //#define LOG_NDEBUG 0
 
-#include <aidl/android/hardware/camera/device/CameraBlob.h>
-#include <aidl/android/hardware/camera/device/CameraBlobId.h>
-
 #include "api1/client2/JpegProcessor.h"
 #include "common/CameraProviderManager.h"
 #include "utils/SessionConfigurationUtils.h"
@@ -33,9 +30,6 @@
 namespace android {
 namespace camera3 {
 
-using aidl::android::hardware::camera::device::CameraBlob;
-using aidl::android::hardware::camera::device::CameraBlobId;
-
 DepthCompositeStream::DepthCompositeStream(sp<CameraDeviceBase> device,
         wp<hardware::camera2::ICameraDeviceCallbacks> cb) :
         CompositeStream(device, cb),
@@ -303,8 +297,7 @@ status_t DepthCompositeStream::processInputFrame(nsecs_t ts, const InputFrame &i
     }
 
     sp<GraphicBuffer> gb = GraphicBuffer::from(anb);
-    GraphicBufferLocker gbLocker(gb);
-    res = gbLocker.lockAsync(&dstBuffer, fenceFd);
+    res = gb->lockAsync(GRALLOC_USAGE_SW_WRITE_OFTEN, &dstBuffer, fenceFd);
     if (res != OK) {
         ALOGE("%s: Error trying to lock output buffer fence: %s (%d)", __FUNCTION__,
                 strerror(-res), res);
@@ -373,7 +366,7 @@ status_t DepthCompositeStream::processInputFrame(nsecs_t ts, const InputFrame &i
         return res;
     }
 
-    size_t finalJpegSize = actualJpegSize + sizeof(CameraBlob);
+    size_t finalJpegSize = actualJpegSize + sizeof(struct camera_jpeg_blob);
     if (finalJpegSize > finalJpegBufferSize) {
         ALOGE("%s: Final jpeg buffer not large enough for the jpeg blob header", __FUNCTION__);
         outputANW->cancelBuffer(mOutputSurface.get(), anb, /*fence*/ -1);
@@ -389,10 +382,10 @@ status_t DepthCompositeStream::processInputFrame(nsecs_t ts, const InputFrame &i
 
     ALOGV("%s: Final jpeg size: %zu", __func__, finalJpegSize);
     uint8_t* header = static_cast<uint8_t *> (dstBuffer) +
-        (gb->getWidth() - sizeof(CameraBlob));
-    CameraBlob *blob = reinterpret_cast<CameraBlob*> (header);
-    blob->blobId = CameraBlobId::JPEG;
-    blob->blobSizeBytes = actualJpegSize;
+        (gb->getWidth() - sizeof(struct camera_jpeg_blob));
+    struct camera_jpeg_blob *blob = reinterpret_cast<struct camera_jpeg_blob*> (header);
+    blob->jpeg_blob_id = CAMERA_JPEG_BLOB_ID;
+    blob->jpeg_size = actualJpegSize;
     outputANW->queueBuffer(mOutputSurface.get(), anb, /*fence*/ -1);
 
     return res;
diff --git a/services/camera/libcameraservice/api2/HeicCompositeStream.cpp b/services/camera/libcameraservice/api2/HeicCompositeStream.cpp
index 54cc27aebf..a73ffb90c6 100644
--- a/services/camera/libcameraservice/api2/HeicCompositeStream.cpp
+++ b/services/camera/libcameraservice/api2/HeicCompositeStream.cpp
@@ -23,8 +23,7 @@
 #include <pthread.h>
 #include <sys/syscall.h>
 
-#include <aidl/android/hardware/camera/device/CameraBlob.h>
-#include <aidl/android/hardware/camera/device/CameraBlobId.h>
+#include <android/hardware/camera/device/3.5/types.h>
 #include <libyuv.h>
 #include <gui/Surface.h>
 #include <utils/Log.h>
@@ -42,8 +41,8 @@
 #include "HeicEncoderInfoManager.h"
 #include "HeicCompositeStream.h"
 
-using aidl::android::hardware::camera::device::CameraBlob;
-using aidl::android::hardware::camera::device::CameraBlobId;
+using android::hardware::camera::device::V3_5::CameraBlob;
+using android::hardware::camera::device::V3_5::CameraBlobId;
 
 namespace android {
 namespace camera3 {
@@ -442,10 +441,6 @@ void HeicCompositeStream::onHeicFormatChanged(sp<AMessage>& newFormat) {
             newFormat->setInt32(KEY_TILE_HEIGHT, mGridHeight);
             newFormat->setInt32(KEY_GRID_ROWS, mGridRows);
             newFormat->setInt32(KEY_GRID_COLUMNS, mGridCols);
-            int32_t left, top, right, bottom;
-            if (newFormat->findRect("crop", &left, &top, &right, &bottom)) {
-                newFormat->setRect("crop", 0, 0, mOutputWidth - 1, mOutputHeight - 1);
-            }
         }
     }
     newFormat->setInt32(KEY_IS_DEFAULT, 1 /*isPrimary*/);
@@ -1135,8 +1130,7 @@ status_t HeicCompositeStream::processCompletedInputFrame(int64_t frameNumber,
     // Copy the content of the file to memory.
     sp<GraphicBuffer> gb = GraphicBuffer::from(inputFrame.anb);
     void* dstBuffer;
-    GraphicBufferLocker gbLocker(gb);
-    auto res = gbLocker.lockAsync(&dstBuffer, inputFrame.fenceFd);
+    auto res = gb->lockAsync(GRALLOC_USAGE_SW_WRITE_OFTEN, &dstBuffer, inputFrame.fenceFd);
     if (res != OK) {
         ALOGE("%s: Error trying to lock output buffer fence: %s (%d)", __FUNCTION__,
                 strerror(-res), res);
@@ -1162,10 +1156,10 @@ status_t HeicCompositeStream::processCompletedInputFrame(int64_t frameNumber,
 
     // Fill in HEIC header
     uint8_t *header = static_cast<uint8_t*>(dstBuffer) + mMaxHeicBufferSize - sizeof(CameraBlob);
-    CameraBlob *blobHeader = (CameraBlob *)header;
+    struct CameraBlob *blobHeader = (struct CameraBlob *)header;
     // Must be in sync with CAMERA3_HEIC_BLOB_ID in android_media_Utils.cpp
     blobHeader->blobId = static_cast<CameraBlobId>(0x00FE);
-    blobHeader->blobSizeBytes = fSize;
+    blobHeader->blobSize = fSize;
 
     res = native_window_set_buffers_timestamp(mOutputSurface.get(), inputFrame.timestamp);
     if (res != OK) {
@@ -1427,15 +1421,15 @@ size_t HeicCompositeStream::findAppSegmentsSize(const uint8_t* appSegmentBuffer,
 
     size_t expectedSize = 0;
     // First check for EXIF transport header at the end of the buffer
-    const uint8_t *header = appSegmentBuffer + (maxSize - sizeof(CameraBlob));
-    const CameraBlob *blob = (const CameraBlob*)(header);
+    const uint8_t *header = appSegmentBuffer + (maxSize - sizeof(struct CameraBlob));
+    const struct CameraBlob *blob = (const struct CameraBlob*)(header);
     if (blob->blobId != CameraBlobId::JPEG_APP_SEGMENTS) {
-        ALOGE("%s: Invalid EXIF blobId %d", __FUNCTION__, blob->blobId);
+        ALOGE("%s: Invalid EXIF blobId %hu", __FUNCTION__, blob->blobId);
         return 0;
     }
 
-    expectedSize = blob->blobSizeBytes;
-    if (expectedSize == 0 || expectedSize > maxSize - sizeof(CameraBlob)) {
+    expectedSize = blob->blobSize;
+    if (expectedSize == 0 || expectedSize > maxSize - sizeof(struct CameraBlob)) {
         ALOGE("%s: Invalid blobSize %zu.", __FUNCTION__, expectedSize);
         return 0;
     }
@@ -1638,7 +1632,7 @@ size_t HeicCompositeStream::calcAppSegmentMaxSize(const CameraMetadata& info) {
         maxAppsSegment = entry.data.u8[0] < 1 ? 1 :
                 entry.data.u8[0] > 16 ? 16 : entry.data.u8[0];
     }
-    return maxAppsSegment * (2 + 0xFFFF) + sizeof(CameraBlob);
+    return maxAppsSegment * (2 + 0xFFFF) + sizeof(struct CameraBlob);
 }
 
 void HeicCompositeStream::updateCodecQualityLocked(int32_t quality) {
diff --git a/services/camera/libcameraservice/common/Camera2ClientBase.cpp b/services/camera/libcameraservice/common/Camera2ClientBase.cpp
index dc5002bffa..9c3520c814 100644
--- a/services/camera/libcameraservice/common/Camera2ClientBase.cpp
+++ b/services/camera/libcameraservice/common/Camera2ClientBase.cpp
@@ -34,8 +34,6 @@
 #include "api2/CameraDeviceClient.h"
 
 #include "device3/Camera3Device.h"
-#include "device3/aidl/AidlCamera3Device.h"
-#include "device3/hidl/HidlCamera3Device.h"
 #include "utils/CameraThreadState.h"
 #include "utils/CameraServiceProxyWrapper.h"
 
@@ -49,7 +47,6 @@ Camera2ClientBase<TClientBase>::Camera2ClientBase(
         const sp<CameraService>& cameraService,
         const sp<TCamCallbacks>& remoteCallback,
         const String16& clientPackageName,
-        bool systemNativeClient,
         const std::optional<String16>& clientFeatureId,
         const String8& cameraId,
         int api1CameraId,
@@ -60,18 +57,19 @@ Camera2ClientBase<TClientBase>::Camera2ClientBase(
         int servicePid,
         bool overrideForPerfClass,
         bool legacyClient):
-        TClientBase(cameraService, remoteCallback, clientPackageName, systemNativeClient,
-                clientFeatureId, cameraId, api1CameraId, cameraFacing, sensorOrientation, clientPid,
-                clientUid, servicePid),
+        TClientBase(cameraService, remoteCallback, clientPackageName, clientFeatureId,
+                cameraId, api1CameraId, cameraFacing, sensorOrientation, clientPid, clientUid,
+                servicePid),
         mSharedCameraCallbacks(remoteCallback),
+        mDeviceVersion(cameraService->getDeviceVersion(TClientBase::mCameraIdStr)),
+        mDevice(new Camera3Device(cameraId, overrideForPerfClass, legacyClient)),
         mDeviceActive(false), mApi1CameraId(api1CameraId)
 {
     ALOGI("Camera %s: Opened. Client: %s (PID %d, UID %d)", cameraId.string(),
             String8(clientPackageName).string(), clientPid, clientUid);
 
     mInitialClientPid = clientPid;
-    mOverrideForPerfClass = overrideForPerfClass;
-    mLegacyClient = legacyClient;
+    LOG_ALWAYS_FATAL_IF(mDevice == 0, "Device should never be NULL here.");
 }
 
 template <typename TClientBase>
@@ -106,28 +104,7 @@ status_t Camera2ClientBase<TClientBase>::initializeImpl(TProviderPtr providerPtr
     if (res != OK) {
         return res;
     }
-    IPCTransport providerTransport = IPCTransport::INVALID;
-    res = providerPtr->getCameraIdIPCTransport(TClientBase::mCameraIdStr.string(),
-            &providerTransport);
-    if (res != OK) {
-        return res;
-    }
-    switch (providerTransport) {
-        case IPCTransport::HIDL:
-            mDevice =
-                    new HidlCamera3Device(TClientBase::mCameraIdStr, mOverrideForPerfClass,
-                            mLegacyClient);
-            break;
-        case IPCTransport::AIDL:
-            mDevice =
-                    new AidlCamera3Device(TClientBase::mCameraIdStr, mOverrideForPerfClass,
-                            mLegacyClient);
-             break;
-        default:
-            ALOGE("%s Invalid transport for camera id %s", __FUNCTION__,
-                    TClientBase::mCameraIdStr.string());
-            return NO_INIT;
-    }
+
     if (mDevice == NULL) {
         ALOGE("%s: Camera %s: No device connected",
                 __FUNCTION__, TClientBase::mCameraIdStr.string());
@@ -242,23 +219,20 @@ status_t Camera2ClientBase<TClientBase>::dumpDevice(
 template <typename TClientBase>
 binder::Status Camera2ClientBase<TClientBase>::disconnect() {
     ATRACE_CALL();
-    ALOGD("Camera %s: start to disconnect", TClientBase::mCameraIdStr.string());
     Mutex::Autolock icl(mBinderSerializationLock);
 
-    ALOGD("Camera %s: serializationLock acquired", TClientBase::mCameraIdStr.string());
     binder::Status res = binder::Status::ok();
     // Allow both client and the media server to disconnect at all times
     int callingPid = CameraThreadState::getCallingPid();
     if (callingPid != TClientBase::mClientPid &&
         callingPid != TClientBase::mServicePid) return res;
 
-    ALOGD("Camera %s: Shutting down", TClientBase::mCameraIdStr.string());
+    ALOGV("Camera %s: Shutting down", TClientBase::mCameraIdStr.string());
 
     // Before detaching the device, cache the info from current open session.
     // The disconnected check avoids duplication of info and also prevents
     // deadlock while acquiring service lock in cacheDump.
     if (!TClientBase::mDisconnected) {
-        ALOGD("Camera %s: start to cacheDump", TClientBase::mCameraIdStr.string());
         Camera2ClientBase::getCameraService()->cacheDump();
     }
 
@@ -317,7 +291,7 @@ void Camera2ClientBase<TClientBase>::notifyError(
 }
 
 template <typename TClientBase>
-status_t Camera2ClientBase<TClientBase>::notifyActive(float maxPreviewFps) {
+status_t Camera2ClientBase<TClientBase>::notifyActive() {
     if (!mDeviceActive) {
         status_t res = TClientBase::startCameraStreamingOps();
         if (res != OK) {
@@ -325,7 +299,7 @@ status_t Camera2ClientBase<TClientBase>::notifyActive(float maxPreviewFps) {
                     TClientBase::mCameraIdStr.string(), res);
             return res;
         }
-        CameraServiceProxyWrapper::logActive(TClientBase::mCameraIdStr, maxPreviewFps);
+        CameraServiceProxyWrapper::logActive(TClientBase::mCameraIdStr);
     }
     mDeviceActive = true;
 
@@ -334,10 +308,9 @@ status_t Camera2ClientBase<TClientBase>::notifyActive(float maxPreviewFps) {
 }
 
 template <typename TClientBase>
-void Camera2ClientBase<TClientBase>::notifyIdleWithUserTag(
+void Camera2ClientBase<TClientBase>::notifyIdle(
         int64_t requestCount, int64_t resultErrorCount, bool deviceError,
-        const std::vector<hardware::CameraStreamStats>& streamStats,
-        const std::string& userTag, int videoStabilizationMode) {
+        const std::vector<hardware::CameraStreamStats>& streamStats) {
     if (mDeviceActive) {
         status_t res = TClientBase::finishCameraStreamingOps();
         if (res != OK) {
@@ -345,8 +318,7 @@ void Camera2ClientBase<TClientBase>::notifyIdleWithUserTag(
                     TClientBase::mCameraIdStr.string(), res);
         }
         CameraServiceProxyWrapper::logIdle(TClientBase::mCameraIdStr,
-                requestCount, resultErrorCount, deviceError, userTag, videoStabilizationMode,
-                streamStats);
+                requestCount, resultErrorCount, deviceError, streamStats);
     }
     mDeviceActive = false;
 
@@ -421,6 +393,11 @@ int Camera2ClientBase<TClientBase>::getCameraId() const {
     return mApi1CameraId;
 }
 
+template <typename TClientBase>
+int Camera2ClientBase<TClientBase>::getCameraDeviceVersion() const {
+    return mDeviceVersion;
+}
+
 template <typename TClientBase>
 const sp<CameraDeviceBase>& Camera2ClientBase<TClientBase>::getCameraDevice() {
     return mDevice;
@@ -469,17 +446,6 @@ void Camera2ClientBase<TClientBase>::SharedCameraCallbacks::clear() {
     mRemoteCallback.clear();
 }
 
-template <typename TClientBase>
-status_t Camera2ClientBase<TClientBase>::injectCamera(const String8& injectedCamId,
-        sp<CameraProviderManager> manager) {
-    return mDevice->injectCamera(injectedCamId, manager);
-}
-
-template <typename TClientBase>
-status_t Camera2ClientBase<TClientBase>::stopInjection() {
-    return mDevice->stopInjection();
-}
-
 template class Camera2ClientBase<CameraService::Client>;
 template class Camera2ClientBase<CameraDeviceClientBase>;
 
diff --git a/services/camera/libcameraservice/common/Camera2ClientBase.h b/services/camera/libcameraservice/common/Camera2ClientBase.h
index b0d1c3f676..29da33abdf 100644
--- a/services/camera/libcameraservice/common/Camera2ClientBase.h
+++ b/services/camera/libcameraservice/common/Camera2ClientBase.h
@@ -48,7 +48,6 @@ public:
     Camera2ClientBase(const sp<CameraService>& cameraService,
                       const sp<TCamCallbacks>& remoteCallback,
                       const String16& clientPackageName,
-                      bool systemNativeClient,
                       const std::optional<String16>& clientFeatureId,
                       const String8& cameraId,
                       int api1CameraId,
@@ -73,11 +72,10 @@ public:
 
     virtual void          notifyError(int32_t errorCode,
                                       const CaptureResultExtras& resultExtras);
-    // Returns errors on app ops permission failures
-    virtual status_t      notifyActive(float maxPreviewFps);
-    virtual void          notifyIdle(int64_t /*requestCount*/, int64_t /*resultErrorCount*/,
-                                     bool /*deviceError*/,
-                                     const std::vector<hardware::CameraStreamStats>&) {}
+    virtual status_t      notifyActive();  // Returns errors on app ops permission failures
+    virtual void          notifyIdle(int64_t requestCount, int64_t resultErrorCount,
+                                     bool deviceError,
+                                     const std::vector<hardware::CameraStreamStats>& streamStats);
     virtual void          notifyShutter(const CaptureResultExtras& resultExtras,
                                         nsecs_t timestamp);
     virtual void          notifyAutoFocus(uint8_t newState, int triggerId);
@@ -88,11 +86,6 @@ public:
     virtual void          notifyRequestQueueEmpty();
     virtual void          notifyRepeatingRequestError(long lastFrameNumber);
 
-    void                  notifyIdleWithUserTag(int64_t requestCount, int64_t resultErrorCount,
-                                     bool deviceError,
-                                     const std::vector<hardware::CameraStreamStats>& streamStats,
-                                     const std::string& userTag, int videoStabilizationMode);
-
     int                   getCameraId() const;
     const sp<CameraDeviceBase>&
                           getCameraDevice();
@@ -125,16 +118,10 @@ public:
         mutable Mutex mRemoteCallbackLock;
     } mSharedCameraCallbacks;
 
-    status_t      injectCamera(const String8& injectedCamId,
-                               sp<CameraProviderManager> manager) override;
-    status_t      stopInjection() override;
-
 protected:
 
     // The PID provided in the constructor call
     pid_t mInitialClientPid;
-    bool mOverrideForPerfClass = false;
-    bool mLegacyClient = false;
 
     virtual sp<IBinder> asBinderWrapper() {
         return IInterface::asBinder(this);
@@ -152,12 +139,11 @@ protected:
 
     /** CameraDeviceBase instance wrapping HAL3+ entry */
 
-    // Note: This was previously set to const to avoid mDevice being updated -
-    // b/112639939 (update of sp<> is racy) during dumpDevice (which is important to be lock free
-    // for debugging purpose). The const has been removed since CameraDeviceBase
-    // needs to be set during initializeImpl(). This must not be set / cleared
-    // anywhere else.
-    sp<CameraDeviceBase>  mDevice;
+    const int mDeviceVersion;
+
+    // Set to const to avoid mDevice being updated (update of sp<> is racy) during
+    // dumpDevice (which is important to be lock free for debugging purpose)
+    const sp<CameraDeviceBase>  mDevice;
 
     /** Utility members */
 
diff --git a/services/camera/libcameraservice/common/CameraDeviceBase.h b/services/camera/libcameraservice/common/CameraDeviceBase.h
index 7e2f93ce68..8168821128 100644
--- a/services/camera/libcameraservice/common/CameraDeviceBase.h
+++ b/services/camera/libcameraservice/common/CameraDeviceBase.h
@@ -35,7 +35,6 @@
 #include "device3/StatusTracker.h"
 #include "binder/Status.h"
 #include "FrameProducer.h"
-#include "utils/IPCTransport.h"
 
 #include "CameraOfflineSessionBase.h"
 
@@ -60,9 +59,6 @@ typedef enum camera_stream_configuration_mode {
     CAMERA_VENDOR_STREAM_CONFIGURATION_MODE_START = 0x8000
 } camera_stream_configuration_mode_t;
 
-// Matches definition of camera3_jpeg_blob in camera3.h and HIDL definition
-// device@3.2:types.hal, needs to stay around till HIDL support is removed (for
-// HIDL -> AIDL cameraBlob translation)
 typedef struct camera_jpeg_blob {
     uint16_t jpeg_blob_id;
     uint32_t jpeg_size;
@@ -92,8 +88,6 @@ class CameraDeviceBase : public virtual FrameProducer {
   public:
     virtual ~CameraDeviceBase();
 
-    virtual IPCTransport getTransportType() const = 0;
-
     /**
      * The device vendor tag ID
      */
@@ -108,24 +102,13 @@ class CameraDeviceBase : public virtual FrameProducer {
     virtual status_t dumpWatchedEventsToVector(std::vector<std::string> &out) = 0;
 
     /**
-     * The physical camera device's static characteristics metadata buffer, or
-     * the logical camera's static characteristics if physical id is empty.
+     * The physical camera device's static characteristics metadata buffer
      */
     virtual const CameraMetadata& infoPhysical(const String8& physicalId) const = 0;
 
     struct PhysicalCameraSettings {
         std::string cameraId;
         CameraMetadata metadata;
-
-        // Whether the physical camera supports testPatternMode/testPatternData
-        bool mHasTestPatternModeTag = true;
-        bool mHasTestPatternDataTag = true;
-
-        // Original value of TEST_PATTERN_MODE and DATA so that they can be
-        // restored when sensor muting is turned off
-        int32_t mOriginalTestPatternMode = 0;
-        int32_t mOriginalTestPatternData[4] = {};
-
     };
     typedef List<PhysicalCameraSettings> PhysicalCameraSettingsList;
 
@@ -188,11 +171,7 @@ class CameraDeviceBase : public virtual FrameProducer {
             std::vector<int> *surfaceIds = nullptr,
             int streamSetId = camera3::CAMERA3_STREAM_SET_ID_INVALID,
             bool isShared = false, bool isMultiResolution = false,
-            uint64_t consumerUsage = 0,
-            int64_t dynamicProfile = ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD,
-            int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT,
-            int timestampBase = OutputConfiguration::TIMESTAMP_BASE_DEFAULT,
-            int mirrorMode = OutputConfiguration::MIRROR_MODE_AUTO) = 0;
+            uint64_t consumerUsage = 0) = 0;
 
     /**
      * Create an output stream of the requested size, format, rotation and
@@ -209,11 +188,7 @@ class CameraDeviceBase : public virtual FrameProducer {
             std::vector<int> *surfaceIds = nullptr,
             int streamSetId = camera3::CAMERA3_STREAM_SET_ID_INVALID,
             bool isShared = false, bool isMultiResolution = false,
-            uint64_t consumerUsage = 0,
-            int64_t dynamicProfile = ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD,
-            int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT,
-            int timestampBase = OutputConfiguration::TIMESTAMP_BASE_DEFAULT,
-            int mirrorMode = OutputConfiguration::MIRROR_MODE_AUTO) = 0;
+            uint64_t consumerUsage = 0) = 0;
 
     /**
      * Create an input stream of width, height, and format.
@@ -234,12 +209,10 @@ class CameraDeviceBase : public virtual FrameProducer {
         android_dataspace dataSpace;
         bool dataSpaceOverridden;
         android_dataspace originalDataSpace;
-        int64_t dynamicRangeProfile;
 
         StreamInfo() : width(0), height(0), format(0), formatOverridden(false), originalFormat(0),
                 dataSpace(HAL_DATASPACE_UNKNOWN), dataSpaceOverridden(false),
-                originalDataSpace(HAL_DATASPACE_UNKNOWN),
-                dynamicRangeProfile(ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD){}
+                originalDataSpace(HAL_DATASPACE_UNKNOWN) {}
         /**
          * Check whether the format matches the current or the original one in case
          * it got overridden.
@@ -324,8 +297,7 @@ class CameraDeviceBase : public virtual FrameProducer {
      * Get Jpeg buffer size for a given jpeg resolution.
      * Negative values are error codes.
      */
-    virtual ssize_t getJpegBufferSize(const CameraMetadata &info, uint32_t width,
-            uint32_t height) const = 0;
+    virtual ssize_t getJpegBufferSize(uint32_t width, uint32_t height) const = 0;
 
     /**
      * Connect HAL notifications to a listener. Overwrites previous
diff --git a/services/camera/libcameraservice/common/CameraOfflineSessionBase.h b/services/camera/libcameraservice/common/CameraOfflineSessionBase.h
index f39b92a48c..54e42a67c5 100644
--- a/services/camera/libcameraservice/common/CameraOfflineSessionBase.h
+++ b/services/camera/libcameraservice/common/CameraOfflineSessionBase.h
@@ -40,8 +40,7 @@ class NotificationListener : public virtual RefBase {
     // Required for API 1 and 2
     virtual void notifyError(int32_t errorCode,
                              const CaptureResultExtras &resultExtras) = 0;
-    // May return an error since it checks appops
-    virtual status_t notifyActive(float maxPreviewFps) = 0;
+    virtual status_t notifyActive() = 0; // May return an error since it checks appops
     virtual void notifyIdle(int64_t requestCount, int64_t resultError, bool deviceError,
             const std::vector<hardware::CameraStreamStats>& streamStats) = 0;
 
diff --git a/services/camera/libcameraservice/common/CameraProviderInfoTemplated.h b/services/camera/libcameraservice/common/CameraProviderInfoTemplated.h
deleted file mode 100644
index db7692a8d1..0000000000
--- a/services/camera/libcameraservice/common/CameraProviderInfoTemplated.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef ANDROID_SERVERS_CAMERA_CAMERAPROVIDERINFO_TEMPLATEDH
-#define ANDROID_SERVERS_CAMERA_CAMERAPROVIDERINFO_TEMPLATEDH
-
-#include "common/CameraProviderManager.h"
-
-namespace android {
-
-template <class VendorTagSectionVectorType, class VendorTagSectionType>
-status_t IdlVendorTagDescriptor::createDescriptorFromIdl(
-        const VendorTagSectionVectorType& vts,
-        sp<VendorTagDescriptor>& descriptor) {
-
-    int tagCount = 0;
-
-    for (size_t s = 0; s < vts.size(); s++) {
-        tagCount += vts[s].tags.size();
-    }
-
-    if (tagCount < 0 || tagCount > INT32_MAX) {
-        ALOGE("%s: tag count %d from vendor tag sections is invalid.", __FUNCTION__, tagCount);
-        return BAD_VALUE;
-    }
-
-    Vector<uint32_t> tagArray;
-    LOG_ALWAYS_FATAL_IF(tagArray.resize(tagCount) != tagCount,
-            "%s: too many (%u) vendor tags defined.", __FUNCTION__, tagCount);
-    sp<IdlVendorTagDescriptor> desc = new IdlVendorTagDescriptor();
-    desc->mTagCount = tagCount;
-
-    SortedVector<String8> sections;
-    KeyedVector<uint32_t, String8> tagToSectionMap;
-
-    int idx = 0;
-    for (size_t s = 0; s < vts.size(); s++) {
-        const VendorTagSectionType& section = vts[s];
-        const char *sectionName = section.sectionName.c_str();
-        if (sectionName == NULL) {
-            ALOGE("%s: no section name defined for vendor tag section %zu.", __FUNCTION__, s);
-            return BAD_VALUE;
-        }
-        String8 sectionString(sectionName);
-        sections.add(sectionString);
-
-        for (size_t j = 0; j < section.tags.size(); j++) {
-            uint32_t tag = section.tags[j].tagId;
-            if (tag < CAMERA_METADATA_VENDOR_TAG_BOUNDARY) {
-                ALOGE("%s: vendor tag %d not in vendor tag section.", __FUNCTION__, tag);
-                return BAD_VALUE;
-            }
-
-            tagArray.editItemAt(idx++) = section.tags[j].tagId;
-
-            const char *tagName = section.tags[j].tagName.c_str();
-            if (tagName == NULL) {
-                ALOGE("%s: no tag name defined for vendor tag %d.", __FUNCTION__, tag);
-                return BAD_VALUE;
-            }
-            desc->mTagToNameMap.add(tag, String8(tagName));
-            tagToSectionMap.add(tag, sectionString);
-
-            int tagType = (int) section.tags[j].tagType;
-            if (tagType < 0 || tagType >= NUM_TYPES) {
-                ALOGE("%s: tag type %d from vendor ops does not exist.", __FUNCTION__, tagType);
-                return BAD_VALUE;
-            }
-            desc->mTagToTypeMap.add(tag, tagType);
-        }
-    }
-
-    desc->mSections = sections;
-
-    for (size_t i = 0; i < tagArray.size(); ++i) {
-        uint32_t tag = tagArray[i];
-        String8 sectionString = tagToSectionMap.valueFor(tag);
-
-        // Set up tag to section index map
-        ssize_t index = sections.indexOf(sectionString);
-        LOG_ALWAYS_FATAL_IF(index < 0, "index %zd must be non-negative", index);
-        desc->mTagToSectionMap.add(tag, static_cast<uint32_t>(index));
-
-        // Set up reverse mapping
-        ssize_t reverseIndex = -1;
-        if ((reverseIndex = desc->mReverseMapping.indexOfKey(sectionString)) < 0) {
-            KeyedVector<String8, uint32_t>* nameMapper = new KeyedVector<String8, uint32_t>();
-            reverseIndex = desc->mReverseMapping.add(sectionString, nameMapper);
-        }
-        desc->mReverseMapping[reverseIndex]->add(desc->mTagToNameMap.valueFor(tag), tag);
-    }
-
-    descriptor = std::move(desc);
-    return OK;
-}
-
-
-} // namespace android
-
-#endif
diff --git a/services/camera/libcameraservice/common/CameraProviderManager.cpp b/services/camera/libcameraservice/common/CameraProviderManager.cpp
index abaea6639f..b10a4c416e 100644
--- a/services/camera/libcameraservice/common/CameraProviderManager.cpp
+++ b/services/camera/libcameraservice/common/CameraProviderManager.cpp
@@ -20,17 +20,14 @@
 
 #include "CameraProviderManager.h"
 
-#include <aidl/android/hardware/camera/device/ICameraDevice.h>
+#include <android/hardware/camera/device/3.7/ICameraDevice.h>
 
 #include <algorithm>
 #include <chrono>
 #include "common/DepthPhotoProcessor.h"
-#include "hidl/HidlProviderInfo.h"
-#include "aidl/AidlProviderInfo.h"
 #include <dlfcn.h>
 #include <future>
 #include <inttypes.h>
-#include <android/binder_manager.h>
 #include <android/hidl/manager/1.2/IServiceManager.h>
 #include <hidl/ServiceManagement.h>
 #include <functional>
@@ -39,6 +36,7 @@
 #include <android-base/logging.h>
 #include <cutils/properties.h>
 #include <hwbinder/IPCThreadState.h>
+#include <utils/SessionConfigurationUtils.h>
 #include <utils/Trace.h>
 
 #include "api2/HeicCompositeStream.h"
@@ -47,53 +45,26 @@
 namespace android {
 
 using namespace ::android::hardware::camera;
-using namespace ::android::camera3;
-using android::hardware::camera::common::V1_0::Status;
-using namespace camera3::SessionConfigurationUtils;
+using namespace ::android::hardware::camera::common::V1_0;
+using camera3::SessionConfigurationUtils;
 using std::literals::chrono_literals::operator""s;
 using hardware::camera2::utils::CameraIdAndSessionConfiguration;
+using hardware::camera::provider::V2_7::CameraIdAndStreamCombination;
 
 namespace {
 const bool kEnableLazyHal(property_get_bool("ro.camera.enableLazyHal", false));
-const std::string kExternalProviderName = "external/0";
 } // anonymous namespace
 
 const float CameraProviderManager::kDepthARTolerance = .1f;
 
-CameraProviderManager::HidlServiceInteractionProxyImpl
-CameraProviderManager::sHidlServiceInteractionProxy{};
+CameraProviderManager::HardwareServiceInteractionProxy
+CameraProviderManager::sHardwareServiceInteractionProxy{};
 
 CameraProviderManager::~CameraProviderManager() {
 }
 
-const char* FrameworkTorchStatusToString(const TorchModeStatus& s) {
-    switch (s) {
-        case TorchModeStatus::NOT_AVAILABLE:
-            return "NOT_AVAILABLE";
-        case TorchModeStatus::AVAILABLE_OFF:
-            return "AVAILABLE_OFF";
-        case TorchModeStatus::AVAILABLE_ON:
-            return "AVAILABLE_ON";
-    }
-    ALOGW("Unexpected HAL torch mode status code %d", s);
-    return "UNKNOWN_STATUS";
-}
-
-const char* FrameworkDeviceStatusToString(const CameraDeviceStatus& s) {
-    switch (s) {
-        case CameraDeviceStatus::NOT_PRESENT:
-            return "NOT_PRESENT";
-        case CameraDeviceStatus::PRESENT:
-            return "PRESENT";
-        case CameraDeviceStatus::ENUMERATING:
-            return "ENUMERATING";
-    }
-    ALOGW("Unexpected HAL device status code %d", s);
-    return "UNKNOWN_STATUS";
-}
-
 hardware::hidl_vec<hardware::hidl_string>
-CameraProviderManager::HidlServiceInteractionProxyImpl::listServices() {
+CameraProviderManager::HardwareServiceInteractionProxy::listServices() {
     hardware::hidl_vec<hardware::hidl_string> ret;
     auto manager = hardware::defaultServiceManager1_2();
     if (manager != nullptr) {
@@ -105,11 +76,20 @@ CameraProviderManager::HidlServiceInteractionProxyImpl::listServices() {
     return ret;
 }
 
-status_t CameraProviderManager::tryToInitAndAddHidlProvidersLocked(
-        HidlServiceInteractionProxy *hidlProxy) {
-    mHidlServiceProxy = hidlProxy;
+status_t CameraProviderManager::initialize(wp<CameraProviderManager::StatusListener> listener,
+        ServiceInteractionProxy* proxy) {
+    std::lock_guard<std::mutex> lock(mInterfaceMutex);
+    if (proxy == nullptr) {
+        ALOGE("%s: No valid service interaction proxy provided", __FUNCTION__);
+        return BAD_VALUE;
+    }
+    mListener = listener;
+    mServiceProxy = proxy;
+    mDeviceState = static_cast<hardware::hidl_bitfield<provider::V2_5::DeviceState>>(
+        provider::V2_5::DeviceState::NORMAL);
+
     // Registering will trigger notifications for all already-known providers
-    bool success = mHidlServiceProxy->registerForNotifications(
+    bool success = mServiceProxy->registerForNotifications(
         /* instance name, empty means no filter */ "",
         this);
     if (!success) {
@@ -118,57 +98,14 @@ status_t CameraProviderManager::tryToInitAndAddHidlProvidersLocked(
         return INVALID_OPERATION;
     }
 
-    for (const auto& instance : mHidlServiceProxy->listServices()) {
-        this->addHidlProviderLocked(instance);
-    }
-    return OK;
-}
 
-static std::string getFullAidlProviderName(const std::string instance) {
-    std::string aidlHalServiceDescriptor =
-            std::string(aidl::android::hardware::camera::provider::ICameraProvider::descriptor);
-   return aidlHalServiceDescriptor + "/" + instance;
-}
-
-status_t CameraProviderManager::tryToAddAidlProvidersLocked() {
-    const char * aidlHalServiceDescriptor =
-            aidl::android::hardware::camera::provider::ICameraProvider::descriptor;
-    auto sm = defaultServiceManager();
-    auto aidlProviders = sm->getDeclaredInstances(
-            String16(aidlHalServiceDescriptor));
-    for (const auto &aidlInstance : aidlProviders) {
-        std::string aidlServiceName =
-                getFullAidlProviderName(std::string(String8(aidlInstance).c_str()));
-        auto res = sm->registerForNotifications(String16(aidlServiceName.c_str()), this);
-        if (res != OK) {
-            ALOGE("%s Unable to register for notifications with AIDL service manager",
-                    __FUNCTION__);
-            return res;
-        }
-        addAidlProviderLocked(aidlServiceName);
+    for (const auto& instance : mServiceProxy->listServices()) {
+        this->addProviderLocked(instance);
     }
-    return OK;
-}
-
-status_t CameraProviderManager::initialize(wp<CameraProviderManager::StatusListener> listener,
-        HidlServiceInteractionProxy* hidlProxy) {
-    std::lock_guard<std::mutex> lock(mInterfaceMutex);
-    if (hidlProxy == nullptr) {
-        ALOGE("%s: No valid service interaction proxy provided", __FUNCTION__);
-        return BAD_VALUE;
-    }
-    mListener = listener;
-    mDeviceState = 0;
-    auto res = tryToInitAndAddHidlProvidersLocked(hidlProxy);
-    if (res != OK) {
-        // Logging done in called function;
-        return res;
-    }
-    res = tryToAddAidlProvidersLocked();
 
     IPCThreadState::self()->flushCommands();
 
-    return res;
+    return OK;
 }
 
 std::pair<int, int> CameraProviderManager::getCameraCount() const {
@@ -274,13 +211,15 @@ std::vector<std::string> CameraProviderManager::getAPI1CompatibleCameraDeviceIds
     return deviceIds;
 }
 
-bool CameraProviderManager::isValidDeviceLocked(const std::string &id, uint16_t majorVersion,
-        IPCTransport transport) const {
+bool CameraProviderManager::isValidDevice(const std::string &id, uint16_t majorVersion) const {
+    std::lock_guard<std::mutex> lock(mInterfaceMutex);
+    return isValidDeviceLocked(id, majorVersion);
+}
+
+bool CameraProviderManager::isValidDeviceLocked(const std::string &id, uint16_t majorVersion) const {
     for (auto& provider : mProviders) {
-        IPCTransport providerTransport = provider->getIPCTransport();
         for (auto& deviceInfo : provider->mDevices) {
-            if (deviceInfo->mId == id && deviceInfo->mVersion.get_major() == majorVersion &&
-                    transport == providerTransport) {
+            if (deviceInfo->mId == id && deviceInfo->mVersion.get_major() == majorVersion) {
                 return true;
             }
         }
@@ -328,31 +267,15 @@ status_t CameraProviderManager::getCameraInfo(const std::string &id,
 }
 
 status_t CameraProviderManager::isSessionConfigurationSupported(const std::string& id,
-        const SessionConfiguration &configuration, bool overrideForPerfClass,
-        metadataGetter getMetadata, bool *status /*out*/) const {
+        const hardware::camera::device::V3_7::StreamConfiguration &configuration,
+        bool *status /*out*/) const {
     std::lock_guard<std::mutex> lock(mInterfaceMutex);
     auto deviceInfo = findDeviceInfoLocked(id);
     if (deviceInfo == nullptr) {
         return NAME_NOT_FOUND;
     }
 
-    return deviceInfo->isSessionConfigurationSupported(configuration,
-            overrideForPerfClass, getMetadata, status);
-}
-
-status_t CameraProviderManager::getCameraIdIPCTransport(const std::string &id,
-        IPCTransport *providerTransport) const {
-    std::lock_guard<std::mutex> lock(mInterfaceMutex);
-    auto deviceInfo = findDeviceInfoLocked(id);
-    if (deviceInfo == nullptr) {
-        return NAME_NOT_FOUND;
-    }
-    sp<ProviderInfo> parentProvider = deviceInfo->mParentProvider.promote();
-    if (parentProvider == nullptr) {
-        return DEAD_OBJECT;
-    }
-    *providerTransport = parentProvider->getIPCTransport();
-    return OK;
+    return deviceInfo->isSessionConfigurationSupported(configuration, status);
 }
 
 status_t CameraProviderManager::getCameraCharacteristics(const std::string &id,
@@ -362,106 +285,39 @@ status_t CameraProviderManager::getCameraCharacteristics(const std::string &id,
 }
 
 status_t CameraProviderManager::getHighestSupportedVersion(const std::string &id,
-        hardware::hidl_version *v, IPCTransport *transport) {
-    if (v == nullptr || transport == nullptr) {
-        return BAD_VALUE;
-    }
+        hardware::hidl_version *v) {
     std::lock_guard<std::mutex> lock(mInterfaceMutex);
 
     hardware::hidl_version maxVersion{0,0};
     bool found = false;
-    IPCTransport providerTransport = IPCTransport::INVALID;
     for (auto& provider : mProviders) {
         for (auto& deviceInfo : provider->mDevices) {
             if (deviceInfo->mId == id) {
                 if (deviceInfo->mVersion > maxVersion) {
                     maxVersion = deviceInfo->mVersion;
-                    providerTransport = provider->getIPCTransport();
                     found = true;
                 }
             }
         }
     }
-    if (!found || providerTransport == IPCTransport::INVALID) {
+    if (!found) {
         return NAME_NOT_FOUND;
     }
     *v = maxVersion;
-    *transport = providerTransport;
     return OK;
 }
 
-status_t CameraProviderManager::getTorchStrengthLevel(const std::string &id,
-        int32_t* torchStrength /*out*/) {
-    std::lock_guard<std::mutex> lock(mInterfaceMutex);
-
-    auto deviceInfo = findDeviceInfoLocked(id);
-    if (deviceInfo == nullptr) return NAME_NOT_FOUND;
-
-    return deviceInfo->getTorchStrengthLevel(torchStrength);
-}
-
-status_t CameraProviderManager::turnOnTorchWithStrengthLevel(const std::string &id,
-        int32_t torchStrength) {
-    std::lock_guard<std::mutex> lock(mInterfaceMutex);
-
-    auto deviceInfo = findDeviceInfoLocked(id);
-    if (deviceInfo == nullptr) return NAME_NOT_FOUND;
-
-    return deviceInfo->turnOnTorchWithStrengthLevel(torchStrength);
-}
-
-bool CameraProviderManager::shouldSkipTorchStrengthUpdate(const std::string &id,
-        int32_t torchStrength) const {
-    std::lock_guard<std::mutex> lock(mInterfaceMutex);
-
-    auto deviceInfo = findDeviceInfoLocked(id);
-    if (deviceInfo == nullptr) return NAME_NOT_FOUND;
-
-    if (deviceInfo->mTorchStrengthLevel == torchStrength) {
-        ALOGV("%s: Skipping torch strength level updates prev_level: %d, new_level: %d",
-                __FUNCTION__, deviceInfo->mTorchStrengthLevel, torchStrength);
-        return true;
-    }
-    return false;
-}
-
-int32_t CameraProviderManager::getTorchDefaultStrengthLevel(const std::string &id) const {
-    std::lock_guard<std::mutex> lock(mInterfaceMutex);
-
-    auto deviceInfo = findDeviceInfoLocked(id);
-    if (deviceInfo == nullptr) return NAME_NOT_FOUND;
-
-    return deviceInfo->mTorchDefaultStrengthLevel;
-}
-
 bool CameraProviderManager::supportSetTorchMode(const std::string &id) const {
     std::lock_guard<std::mutex> lock(mInterfaceMutex);
     for (auto& provider : mProviders) {
-        for (auto& deviceInfo : provider->mDevices) {
-            if (deviceInfo->mId == id) {
-                return provider->mSetTorchModeSupported;
-            }
+        auto deviceInfo = findDeviceInfoLocked(id);
+        if (deviceInfo != nullptr) {
+            return provider->mSetTorchModeSupported;
         }
     }
     return false;
 }
 
-template <class ProviderInfoType, class HalCameraProviderType>
-status_t CameraProviderManager::setTorchModeT(sp<ProviderInfo> &parentProvider,
-        std::shared_ptr<HalCameraProvider> *halCameraProvider) {
-    if (halCameraProvider == nullptr) {
-        return BAD_VALUE;
-    }
-    ProviderInfoType *idlProviderInfo = static_cast<ProviderInfoType *>(parentProvider.get());
-    auto idlInterface = idlProviderInfo->startProviderInterface();
-    if (idlInterface == nullptr) {
-        return DEAD_OBJECT;
-    }
-    *halCameraProvider =
-            std::make_shared<HalCameraProviderType>(idlInterface, idlInterface->descriptor);
-    return OK;
-}
-
 status_t CameraProviderManager::setTorchMode(const std::string &id, bool enabled) {
     std::lock_guard<std::mutex> lock(mInterfaceMutex);
 
@@ -474,26 +330,11 @@ status_t CameraProviderManager::setTorchMode(const std::string &id, bool enabled
     if (parentProvider == nullptr) {
         return DEAD_OBJECT;
     }
-    std::shared_ptr<HalCameraProvider> halCameraProvider = nullptr;
-    IPCTransport providerTransport = parentProvider->getIPCTransport();
-    status_t res = OK;
-    if (providerTransport == IPCTransport::HIDL) {
-        res = setTorchModeT<HidlProviderInfo, HidlHalCameraProvider>(parentProvider,
-                &halCameraProvider);
-        if (res != OK) {
-            return res;
-        }
-    } else if (providerTransport == IPCTransport::AIDL) {
-        res = setTorchModeT<AidlProviderInfo, AidlHalCameraProvider>(parentProvider,
-                &halCameraProvider);
-        if (res != OK) {
-            return res;
-        }
-    } else {
-        ALOGE("%s Invalid provider transport", __FUNCTION__);
-        return INVALID_OPERATION;
+    const sp<provider::V2_4::ICameraProvider> interface = parentProvider->startProviderInterface();
+    if (interface == nullptr) {
+        return DEAD_OBJECT;
     }
-    saveRef(DeviceMode::TORCH, deviceInfo->mId, halCameraProvider);
+    saveRef(DeviceMode::TORCH, deviceInfo->mId, interface);
 
     return deviceInfo->setTorchMode(enabled);
 }
@@ -510,72 +351,8 @@ status_t CameraProviderManager::setUpVendorTags() {
     return OK;
 }
 
-sp<CameraProviderManager::ProviderInfo> CameraProviderManager::startExternalLazyProvider() const {
-    std::lock_guard<std::mutex> providerLock(mProviderLifecycleLock);
-    std::lock_guard<std::mutex> lock(mInterfaceMutex);
-
-    for (const auto& providerInfo : mProviders) {
-        if (providerInfo->isExternalLazyHAL()) {
-            if (!providerInfo->successfullyStartedProviderInterface()) {
-                return nullptr;
-            } else {
-                return providerInfo;
-            }
-        }
-    }
-    return nullptr;
-}
-
-status_t CameraProviderManager::notifyUsbDeviceEvent(int32_t eventId,
-                                                     const std::string& usbDeviceId) {
-    if (!kEnableLazyHal) {
-        return OK;
-    }
-
-    ALOGV("notifySystemEvent: %d usbDeviceId : %s", eventId, usbDeviceId.c_str());
-
-    if (eventId == android::hardware::ICameraService::EVENT_USB_DEVICE_ATTACHED) {
-        sp<ProviderInfo> externalProvider = startExternalLazyProvider();
-        if (externalProvider != nullptr) {
-            auto usbDevices = mExternalUsbDevicesForProvider.first;
-            usbDevices.push_back(usbDeviceId);
-            mExternalUsbDevicesForProvider = {usbDevices, externalProvider};
-        }
-    } else if (eventId
-          == android::hardware::ICameraService::EVENT_USB_DEVICE_DETACHED) {
-        usbDeviceDetached(usbDeviceId);
-    }
-
-    return OK;
-}
-
-status_t CameraProviderManager::usbDeviceDetached(const std::string &usbDeviceId) {
-    std::lock_guard<std::mutex> providerLock(mProviderLifecycleLock);
-    std::lock_guard<std::mutex> interfaceLock(mInterfaceMutex);
-
-    auto usbDevices = mExternalUsbDevicesForProvider.first;
-    auto foundId = std::find(usbDevices.begin(), usbDevices.end(), usbDeviceId);
-    if (foundId != usbDevices.end()) {
-        sp<ProviderInfo> providerInfo = mExternalUsbDevicesForProvider.second;
-        if (providerInfo == nullptr) {
-              ALOGE("%s No valid external provider for USB device: %s",
-                    __FUNCTION__,
-                    usbDeviceId.c_str());
-              mExternalUsbDevicesForProvider = {std::vector<std::string>(), nullptr};
-              return DEAD_OBJECT;
-        } else {
-            mInterfaceMutex.unlock();
-            providerInfo->removeAllDevices();
-            mInterfaceMutex.lock();
-            mExternalUsbDevicesForProvider = {std::vector<std::string>(), nullptr};
-        }
-    } else {
-        return DEAD_OBJECT;
-    }
-    return OK;
-}
-
-status_t CameraProviderManager::notifyDeviceStateChange(int64_t newState) {
+status_t CameraProviderManager::notifyDeviceStateChange(
+        hardware::hidl_bitfield<provider::V2_5::DeviceState> newState) {
     std::lock_guard<std::mutex> lock(mInterfaceMutex);
     mDeviceState = newState;
     status_t res = OK;
@@ -601,115 +378,32 @@ status_t CameraProviderManager::notifyDeviceStateChange(int64_t newState) {
     return res;
 }
 
-status_t CameraProviderManager::openAidlSession(const std::string &id,
-        const std::shared_ptr<
-                aidl::android::hardware::camera::device::ICameraDeviceCallback>& callback,
-        /*out*/
-        std::shared_ptr<aidl::android::hardware::camera::device::ICameraDeviceSession> *session) {
-
-    std::lock_guard<std::mutex> lock(mInterfaceMutex);
-
-    auto deviceInfo = findDeviceInfoLocked(id);
-    if (deviceInfo == nullptr) return NAME_NOT_FOUND;
-
-    auto *aidlDeviceInfo3 = static_cast<AidlProviderInfo::AidlDeviceInfo3*>(deviceInfo);
-    sp<ProviderInfo> parentProvider = deviceInfo->mParentProvider.promote();
-    if (parentProvider == nullptr) {
-        return DEAD_OBJECT;
-    }
-    auto provider =
-            static_cast<AidlProviderInfo *>(parentProvider.get())->startProviderInterface();
-    if (provider == nullptr) {
-        return DEAD_OBJECT;
-    }
-    std::shared_ptr<HalCameraProvider> halCameraProvider =
-            std::make_shared<AidlHalCameraProvider>(provider, provider->descriptor);
-    saveRef(DeviceMode::CAMERA, id, halCameraProvider);
-
-    auto interface = aidlDeviceInfo3->startDeviceInterface();
-    if (interface == nullptr) {
-        removeRef(DeviceMode::CAMERA, id);
-        return DEAD_OBJECT;
-    }
-
-    auto ret = interface->open(callback, session);
-    if (!ret.isOk()) {
-        removeRef(DeviceMode::CAMERA, id);
-        ALOGE("%s: Transaction error opening a session for camera device %s: %s",
-                __FUNCTION__, id.c_str(), ret.getMessage());
-        return AidlProviderInfo::mapToStatusT(ret);
-    }
-    return OK;
-}
-
-status_t CameraProviderManager::openAidlInjectionSession(const std::string &id,
-        const std::shared_ptr<
-                aidl::android::hardware::camera::device::ICameraDeviceCallback>& callback,
-        /*out*/
-        std::shared_ptr<
-                aidl::android::hardware::camera::device::ICameraInjectionSession> *session) {
-
-    std::lock_guard<std::mutex> lock(mInterfaceMutex);
-
-    auto deviceInfo = findDeviceInfoLocked(id);
-    if (deviceInfo == nullptr) return NAME_NOT_FOUND;
-
-    auto *aidlDeviceInfo3 = static_cast<AidlProviderInfo::AidlDeviceInfo3*>(deviceInfo);
-    sp<ProviderInfo> parentProvider = deviceInfo->mParentProvider.promote();
-    if (parentProvider == nullptr) {
-        return DEAD_OBJECT;
-    }
-    auto provider =
-            static_cast<AidlProviderInfo *>(parentProvider.get())->startProviderInterface();
-    if (provider == nullptr) {
-        return DEAD_OBJECT;
-    }
-    std::shared_ptr<HalCameraProvider> halCameraProvider =
-            std::make_shared<AidlHalCameraProvider>(provider, provider->descriptor);
-    saveRef(DeviceMode::CAMERA, id, halCameraProvider);
-
-    auto interface = aidlDeviceInfo3->startDeviceInterface();
-    if (interface == nullptr) {
-        return DEAD_OBJECT;
-    }
-
-    auto ret = interface->openInjectionSession(callback, session);
-    if (!ret.isOk()) {
-        removeRef(DeviceMode::CAMERA, id);
-        ALOGE("%s: Transaction error opening a session for camera device %s: %s",
-                __FUNCTION__, id.c_str(), ret.getMessage());
-        return DEAD_OBJECT;
-    }
-    return OK;
-}
-
-status_t CameraProviderManager::openHidlSession(const std::string &id,
+status_t CameraProviderManager::openSession(const std::string &id,
         const sp<device::V3_2::ICameraDeviceCallback>& callback,
         /*out*/
         sp<device::V3_2::ICameraDeviceSession> *session) {
 
     std::lock_guard<std::mutex> lock(mInterfaceMutex);
 
-    auto deviceInfo = findDeviceInfoLocked(id);
+    auto deviceInfo = findDeviceInfoLocked(id,
+            /*minVersion*/ {3,0}, /*maxVersion*/ {4,0});
     if (deviceInfo == nullptr) return NAME_NOT_FOUND;
 
-    auto *hidlDeviceInfo3 = static_cast<HidlProviderInfo::HidlDeviceInfo3*>(deviceInfo);
+    auto *deviceInfo3 = static_cast<ProviderInfo::DeviceInfo3*>(deviceInfo);
     sp<ProviderInfo> parentProvider = deviceInfo->mParentProvider.promote();
     if (parentProvider == nullptr) {
         return DEAD_OBJECT;
     }
-    const sp<provider::V2_4::ICameraProvider> provider =
-            static_cast<HidlProviderInfo *>(parentProvider.get())->startProviderInterface();
+    const sp<provider::V2_4::ICameraProvider> provider = parentProvider->startProviderInterface();
     if (provider == nullptr) {
         return DEAD_OBJECT;
     }
-    std::shared_ptr<HalCameraProvider> halCameraProvider =
-            std::make_shared<HidlHalCameraProvider>(provider, provider->descriptor);
-    saveRef(DeviceMode::CAMERA, id, halCameraProvider);
+    saveRef(DeviceMode::CAMERA, id, provider);
 
     Status status;
     hardware::Return<void> ret;
-    auto interface = hidlDeviceInfo3->startDeviceInterface();
+    auto interface = deviceInfo3->startDeviceInterface<
+            CameraProviderManager::ProviderInfo::DeviceInfo3::InterfaceT>();
     if (interface == nullptr) {
         return DEAD_OBJECT;
     }
@@ -727,18 +421,17 @@ status_t CameraProviderManager::openHidlSession(const std::string &id,
                 __FUNCTION__, id.c_str(), ret.description().c_str());
         return DEAD_OBJECT;
     }
-    return HidlProviderInfo::mapToStatusT(status);
+    return mapToStatusT(status);
 }
 
 void CameraProviderManager::saveRef(DeviceMode usageType, const std::string &cameraId,
-        std::shared_ptr<HalCameraProvider> provider) {
+        sp<provider::V2_4::ICameraProvider> provider) {
     if (!kEnableLazyHal) {
         return;
     }
-    ALOGV("Saving camera provider %s for camera device %s", provider->mDescriptor.c_str(),
-              cameraId.c_str());
+    ALOGV("Saving camera provider %s for camera device %s", provider->descriptor, cameraId.c_str());
     std::lock_guard<std::mutex> lock(mProviderInterfaceMapLock);
-    std::unordered_map<std::string, std::shared_ptr<HalCameraProvider>> *primaryMap, *alternateMap;
+    std::unordered_map<std::string, sp<provider::V2_4::ICameraProvider>> *primaryMap, *alternateMap;
     if (usageType == DeviceMode::TORCH) {
         primaryMap = &mTorchProviderByCameraId;
         alternateMap = &mCameraProviderByCameraId;
@@ -761,7 +454,7 @@ void CameraProviderManager::removeRef(DeviceMode usageType, const std::string &c
         return;
     }
     ALOGV("Removing camera device %s", cameraId.c_str());
-    std::unordered_map<std::string, std::shared_ptr<HalCameraProvider>> *providerMap;
+    std::unordered_map<std::string, sp<provider::V2_4::ICameraProvider>> *providerMap;
     if (usageType == DeviceMode::TORCH) {
         providerMap = &mTorchProviderByCameraId;
     } else {
@@ -786,26 +479,6 @@ void CameraProviderManager::removeRef(DeviceMode usageType, const std::string &c
     }
 }
 
-// We ignore sp<IBinder> param here since we need std::shared_ptr<...> which
-// will be retrieved through the ndk api through addAidlProviderLocked ->
-// tryToInitializeAidlProvider.
-void CameraProviderManager::onServiceRegistration(const String16 &name, const sp<IBinder>&) {
-    status_t res = OK;
-    std::lock_guard<std::mutex> providerLock(mProviderLifecycleLock);
-    {
-        std::lock_guard<std::mutex> lock(mInterfaceMutex);
-
-        res = addAidlProviderLocked(String8(name).c_str());
-    }
-
-    sp<StatusListener> listener = getStatusListener();
-    if (nullptr != listener.get() && res == OK) {
-        listener->onNewProviderRegistered();
-    }
-
-    IPCThreadState::self()->flushCommands();
-}
-
 hardware::Return<void> CameraProviderManager::onRegistration(
         const hardware::hidl_string& /*fqName*/,
         const hardware::hidl_string& name,
@@ -815,7 +488,7 @@ hardware::Return<void> CameraProviderManager::onRegistration(
     {
         std::lock_guard<std::mutex> lock(mInterfaceMutex);
 
-        res = addHidlProviderLocked(name, preexisting);
+        res = addProviderLocked(name, preexisting);
     }
 
     sp<StatusListener> listener = getStatusListener();
@@ -837,70 +510,10 @@ status_t CameraProviderManager::dump(int fd, const Vector<String16>& args) {
     return OK;
 }
 
-void CameraProviderManager::ProviderInfo::initializeProviderInfoCommon(
-        const std::vector<std::string> &devices) {
-
-    sp<StatusListener> listener = mManager->getStatusListener();
-
-    for (auto& device : devices) {
-        std::string id;
-        status_t res = addDevice(device, CameraDeviceStatus::PRESENT, &id);
-        if (res != OK) {
-            ALOGE("%s: Unable to enumerate camera device '%s': %s (%d)",
-                    __FUNCTION__, device.c_str(), strerror(-res), res);
-            continue;
-        }
-    }
-
-    ALOGI("Camera provider %s ready with %zu camera devices",
-            mProviderName.c_str(), mDevices.size());
-
-    // Process cached status callbacks
-    std::unique_ptr<std::vector<CameraStatusInfoT>> cachedStatus =
-            std::make_unique<std::vector<CameraStatusInfoT>>();
-    {
-        std::lock_guard<std::mutex> lock(mInitLock);
-
-        for (auto& statusInfo : mCachedStatus) {
-            std::string id, physicalId;
-            status_t res = OK;
-            if (statusInfo.isPhysicalCameraStatus) {
-                res = physicalCameraDeviceStatusChangeLocked(&id, &physicalId,
-                    statusInfo.cameraId, statusInfo.physicalCameraId, statusInfo.status);
-            } else {
-                res = cameraDeviceStatusChangeLocked(&id, statusInfo.cameraId, statusInfo.status);
-            }
-            if (res == OK) {
-                cachedStatus->emplace_back(statusInfo.isPhysicalCameraStatus,
-                        id.c_str(), physicalId.c_str(), statusInfo.status);
-            }
-        }
-        mCachedStatus.clear();
-
-        mInitialized = true;
-    }
-
-    // The cached status change callbacks cannot be fired directly from this
-    // function, due to same-thread deadlock trying to acquire mInterfaceMutex
-    // twice.
-    if (listener != nullptr) {
-        mInitialStatusCallbackFuture = std::async(std::launch::async,
-                &CameraProviderManager::ProviderInfo::notifyInitialStatusChange, this,
-                listener, std::move(cachedStatus));
-    }
-}
-
 CameraProviderManager::ProviderInfo::DeviceInfo* CameraProviderManager::findDeviceInfoLocked(
-        const std::string& id) const {
+        const std::string& id,
+        hardware::hidl_version minVersion, hardware::hidl_version maxVersion) const {
     for (auto& provider : mProviders) {
-        using hardware::hidl_version;
-        IPCTransport transport = provider->getIPCTransport();
-        // AIDL min version starts at major: 1 minor: 1
-        hidl_version minVersion =
-                (transport == IPCTransport::HIDL) ? hidl_version{3, 2} : hidl_version{1, 1} ;
-        hidl_version maxVersion =
-                (transport == IPCTransport::HIDL) ? hidl_version{3, 7} : hidl_version{1000, 0};
-
         for (auto& deviceInfo : provider->mDevices) {
             if (deviceInfo->mId == id &&
                     minVersion <= deviceInfo->mVersion && maxVersion >= deviceInfo->mVersion) {
@@ -912,13 +525,16 @@ CameraProviderManager::ProviderInfo::DeviceInfo* CameraProviderManager::findDevi
 }
 
 metadata_vendor_id_t CameraProviderManager::getProviderTagIdLocked(
-        const std::string& id) const {
+        const std::string& id, hardware::hidl_version minVersion,
+        hardware::hidl_version maxVersion) const {
     metadata_vendor_id_t ret = CAMERA_METADATA_INVALID_VENDOR_ID;
 
     std::lock_guard<std::mutex> lock(mInterfaceMutex);
     for (auto& provider : mProviders) {
         for (auto& deviceInfo : provider->mDevices) {
-            if (deviceInfo->mId == id) {
+            if (deviceInfo->mId == id &&
+                    minVersion <= deviceInfo->mVersion &&
+                    maxVersion >= deviceInfo->mVersion) {
                 return provider->mProviderTagid;
             }
         }
@@ -1241,45 +857,12 @@ status_t CameraProviderManager::ProviderInfo::DeviceInfo3::addDynamicDepthTags(
     return OK;
 }
 
-status_t CameraProviderManager::ProviderInfo::DeviceInfo3::fixupTorchStrengthTags() {
-    status_t res = OK;
-    auto& c = mCameraCharacteristics;
-    auto flashInfoStrengthDefaultLevelEntry = c.find(ANDROID_FLASH_INFO_STRENGTH_DEFAULT_LEVEL);
-    if (flashInfoStrengthDefaultLevelEntry.count == 0) {
-        int32_t flashInfoStrengthDefaultLevel = 1;
-        res = c.update(ANDROID_FLASH_INFO_STRENGTH_DEFAULT_LEVEL,
-                &flashInfoStrengthDefaultLevel, 1);
-        if (res != OK) {
-            ALOGE("%s: Failed to update ANDROID_FLASH_INFO_STRENGTH_DEFAULT_LEVEL: %s (%d)",
-                    __FUNCTION__,strerror(-res), res);
-            return res;
-        }
-    }
-    auto flashInfoStrengthMaximumLevelEntry = c.find(ANDROID_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL);
-    if (flashInfoStrengthMaximumLevelEntry.count == 0) {
-        int32_t flashInfoStrengthMaximumLevel = 1;
-        res = c.update(ANDROID_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL,
-                &flashInfoStrengthMaximumLevel, 1);
-        if (res != OK) {
-            ALOGE("%s: Failed to update ANDROID_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL: %s (%d)",
-                    __FUNCTION__,strerror(-res), res);
-            return res;
-        }
-    }
-    return res;
-}
-
 status_t CameraProviderManager::ProviderInfo::DeviceInfo3::fixupMonochromeTags() {
     status_t res = OK;
     auto& c = mCameraCharacteristics;
-    sp<ProviderInfo> parentProvider = mParentProvider.promote();
-    if (parentProvider == nullptr) {
-        return DEAD_OBJECT;
-    }
-    IPCTransport ipcTransport = parentProvider->getIPCTransport();
+
     // Override static metadata for MONOCHROME camera with older device version
-    if (ipcTransport == IPCTransport::HIDL &&
-            (mVersion.get_major() == 3 && mVersion.get_minor() < 5)) {
+    if (mVersion.get_major() == 3 && mVersion.get_minor() < 5) {
         camera_metadata_entry cap = c.find(ANDROID_REQUEST_AVAILABLE_CAPABILITIES);
         for (size_t i = 0; i < cap.count; i++) {
             if (cap.data.u8[i] == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME) {
@@ -1639,7 +1222,6 @@ CameraProviderManager::isHiddenPhysicalCameraInternal(const std::string& cameraI
     }
 
     for (auto& provider : mProviders) {
-        IPCTransport transport = provider->getIPCTransport();
         for (auto& deviceInfo : provider->mDevices) {
             std::vector<std::string> physicalIds;
             if (deviceInfo->mIsLogicalCamera) {
@@ -1647,8 +1229,7 @@ CameraProviderManager::isHiddenPhysicalCameraInternal(const std::string& cameraI
                         cameraId) != deviceInfo->mPhysicalIds.end()) {
                     int deviceVersion = HARDWARE_DEVICE_API_VERSION(
                             deviceInfo->mVersion.get_major(), deviceInfo->mVersion.get_minor());
-                    if (transport == IPCTransport::HIDL &&
-                            deviceVersion < CAMERA_DEVICE_API_VERSION_3_5) {
+                    if (deviceVersion < CAMERA_DEVICE_API_VERSION_3_5) {
                         ALOGE("%s: Wrong deviceVersion %x for hiddenPhysicalCameraId %s",
                                 __FUNCTION__, deviceVersion, cameraId.c_str());
                         return falseRet;
@@ -1663,89 +1244,23 @@ CameraProviderManager::isHiddenPhysicalCameraInternal(const std::string& cameraI
     return falseRet;
 }
 
-status_t CameraProviderManager::tryToInitializeAidlProviderLocked(
-        const std::string& providerName, const sp<ProviderInfo>& providerInfo) {
-    using aidl::android::hardware::camera::provider::ICameraProvider;
-    std::shared_ptr<ICameraProvider> interface =
-            ICameraProvider::fromBinder(ndk::SpAIBinder(
-                    AServiceManager_getService(providerName.c_str())));
-
-    if (interface == nullptr) {
-        ALOGW("%s: AIDL Camera provider HAL '%s' is not actually available", __FUNCTION__,
-                providerName.c_str());
-        return BAD_VALUE;
-    }
-
-    AidlProviderInfo *aidlProviderInfo = static_cast<AidlProviderInfo *>(providerInfo.get());
-    return aidlProviderInfo->initializeAidlProvider(interface, mDeviceState);
-}
-
-status_t CameraProviderManager::tryToInitializeHidlProviderLocked(
+status_t CameraProviderManager::tryToInitializeProviderLocked(
         const std::string& providerName, const sp<ProviderInfo>& providerInfo) {
     sp<provider::V2_4::ICameraProvider> interface;
-    interface = mHidlServiceProxy->tryGetService(providerName);
+    interface = mServiceProxy->tryGetService(providerName);
 
     if (interface == nullptr) {
         // The interface may not be started yet. In that case, this is not a
         // fatal error.
-        ALOGW("%s: HIDL Camera provider HAL '%s' is not actually available", __FUNCTION__,
+        ALOGW("%s: Camera provider HAL '%s' is not actually available", __FUNCTION__,
                 providerName.c_str());
         return BAD_VALUE;
     }
 
-    HidlProviderInfo *hidlProviderInfo = static_cast<HidlProviderInfo *>(providerInfo.get());
-    return hidlProviderInfo->initializeHidlProvider(interface, mDeviceState);
-}
-
-status_t CameraProviderManager::addAidlProviderLocked(const std::string& newProvider) {
-    // Several camera provider instances can be temporarily present.
-    // Defer initialization of a new instance until the older instance is properly removed.
-    auto providerInstance = newProvider + "-" + std::to_string(mProviderInstanceId);
-    bool providerPresent = false;
-    bool preexisting =
-            (mAidlProviderWithBinders.find(newProvider) != mAidlProviderWithBinders.end());
-
-    // We need to use the extracted provider name here since 'newProvider' has
-    // the fully qualified name of the provider service in case of AIDL. We want
-    // just instance name.
-    using aidl::android::hardware::camera::provider::ICameraProvider;
-    std::string extractedProviderName =
-            newProvider.substr(std::string(ICameraProvider::descriptor).size() + 1);
-    for (const auto& providerInfo : mProviders) {
-        if (providerInfo->mProviderName == extractedProviderName) {
-            ALOGW("%s: Camera provider HAL with name '%s' already registered",
-                    __FUNCTION__, newProvider.c_str());
-            // Do not add new instances for lazy HAL external provider or aidl
-            // binders previously seen.
-            if (preexisting || providerInfo->isExternalLazyHAL()) {
-                return ALREADY_EXISTS;
-            } else {
-                ALOGW("%s: The new provider instance will get initialized immediately after the"
-                        " currently present instance is removed!", __FUNCTION__);
-                providerPresent = true;
-                break;
-            }
-        }
-    }
-
-    sp<AidlProviderInfo> providerInfo =
-            new AidlProviderInfo(extractedProviderName, providerInstance, this);
-
-    if (!providerPresent) {
-        status_t res = tryToInitializeAidlProviderLocked(newProvider, providerInfo);
-        if (res != OK) {
-            return res;
-        }
-        mAidlProviderWithBinders.emplace(newProvider);
-    }
-
-    mProviders.push_back(providerInfo);
-    mProviderInstanceId++;
-
-    return OK;
+    return providerInfo->initialize(interface, mDeviceState);
 }
 
-status_t CameraProviderManager::addHidlProviderLocked(const std::string& newProvider,
+status_t CameraProviderManager::addProviderLocked(const std::string& newProvider,
         bool preexisting) {
     // Several camera provider instances can be temporarily present.
     // Defer initialization of a new instance until the older instance is properly removed.
@@ -1755,10 +1270,9 @@ status_t CameraProviderManager::addHidlProviderLocked(const std::string& newProv
         if (providerInfo->mProviderName == newProvider) {
             ALOGW("%s: Camera provider HAL with name '%s' already registered",
                     __FUNCTION__, newProvider.c_str());
-            // Do not add new instances for lazy HAL external provider
-            if (preexisting || providerInfo->isExternalLazyHAL()) {
+            if (preexisting) {
                 return ALREADY_EXISTS;
-            } else {
+            } else{
                 ALOGW("%s: The new provider instance will get initialized immediately after the"
                         " currently present instance is removed!", __FUNCTION__);
                 providerPresent = true;
@@ -1767,9 +1281,9 @@ status_t CameraProviderManager::addHidlProviderLocked(const std::string& newProv
         }
     }
 
-    sp<HidlProviderInfo> providerInfo = new HidlProviderInfo(newProvider, providerInstance, this);
+    sp<ProviderInfo> providerInfo = new ProviderInfo(newProvider, providerInstance, this);
     if (!providerPresent) {
-        status_t res = tryToInitializeHidlProviderLocked(newProvider, providerInfo);
+        status_t res = tryToInitializeProviderLocked(newProvider, providerInfo);
         if (res != OK) {
             return res;
         }
@@ -1807,17 +1321,7 @@ status_t CameraProviderManager::removeProvider(const std::string& provider) {
         // initialize.
         for (const auto& providerInfo : mProviders) {
             if (providerInfo->mProviderName == removedProviderName) {
-                IPCTransport providerTransport = providerInfo->getIPCTransport();
-                std::string removedAidlProviderName = getFullAidlProviderName(removedProviderName);
-                switch(providerTransport) {
-                    case IPCTransport::HIDL:
-                        return tryToInitializeHidlProviderLocked(removedProviderName, providerInfo);
-                    case IPCTransport::AIDL:
-                        return tryToInitializeAidlProviderLocked(removedAidlProviderName,
-                                providerInfo);
-                    default:
-                        ALOGE("%s Unsupported Transport %d", __FUNCTION__, providerTransport);
-                }
+                return tryToInitializeProviderLocked(removedProviderName, providerInfo);
             }
         }
 
@@ -1839,6 +1343,7 @@ status_t CameraProviderManager::removeProvider(const std::string& provider) {
 sp<CameraProviderManager::StatusListener> CameraProviderManager::getStatusListener() const {
     return mListener.promote();
 }
+
 /**** Methods for ProviderInfo ****/
 
 
@@ -1854,63 +1359,286 @@ CameraProviderManager::ProviderInfo::ProviderInfo(
     (void) mManager;
 }
 
+status_t CameraProviderManager::ProviderInfo::initialize(
+        sp<provider::V2_4::ICameraProvider>& interface,
+        hardware::hidl_bitfield<provider::V2_5::DeviceState> currentDeviceState) {
+    status_t res = parseProviderName(mProviderName, &mType, &mId);
+    if (res != OK) {
+        ALOGE("%s: Invalid provider name, ignoring", __FUNCTION__);
+        return BAD_VALUE;
+    }
+    ALOGI("Connecting to new camera provider: %s, isRemote? %d",
+            mProviderName.c_str(), interface->isRemote());
+
+    // Determine minor version
+    mMinorVersion = 4;
+    auto cast2_6 = provider::V2_6::ICameraProvider::castFrom(interface);
+    sp<provider::V2_6::ICameraProvider> interface2_6 = nullptr;
+    if (cast2_6.isOk()) {
+        interface2_6 = cast2_6;
+        if (interface2_6 != nullptr) {
+            mMinorVersion = 6;
+        }
+    }
+    // We need to check again since cast2_6.isOk() succeeds even if the provider
+    // version isn't actually 2.6.
+    if (interface2_6 == nullptr){
+        auto cast2_5 =
+                provider::V2_5::ICameraProvider::castFrom(interface);
+        sp<provider::V2_5::ICameraProvider> interface2_5 = nullptr;
+        if (cast2_5.isOk()) {
+            interface2_5 = cast2_5;
+            if (interface != nullptr) {
+                mMinorVersion = 5;
+            }
+        }
+    } else {
+        auto cast2_7 = provider::V2_7::ICameraProvider::castFrom(interface);
+        if (cast2_7.isOk()) {
+            sp<provider::V2_7::ICameraProvider> interface2_7 = cast2_7;
+            if (interface2_7 != nullptr) {
+                mMinorVersion = 7;
+            }
+        }
+    }
+
+    // cameraDeviceStatusChange callbacks may be called (and causing new devices added)
+    // before setCallback returns
+    hardware::Return<Status> status = interface->setCallback(this);
+    if (!status.isOk()) {
+        ALOGE("%s: Transaction error setting up callbacks with camera provider '%s': %s",
+                __FUNCTION__, mProviderName.c_str(), status.description().c_str());
+        return DEAD_OBJECT;
+    }
+    if (status != Status::OK) {
+        ALOGE("%s: Unable to register callbacks with camera provider '%s'",
+                __FUNCTION__, mProviderName.c_str());
+        return mapToStatusT(status);
+    }
+
+    hardware::Return<bool> linked = interface->linkToDeath(this, /*cookie*/ mId);
+    if (!linked.isOk()) {
+        ALOGE("%s: Transaction error in linking to camera provider '%s' death: %s",
+                __FUNCTION__, mProviderName.c_str(), linked.description().c_str());
+        return DEAD_OBJECT;
+    } else if (!linked) {
+        ALOGW("%s: Unable to link to provider '%s' death notifications",
+                __FUNCTION__, mProviderName.c_str());
+    }
+
+    if (!kEnableLazyHal) {
+        // Save HAL reference indefinitely
+        mSavedInterface = interface;
+    } else {
+        mActiveInterface = interface;
+    }
+
+    ALOGV("%s: Setting device state for %s: 0x%" PRIx64,
+            __FUNCTION__, mProviderName.c_str(), mDeviceState);
+    notifyDeviceStateChange(currentDeviceState);
+
+    res = setUpVendorTags();
+    if (res != OK) {
+        ALOGE("%s: Unable to set up vendor tags from provider '%s'",
+                __FUNCTION__, mProviderName.c_str());
+        return res;
+    }
+
+    // Get initial list of camera devices, if any
+    std::vector<std::string> devices;
+    hardware::Return<void> ret = interface->getCameraIdList([&status, this, &devices](
+            Status idStatus,
+            const hardware::hidl_vec<hardware::hidl_string>& cameraDeviceNames) {
+        status = idStatus;
+        if (status == Status::OK) {
+            for (auto& name : cameraDeviceNames) {
+                uint16_t major, minor;
+                std::string type, id;
+                status_t res = parseDeviceName(name, &major, &minor, &type, &id);
+                if (res != OK) {
+                    ALOGE("%s: Error parsing deviceName: %s: %d", __FUNCTION__, name.c_str(), res);
+                    status = Status::INTERNAL_ERROR;
+                } else {
+                    devices.push_back(name);
+                    mProviderPublicCameraIds.push_back(id);
+                }
+            }
+        } });
+    if (!ret.isOk()) {
+        ALOGE("%s: Transaction error in getting camera ID list from provider '%s': %s",
+                __FUNCTION__, mProviderName.c_str(), linked.description().c_str());
+        return DEAD_OBJECT;
+    }
+    if (status != Status::OK) {
+        ALOGE("%s: Unable to query for camera devices from provider '%s'",
+                __FUNCTION__, mProviderName.c_str());
+        return mapToStatusT(status);
+    }
+
+    // Get list of concurrent streaming camera device combinations
+    if (mMinorVersion >= 6) {
+        res = getConcurrentCameraIdsInternalLocked(interface2_6);
+        if (res != OK) {
+            return res;
+        }
+    }
+
+    ret = interface->isSetTorchModeSupported(
+        [this](auto status, bool supported) {
+            if (status == Status::OK) {
+                mSetTorchModeSupported = supported;
+            }
+        });
+    if (!ret.isOk()) {
+        ALOGE("%s: Transaction error checking torch mode support '%s': %s",
+                __FUNCTION__, mProviderName.c_str(), ret.description().c_str());
+        return DEAD_OBJECT;
+    }
+
+    mIsRemote = interface->isRemote();
+
+    sp<StatusListener> listener = mManager->getStatusListener();
+    for (auto& device : devices) {
+        std::string id;
+        status_t res = addDevice(device, common::V1_0::CameraDeviceStatus::PRESENT, &id);
+        if (res != OK) {
+            ALOGE("%s: Unable to enumerate camera device '%s': %s (%d)",
+                    __FUNCTION__, device.c_str(), strerror(-res), res);
+            continue;
+        }
+    }
+
+    ALOGI("Camera provider %s ready with %zu camera devices",
+            mProviderName.c_str(), mDevices.size());
+
+    // Process cached status callbacks
+    std::unique_ptr<std::vector<CameraStatusInfoT>> cachedStatus =
+            std::make_unique<std::vector<CameraStatusInfoT>>();
+    {
+        std::lock_guard<std::mutex> lock(mInitLock);
+
+        for (auto& statusInfo : mCachedStatus) {
+            std::string id, physicalId;
+            status_t res = OK;
+            if (statusInfo.isPhysicalCameraStatus) {
+                res = physicalCameraDeviceStatusChangeLocked(&id, &physicalId,
+                    statusInfo.cameraId, statusInfo.physicalCameraId, statusInfo.status);
+            } else {
+                res = cameraDeviceStatusChangeLocked(&id, statusInfo.cameraId, statusInfo.status);
+            }
+            if (res == OK) {
+                cachedStatus->emplace_back(statusInfo.isPhysicalCameraStatus,
+                        id.c_str(), physicalId.c_str(), statusInfo.status);
+            }
+        }
+        mCachedStatus.clear();
+
+        mInitialized = true;
+    }
+
+    // The cached status change callbacks cannot be fired directly from this
+    // function, due to same-thread deadlock trying to acquire mInterfaceMutex
+    // twice.
+    if (listener != nullptr) {
+        mInitialStatusCallbackFuture = std::async(std::launch::async,
+                &CameraProviderManager::ProviderInfo::notifyInitialStatusChange, this,
+                listener, std::move(cachedStatus));
+    }
+
+    return OK;
+}
+
+const sp<provider::V2_4::ICameraProvider>
+CameraProviderManager::ProviderInfo::startProviderInterface() {
+    ATRACE_CALL();
+    ALOGV("Request to start camera provider: %s", mProviderName.c_str());
+    if (mSavedInterface != nullptr) {
+        return mSavedInterface;
+    }
+    if (!kEnableLazyHal) {
+        ALOGE("Bad provider state! Should not be here on a non-lazy HAL!");
+        return nullptr;
+    }
+
+    auto interface = mActiveInterface.promote();
+    if (interface == nullptr) {
+        ALOGI("Camera HAL provider needs restart, calling getService(%s)", mProviderName.c_str());
+        interface = mManager->mServiceProxy->getService(mProviderName);
+        interface->setCallback(this);
+        hardware::Return<bool> linked = interface->linkToDeath(this, /*cookie*/ mId);
+        if (!linked.isOk()) {
+            ALOGE("%s: Transaction error in linking to camera provider '%s' death: %s",
+                    __FUNCTION__, mProviderName.c_str(), linked.description().c_str());
+            mManager->removeProvider(mProviderName);
+            return nullptr;
+        } else if (!linked) {
+            ALOGW("%s: Unable to link to provider '%s' death notifications",
+                    __FUNCTION__, mProviderName.c_str());
+        }
+        // Send current device state
+        if (mMinorVersion >= 5) {
+            auto castResult = provider::V2_5::ICameraProvider::castFrom(interface);
+            if (castResult.isOk()) {
+                sp<provider::V2_5::ICameraProvider> interface_2_5 = castResult;
+                if (interface_2_5 != nullptr) {
+                    ALOGV("%s: Initial device state for %s: 0x %" PRIx64,
+                            __FUNCTION__, mProviderName.c_str(), mDeviceState);
+                    interface_2_5->notifyDeviceStateChange(mDeviceState);
+                }
+            }
+        }
+
+        mActiveInterface = interface;
+    } else {
+        ALOGV("Camera provider (%s) already in use. Re-using instance.", mProviderName.c_str());
+    }
+    return interface;
+}
+
 const std::string& CameraProviderManager::ProviderInfo::getType() const {
     return mType;
 }
 
-status_t CameraProviderManager::ProviderInfo::addDevice(
-        const std::string& name, CameraDeviceStatus initialStatus,
-        /*out*/ std::string* parsedId) {
+status_t CameraProviderManager::ProviderInfo::addDevice(const std::string& name,
+        CameraDeviceStatus initialStatus, /*out*/ std::string* parsedId) {
 
     ALOGI("Enumerating new camera device: %s", name.c_str());
 
     uint16_t major, minor;
     std::string type, id;
-    IPCTransport transport = getIPCTransport();
 
     status_t res = parseDeviceName(name, &major, &minor, &type, &id);
     if (res != OK) {
         return res;
     }
-
     if (type != mType) {
         ALOGE("%s: Device type %s does not match provider type %s", __FUNCTION__,
                 type.c_str(), mType.c_str());
         return BAD_VALUE;
     }
-    if (mManager->isValidDeviceLocked(id, major, transport)) {
+    if (mManager->isValidDeviceLocked(id, major)) {
         ALOGE("%s: Device %s: ID %s is already in use for device major version %d", __FUNCTION__,
                 name.c_str(), id.c_str(), major);
         return BAD_VALUE;
     }
 
     std::unique_ptr<DeviceInfo> deviceInfo;
-    switch (transport) {
-        case IPCTransport::HIDL:
-            switch (major) {
-                case 3:
-                    break;
-                default:
-                    ALOGE("%s: Device %s: Unsupported HIDL device HAL major version %d:",
-                          __FUNCTION__,  name.c_str(), major);
-                    return BAD_VALUE;
-            }
-            break;
-        case IPCTransport::AIDL:
-            if (major != 1) {
-                ALOGE("%s: Device %s: Unsupported AIDL device HAL major version %d:", __FUNCTION__,
-                        name.c_str(), major);
-                return BAD_VALUE;
-            }
+    switch (major) {
+        case 1:
+            ALOGE("%s: Device %s: Unsupported HIDL device HAL major version %d:", __FUNCTION__,
+                    name.c_str(), major);
+            return BAD_VALUE;
+        case 3:
+            deviceInfo = initializeDeviceInfo<DeviceInfo3>(name, mProviderTagid,
+                    id, minor);
+            deviceInfo->notifyDeviceStateChange(mDeviceState);
             break;
         default:
-            ALOGE("%s Invalid transport %d", __FUNCTION__, transport);
+            ALOGE("%s: Device %s: Unknown HIDL device HAL major version %d:", __FUNCTION__,
+                    name.c_str(), major);
             return BAD_VALUE;
     }
-
-    deviceInfo = initializeDeviceInfo(name, mProviderTagid, id, minor);
     if (deviceInfo == nullptr) return BAD_VALUE;
-    deviceInfo->notifyDeviceStateChange(getDeviceState());
     deviceInfo->mStatus = initialStatus;
     bool isAPI1Compatible = deviceInfo->isAPI1Compatible();
 
@@ -1938,50 +1666,15 @@ void CameraProviderManager::ProviderInfo::removeDevice(std::string id) {
             mUniqueCameraIds.erase(id);
             if ((*it)->isAPI1Compatible()) {
                 mUniqueAPI1CompatibleCameraIds.erase(std::remove(
-                    mUniqueAPI1CompatibleCameraIds.begin(),
-                    mUniqueAPI1CompatibleCameraIds.end(), id));
+                        mUniqueAPI1CompatibleCameraIds.begin(),
+                        mUniqueAPI1CompatibleCameraIds.end(), id));
             }
-
-            // Remove reference to camera provider to avoid pointer leak when
-            // unplugging external camera while in use with lazy HALs
-            mManager->removeRef(DeviceMode::CAMERA, id);
-            mManager->removeRef(DeviceMode::TORCH, id);
-
             mDevices.erase(it);
             break;
         }
     }
 }
 
-void CameraProviderManager::ProviderInfo::removeAllDevices() {
-    std::lock_guard<std::mutex> lock(mLock);
-
-    auto itDevices = mDevices.begin();
-    while (itDevices != mDevices.end()) {
-        std::string id = (*itDevices)->mId;
-        std::string deviceName = (*itDevices)->mName;
-        removeDevice(id);
-        // device was removed, reset iterator
-        itDevices = mDevices.begin();
-
-        //notify CameraService of status change
-        sp<StatusListener> listener = mManager->getStatusListener();
-        if (listener != nullptr) {
-            mLock.unlock();
-            ALOGV("%s: notify device not_present: %s",
-                  __FUNCTION__,
-                  deviceName.c_str());
-            listener->onDeviceStatusChanged(String8(id.c_str()),
-                                            CameraDeviceStatus::NOT_PRESENT);
-            mLock.lock();
-        }
-    }
-}
-
-bool CameraProviderManager::ProviderInfo::isExternalLazyHAL() const {
-    return kEnableLazyHal && (mProviderName == kExternalProviderName);
-}
-
 status_t CameraProviderManager::ProviderInfo::dump(int fd, const Vector<String16>&) const {
     dprintf(fd, "== Camera Provider HAL %s (v2.%d, %s) static info: %zu devices: ==\n",
             mProviderInstance.c_str(),
@@ -2056,57 +1749,117 @@ status_t CameraProviderManager::ProviderInfo::dump(int fd, const Vector<String16
     return OK;
 }
 
+status_t CameraProviderManager::ProviderInfo::getConcurrentCameraIdsInternalLocked(
+        sp<provider::V2_6::ICameraProvider> &interface2_6) {
+    if (interface2_6 == nullptr) {
+        ALOGE("%s: null interface provided", __FUNCTION__);
+        return BAD_VALUE;
+    }
+    Status status = Status::OK;
+    hardware::Return<void> ret =
+            interface2_6->getConcurrentStreamingCameraIds([&status, this](
+            Status concurrentIdStatus, // TODO: Move all instances of hidl_string to 'using'
+            const hardware::hidl_vec<hardware::hidl_vec<hardware::hidl_string>>&
+                        cameraDeviceIdCombinations) {
+            status = concurrentIdStatus;
+            if (status == Status::OK) {
+                mConcurrentCameraIdCombinations.clear();
+                for (auto& combination : cameraDeviceIdCombinations) {
+                    std::unordered_set<std::string> deviceIds;
+                    for (auto &cameraDeviceId : combination) {
+                        deviceIds.insert(cameraDeviceId.c_str());
+                    }
+                    mConcurrentCameraIdCombinations.push_back(std::move(deviceIds));
+                }
+            } });
+    if (!ret.isOk()) {
+        ALOGE("%s: Transaction error in getting concurrent camera ID list from provider '%s'",
+                __FUNCTION__, mProviderName.c_str());
+            return DEAD_OBJECT;
+    }
+    if (status != Status::OK) {
+        ALOGE("%s: Unable to query for camera devices from provider '%s'",
+                    __FUNCTION__, mProviderName.c_str());
+        return mapToStatusT(status);
+    }
+    return OK;
+}
+
+status_t CameraProviderManager::ProviderInfo::reCacheConcurrentStreamingCameraIdsLocked() {
+    if (mMinorVersion < 6) {
+      // Unsupported operation, nothing to do here
+      return OK;
+    }
+    // Check if the provider is currently active - not going to start it up for this notification
+    auto interface = mSavedInterface != nullptr ? mSavedInterface : mActiveInterface.promote();
+    if (interface == nullptr) {
+        ALOGE("%s: camera provider interface for %s is not valid", __FUNCTION__,
+                mProviderName.c_str());
+        return INVALID_OPERATION;
+    }
+    auto castResult = provider::V2_6::ICameraProvider::castFrom(interface);
+
+    if (castResult.isOk()) {
+        sp<provider::V2_6::ICameraProvider> interface2_6 = castResult;
+        if (interface2_6 != nullptr) {
+            return getConcurrentCameraIdsInternalLocked(interface2_6);
+        } else {
+            // This should not happen since mMinorVersion >= 6
+            ALOGE("%s: mMinorVersion was >= 6, but interface2_6 was nullptr", __FUNCTION__);
+            return UNKNOWN_ERROR;
+        }
+    }
+    return OK;
+}
+
 std::vector<std::unordered_set<std::string>>
 CameraProviderManager::ProviderInfo::getConcurrentCameraIdCombinations() {
     std::lock_guard<std::mutex> lock(mLock);
     return mConcurrentCameraIdCombinations;
 }
 
-void CameraProviderManager::ProviderInfo::cameraDeviceStatusChangeInternal(
-        const std::string& cameraDeviceName, CameraDeviceStatus newStatus) {
+hardware::Return<void> CameraProviderManager::ProviderInfo::cameraDeviceStatusChange(
+        const hardware::hidl_string& cameraDeviceName,
+        CameraDeviceStatus newStatus) {
     sp<StatusListener> listener;
     std::string id;
     std::lock_guard<std::mutex> lock(mInitLock);
-    CameraDeviceStatus internalNewStatus = newStatus;
+
     if (!mInitialized) {
         mCachedStatus.emplace_back(false /*isPhysicalCameraStatus*/,
-                cameraDeviceName.c_str(), std::string().c_str(),
-                internalNewStatus);
-        return;
+                cameraDeviceName.c_str(), std::string().c_str(), newStatus);
+        return hardware::Void();
     }
 
     {
         std::lock_guard<std::mutex> lock(mLock);
         if (OK != cameraDeviceStatusChangeLocked(&id, cameraDeviceName, newStatus)) {
-            return;
+            return hardware::Void();
         }
         listener = mManager->getStatusListener();
     }
 
     // Call without lock held to allow reentrancy into provider manager
     if (listener != nullptr) {
-        listener->onDeviceStatusChanged(String8(id.c_str()), internalNewStatus);
+        listener->onDeviceStatusChanged(String8(id.c_str()), newStatus);
     }
+
+    return hardware::Void();
 }
 
 status_t CameraProviderManager::ProviderInfo::cameraDeviceStatusChangeLocked(
-        std::string* id, const std::string& cameraDeviceName,
+        std::string* id, const hardware::hidl_string& cameraDeviceName,
         CameraDeviceStatus newStatus) {
     bool known = false;
     std::string cameraId;
     for (auto& deviceInfo : mDevices) {
         if (deviceInfo->mName == cameraDeviceName) {
-            Mutex::Autolock l(deviceInfo->mDeviceAvailableLock);
             ALOGI("Camera device %s status is now %s, was %s", cameraDeviceName.c_str(),
-                    FrameworkDeviceStatusToString(newStatus),
-                    FrameworkDeviceStatusToString(deviceInfo->mStatus));
+                    deviceStatusToString(newStatus), deviceStatusToString(deviceInfo->mStatus));
             deviceInfo->mStatus = newStatus;
             // TODO: Handle device removal (NOT_PRESENT)
             cameraId = deviceInfo->mId;
             known = true;
-            deviceInfo->mIsDeviceAvailable =
-                (newStatus == CameraDeviceStatus::PRESENT);
-            deviceInfo->mDeviceAvailableSignal.signal();
             break;
         }
     }
@@ -2120,13 +1873,7 @@ status_t CameraProviderManager::ProviderInfo::cameraDeviceStatusChangeLocked(
         addDevice(cameraDeviceName, newStatus, &cameraId);
     } else if (newStatus == CameraDeviceStatus::NOT_PRESENT) {
         removeDevice(cameraId);
-    } else if (isExternalLazyHAL()) {
-        // Do not notify CameraService for PRESENT->PRESENT (lazy HAL restart)
-        // because NOT_AVAILABLE is set on CameraService::connect and a PRESENT
-        // notif. would overwrite it
-        return BAD_VALUE;
     }
-
     if (reCacheConcurrentStreamingCameraIdsLocked() != OK) {
         ALOGE("%s: CameraProvider %s could not re-cache concurrent streaming camera id list ",
                   __FUNCTION__, mProviderName.c_str());
@@ -2135,18 +1882,19 @@ status_t CameraProviderManager::ProviderInfo::cameraDeviceStatusChangeLocked(
     return OK;
 }
 
-void CameraProviderManager::ProviderInfo::physicalCameraDeviceStatusChangeInternal(
-        const std::string& cameraDeviceName,
-        const std::string& physicalCameraDeviceName,
+hardware::Return<void> CameraProviderManager::ProviderInfo::physicalCameraDeviceStatusChange(
+        const hardware::hidl_string& cameraDeviceName,
+        const hardware::hidl_string& physicalCameraDeviceName,
         CameraDeviceStatus newStatus) {
     sp<StatusListener> listener;
     std::string id;
     std::string physicalId;
     std::lock_guard<std::mutex> lock(mInitLock);
+
     if (!mInitialized) {
         mCachedStatus.emplace_back(true /*isPhysicalCameraStatus*/, cameraDeviceName,
                 physicalCameraDeviceName, newStatus);
-        return;
+        return hardware::Void();
     }
 
     {
@@ -2154,7 +1902,7 @@ void CameraProviderManager::ProviderInfo::physicalCameraDeviceStatusChangeIntern
 
         if (OK != physicalCameraDeviceStatusChangeLocked(&id, &physicalId, cameraDeviceName,
                 physicalCameraDeviceName, newStatus)) {
-            return;
+            return hardware::Void();
         }
 
         listener = mManager->getStatusListener();
@@ -2164,13 +1912,13 @@ void CameraProviderManager::ProviderInfo::physicalCameraDeviceStatusChangeIntern
         listener->onDeviceStatusChanged(String8(id.c_str()),
                 String8(physicalId.c_str()), newStatus);
     }
-    return;
+    return hardware::Void();
 }
 
 status_t CameraProviderManager::ProviderInfo::physicalCameraDeviceStatusChangeLocked(
             std::string* id, std::string* physicalId,
-            const std::string& cameraDeviceName,
-            const std::string& physicalCameraDeviceName,
+            const hardware::hidl_string& cameraDeviceName,
+            const hardware::hidl_string& physicalCameraDeviceName,
             CameraDeviceStatus newStatus) {
     bool known = false;
     std::string cameraId;
@@ -2190,7 +1938,7 @@ status_t CameraProviderManager::ProviderInfo::physicalCameraDeviceStatusChangeLo
             }
             ALOGI("Camera device %s physical device %s status is now %s",
                     cameraDeviceName.c_str(), physicalCameraDeviceName.c_str(),
-                    FrameworkDeviceStatusToString(newStatus));
+                    deviceStatusToString(newStatus));
             known = true;
             break;
         }
@@ -2208,57 +1956,196 @@ status_t CameraProviderManager::ProviderInfo::physicalCameraDeviceStatusChangeLo
     return OK;
 }
 
-void CameraProviderManager::ProviderInfo::torchModeStatusChangeInternal(
-        const std::string& cameraDeviceName,
-        TorchModeStatus newStatus) {
-    sp<StatusListener> listener;
-    SystemCameraKind systemCameraKind = SystemCameraKind::PUBLIC;
-    std::string id;
-    bool known = false;
-    {
-        // Hold mLock for accessing mDevices
-        std::lock_guard<std::mutex> lock(mLock);
-        for (auto& deviceInfo : mDevices) {
-            if (deviceInfo->mName == cameraDeviceName) {
-                ALOGI("Camera device %s torch status is now %s", cameraDeviceName.c_str(),
-                        FrameworkTorchStatusToString(newStatus));
-                id = deviceInfo->mId;
-                known = true;
-                systemCameraKind = deviceInfo->mSystemCameraKind;
-                if (TorchModeStatus::AVAILABLE_ON != newStatus) {
-                    mManager->removeRef(CameraProviderManager::DeviceMode::TORCH, id);
+hardware::Return<void> CameraProviderManager::ProviderInfo::torchModeStatusChange(
+        const hardware::hidl_string& cameraDeviceName,
+        TorchModeStatus newStatus) {
+    sp<StatusListener> listener;
+    std::string id;
+    {
+        std::lock_guard<std::mutex> lock(mManager->mStatusListenerMutex);
+        bool known = false;
+        for (auto& deviceInfo : mDevices) {
+            if (deviceInfo->mName == cameraDeviceName) {
+                ALOGI("Camera device %s torch status is now %s", cameraDeviceName.c_str(),
+                        torchStatusToString(newStatus));
+                id = deviceInfo->mId;
+                known = true;
+                if (TorchModeStatus::AVAILABLE_ON != newStatus) {
+                    mManager->removeRef(DeviceMode::TORCH, id);
+                }
+                break;
+            }
+        }
+        if (!known) {
+            ALOGW("Camera provider %s says an unknown camera %s now has torch status %d. Curious.",
+                    mProviderName.c_str(), cameraDeviceName.c_str(), newStatus);
+            return hardware::Void();
+        }
+        listener = mManager->getStatusListener();
+    }
+    // Call without lock held to allow reentrancy into provider manager
+    if (listener != nullptr) {
+        listener->onTorchStatusChanged(String8(id.c_str()), newStatus);
+    }
+    return hardware::Void();
+}
+
+void CameraProviderManager::ProviderInfo::serviceDied(uint64_t cookie,
+        const wp<hidl::base::V1_0::IBase>& who) {
+    (void) who;
+    ALOGI("Camera provider '%s' has died; removing it", mProviderInstance.c_str());
+    if (cookie != mId) {
+        ALOGW("%s: Unexpected serviceDied cookie %" PRIu64 ", expected %" PRIu32,
+                __FUNCTION__, cookie, mId);
+    }
+    mManager->removeProvider(mProviderInstance);
+}
+
+status_t CameraProviderManager::ProviderInfo::setUpVendorTags() {
+    if (mVendorTagDescriptor != nullptr)
+        return OK;
+
+    hardware::hidl_vec<VendorTagSection> vts;
+    Status status;
+    hardware::Return<void> ret;
+    const sp<provider::V2_4::ICameraProvider> interface = startProviderInterface();
+    if (interface == nullptr) {
+        return DEAD_OBJECT;
+    }
+    ret = interface->getVendorTags(
+        [&](auto s, const auto& vendorTagSecs) {
+            status = s;
+            if (s == Status::OK) {
+                vts = vendorTagSecs;
+            }
+    });
+    if (!ret.isOk()) {
+        ALOGE("%s: Transaction error getting vendor tags from provider '%s': %s",
+                __FUNCTION__, mProviderName.c_str(), ret.description().c_str());
+        return DEAD_OBJECT;
+    }
+    if (status != Status::OK) {
+        return mapToStatusT(status);
+    }
+
+    // Read all vendor tag definitions into a descriptor
+    status_t res;
+    if ((res = HidlVendorTagDescriptor::createDescriptorFromHidl(vts, /*out*/mVendorTagDescriptor))
+            != OK) {
+        ALOGE("%s: Could not generate descriptor from vendor tag operations,"
+                "received error %s (%d). Camera clients will not be able to use"
+                "vendor tags", __FUNCTION__, strerror(res), res);
+        return res;
+    }
+
+    return OK;
+}
+
+void CameraProviderManager::ProviderInfo::notifyDeviceInfoStateChangeLocked(
+        hardware::hidl_bitfield<provider::V2_5::DeviceState> newDeviceState) {
+    std::lock_guard<std::mutex> lock(mLock);
+    for (auto it = mDevices.begin(); it != mDevices.end(); it++) {
+        (*it)->notifyDeviceStateChange(newDeviceState);
+    }
+}
+
+status_t CameraProviderManager::ProviderInfo::notifyDeviceStateChange(
+        hardware::hidl_bitfield<provider::V2_5::DeviceState> newDeviceState) {
+    mDeviceState = newDeviceState;
+    if (mMinorVersion >= 5) {
+        // Check if the provider is currently active - not going to start it up for this notification
+        auto interface = mSavedInterface != nullptr ? mSavedInterface : mActiveInterface.promote();
+        if (interface != nullptr) {
+            // Send current device state
+            auto castResult = provider::V2_5::ICameraProvider::castFrom(interface);
+            if (castResult.isOk()) {
+                sp<provider::V2_5::ICameraProvider> interface_2_5 = castResult;
+                if (interface_2_5 != nullptr) {
+                    interface_2_5->notifyDeviceStateChange(mDeviceState);
                 }
-                break;
             }
         }
-        if (!known) {
-            ALOGW("Camera provider %s says an unknown camera %s now has torch status %d. Curious.",
-                    mProviderName.c_str(), cameraDeviceName.c_str(), newStatus);
-            return;
-        }
-        // no lock needed since listener is set up only once during
-        // CameraProviderManager initialization and then never changed till it is
-        // destructed.
-        listener = mManager->getStatusListener();
-     }
-    // Call without lock held to allow reentrancy into provider manager
-    // The problem with holding mLock here is that we
-    // might be limiting re-entrancy : CameraService::onTorchStatusChanged calls
-    // back into CameraProviderManager which might try to hold mLock again (eg:
-    // findDeviceInfo, which should be holding mLock while iterating through
-    // each provider's devices).
-    if (listener != nullptr) {
-        listener->onTorchStatusChanged(String8(id.c_str()), newStatus, systemCameraKind);
     }
-    return;
+    return OK;
 }
 
-void CameraProviderManager::ProviderInfo::notifyDeviceInfoStateChangeLocked(
-        int64_t newDeviceState) {
-    std::lock_guard<std::mutex> lock(mLock);
-    for (auto it = mDevices.begin(); it != mDevices.end(); it++) {
-        (*it)->notifyDeviceStateChange(newDeviceState);
+status_t CameraProviderManager::ProviderInfo::isConcurrentSessionConfigurationSupported(
+        const hardware::hidl_vec<CameraIdAndStreamCombination> &halCameraIdsAndStreamCombinations,
+        bool *isSupported) {
+    status_t res = OK;
+    if (mMinorVersion >= 6) {
+        // Check if the provider is currently active - not going to start it up for this notification
+        auto interface = mSavedInterface != nullptr ? mSavedInterface : mActiveInterface.promote();
+        if (interface == nullptr) {
+            // TODO: This might be some other problem
+            return INVALID_OPERATION;
+        }
+        auto castResult2_6 = provider::V2_6::ICameraProvider::castFrom(interface);
+        auto castResult2_7 = provider::V2_7::ICameraProvider::castFrom(interface);
+        Status callStatus;
+        auto cb =
+                [&isSupported, &callStatus](Status s, bool supported) {
+                      callStatus = s;
+                      *isSupported = supported; };
+
+        ::android::hardware::Return<void> ret;
+        sp<provider::V2_7::ICameraProvider> interface_2_7;
+        sp<provider::V2_6::ICameraProvider> interface_2_6;
+        if (mMinorVersion >= 7 && castResult2_7.isOk()) {
+            interface_2_7 = castResult2_7;
+            if (interface_2_7 != nullptr) {
+                ret = interface_2_7->isConcurrentStreamCombinationSupported_2_7(
+                        halCameraIdsAndStreamCombinations, cb);
+            }
+        } else if (mMinorVersion == 6 && castResult2_6.isOk()) {
+            interface_2_6 = castResult2_6;
+            if (interface_2_6 != nullptr) {
+                hardware::hidl_vec<provider::V2_6::CameraIdAndStreamCombination>
+                        halCameraIdsAndStreamCombinations_2_6;
+                size_t numStreams = halCameraIdsAndStreamCombinations.size();
+                halCameraIdsAndStreamCombinations_2_6.resize(numStreams);
+                for (size_t i = 0; i < numStreams; i++) {
+                    using namespace camera3;
+                    auto const& combination = halCameraIdsAndStreamCombinations[i];
+                    halCameraIdsAndStreamCombinations_2_6[i].cameraId = combination.cameraId;
+                    bool success =
+                            SessionConfigurationUtils::convertHALStreamCombinationFromV37ToV34(
+                                    halCameraIdsAndStreamCombinations_2_6[i].streamConfiguration,
+                                    combination.streamConfiguration);
+                    if (!success) {
+                        *isSupported = false;
+                        return OK;
+                    }
+                }
+                ret = interface_2_6->isConcurrentStreamCombinationSupported(
+                        halCameraIdsAndStreamCombinations_2_6, cb);
+            }
+        }
+
+        if (interface_2_7 != nullptr || interface_2_6 != nullptr) {
+            if (ret.isOk()) {
+                switch (callStatus) {
+                    case Status::OK:
+                        // Expected case, do nothing.
+                        res = OK;
+                        break;
+                    case Status::METHOD_NOT_SUPPORTED:
+                        res = INVALID_OPERATION;
+                        break;
+                    default:
+                        ALOGE("%s: Session configuration query failed: %d", __FUNCTION__,
+                                  callStatus);
+                        res = UNKNOWN_ERROR;
+                }
+            } else {
+                ALOGE("%s: Unexpected binder error: %s", __FUNCTION__, ret.description().c_str());
+                res = UNKNOWN_ERROR;
+            }
+            return res;
+        }
     }
+    // unsupported operation
+    return INVALID_OPERATION;
 }
 
 void CameraProviderManager::ProviderInfo::notifyInitialStatusChange(
@@ -2275,16 +2162,290 @@ void CameraProviderManager::ProviderInfo::notifyInitialStatusChange(
     }
 }
 
+template<class DeviceInfoT>
+std::unique_ptr<CameraProviderManager::ProviderInfo::DeviceInfo>
+    CameraProviderManager::ProviderInfo::initializeDeviceInfo(
+        const std::string &name, const metadata_vendor_id_t tagId,
+        const std::string &id, uint16_t minorVersion) {
+    Status status;
+
+    auto cameraInterface =
+            startDeviceInterface<typename DeviceInfoT::InterfaceT>(name);
+    if (cameraInterface == nullptr) return nullptr;
+
+    CameraResourceCost resourceCost;
+    cameraInterface->getResourceCost([&status, &resourceCost](
+        Status s, CameraResourceCost cost) {
+                status = s;
+                resourceCost = cost;
+            });
+    if (status != Status::OK) {
+        ALOGE("%s: Unable to obtain resource costs for camera device %s: %s", __FUNCTION__,
+                name.c_str(), statusToString(status));
+        return nullptr;
+    }
+
+    for (auto& conflictName : resourceCost.conflictingDevices) {
+        uint16_t major, minor;
+        std::string type, id;
+        status_t res = parseDeviceName(conflictName, &major, &minor, &type, &id);
+        if (res != OK) {
+            ALOGE("%s: Failed to parse conflicting device %s", __FUNCTION__, conflictName.c_str());
+            return nullptr;
+        }
+        conflictName = id;
+    }
+
+    return std::unique_ptr<DeviceInfo>(
+        new DeviceInfoT(name, tagId, id, minorVersion, resourceCost, this,
+                mProviderPublicCameraIds, cameraInterface));
+}
+
+template<class InterfaceT>
+sp<InterfaceT>
+CameraProviderManager::ProviderInfo::startDeviceInterface(const std::string &name) {
+    ALOGE("%s: Device %s: Unknown HIDL device HAL major version %d:", __FUNCTION__,
+            name.c_str(), InterfaceT::version.get_major());
+    return nullptr;
+}
+
+template<>
+sp<device::V3_2::ICameraDevice>
+CameraProviderManager::ProviderInfo::startDeviceInterface
+        <device::V3_2::ICameraDevice>(const std::string &name) {
+    Status status;
+    sp<device::V3_2::ICameraDevice> cameraInterface;
+    hardware::Return<void> ret;
+    const sp<provider::V2_4::ICameraProvider> interface = startProviderInterface();
+    if (interface == nullptr) {
+        return nullptr;
+    }
+    ret = interface->getCameraDeviceInterface_V3_x(name, [&status, &cameraInterface](
+        Status s, sp<device::V3_2::ICameraDevice> interface) {
+                status = s;
+                cameraInterface = interface;
+            });
+    if (!ret.isOk()) {
+        ALOGE("%s: Transaction error trying to obtain interface for camera device %s: %s",
+                __FUNCTION__, name.c_str(), ret.description().c_str());
+        return nullptr;
+    }
+    if (status != Status::OK) {
+        ALOGE("%s: Unable to obtain interface for camera device %s: %s", __FUNCTION__,
+                name.c_str(), statusToString(status));
+        return nullptr;
+    }
+    return cameraInterface;
+}
+
+CameraProviderManager::ProviderInfo::DeviceInfo::~DeviceInfo() {}
+
+template<class InterfaceT>
+sp<InterfaceT> CameraProviderManager::ProviderInfo::DeviceInfo::startDeviceInterface() {
+    sp<InterfaceT> device;
+    ATRACE_CALL();
+    if (mSavedInterface == nullptr) {
+        sp<ProviderInfo> parentProvider = mParentProvider.promote();
+        if (parentProvider != nullptr) {
+            device = parentProvider->startDeviceInterface<InterfaceT>(mName);
+        }
+    } else {
+        device = (InterfaceT *) mSavedInterface.get();
+    }
+    return device;
+}
+
+template<class InterfaceT>
+status_t CameraProviderManager::ProviderInfo::DeviceInfo::setTorchMode(InterfaceT& interface,
+        bool enabled) {
+    Status s = interface->setTorchMode(enabled ? TorchMode::ON : TorchMode::OFF);
+    return mapToStatusT(s);
+}
+
 CameraProviderManager::ProviderInfo::DeviceInfo3::DeviceInfo3(const std::string& name,
         const metadata_vendor_id_t tagId, const std::string &id,
         uint16_t minorVersion,
         const CameraResourceCost& resourceCost,
         sp<ProviderInfo> parentProvider,
-        const std::vector<std::string>& publicCameraIds) :
+        const std::vector<std::string>& publicCameraIds,
+        sp<InterfaceT> interface) :
         DeviceInfo(name, tagId, id, hardware::hidl_version{3, minorVersion},
-                   publicCameraIds, resourceCost, parentProvider) { }
+                   publicCameraIds, resourceCost, parentProvider) {
+    // Get camera characteristics and initialize flash unit availability
+    Status status;
+    hardware::Return<void> ret;
+    ret = interface->getCameraCharacteristics([&status, this](Status s,
+                    device::V3_2::CameraMetadata metadata) {
+                status = s;
+                if (s == Status::OK) {
+                    camera_metadata_t *buffer =
+                            reinterpret_cast<camera_metadata_t*>(metadata.data());
+                    size_t expectedSize = metadata.size();
+                    int res = validate_camera_metadata_structure(buffer, &expectedSize);
+                    if (res == OK || res == CAMERA_METADATA_VALIDATION_SHIFTED) {
+                        set_camera_metadata_vendor_id(buffer, mProviderTagid);
+                        mCameraCharacteristics = buffer;
+                    } else {
+                        ALOGE("%s: Malformed camera metadata received from HAL", __FUNCTION__);
+                        status = Status::INTERNAL_ERROR;
+                    }
+                }
+            });
+    if (!ret.isOk()) {
+        ALOGE("%s: Transaction error getting camera characteristics for device %s"
+                " to check for a flash unit: %s", __FUNCTION__, id.c_str(),
+                ret.description().c_str());
+        return;
+    }
+    if (status != Status::OK) {
+        ALOGE("%s: Unable to get camera characteristics for device %s: %s (%d)",
+                __FUNCTION__, id.c_str(), CameraProviderManager::statusToString(status), status);
+        return;
+    }
+
+    if (mCameraCharacteristics.exists(ANDROID_INFO_DEVICE_STATE_ORIENTATIONS)) {
+        const auto &stateMap = mCameraCharacteristics.find(ANDROID_INFO_DEVICE_STATE_ORIENTATIONS);
+        if ((stateMap.count > 0) && ((stateMap.count % 2) == 0)) {
+            for (size_t i = 0; i < stateMap.count; i += 2) {
+                mDeviceStateOrientationMap.emplace(stateMap.data.i64[i], stateMap.data.i64[i+1]);
+            }
+        } else {
+            ALOGW("%s: Invalid ANDROID_INFO_DEVICE_STATE_ORIENTATIONS map size: %zu", __FUNCTION__,
+                    stateMap.count);
+        }
+    }
+
+    mSystemCameraKind = getSystemCameraKind();
+
+    status_t res = fixupMonochromeTags();
+    if (OK != res) {
+        ALOGE("%s: Unable to fix up monochrome tags based for older HAL version: %s (%d)",
+                __FUNCTION__, strerror(-res), res);
+        return;
+    }
+    auto stat = addDynamicDepthTags();
+    if (OK != stat) {
+        ALOGE("%s: Failed appending dynamic depth tags: %s (%d)", __FUNCTION__, strerror(-stat),
+                stat);
+    }
+    res = deriveHeicTags();
+    if (OK != res) {
+        ALOGE("%s: Unable to derive HEIC tags based on camera and media capabilities: %s (%d)",
+                __FUNCTION__, strerror(-res), res);
+    }
+
+    if (SessionConfigurationUtils::isUltraHighResolutionSensor(mCameraCharacteristics)) {
+        status_t status = addDynamicDepthTags(/*maxResolution*/true);
+        if (OK != status) {
+            ALOGE("%s: Failed appending dynamic depth tags for maximum resolution mode: %s (%d)",
+                    __FUNCTION__, strerror(-status), status);
+        }
+
+        status = deriveHeicTags(/*maxResolution*/true);
+        if (OK != status) {
+            ALOGE("%s: Unable to derive HEIC tags based on camera and media capabilities for"
+                    "maximum resolution mode: %s (%d)", __FUNCTION__, strerror(-status), status);
+        }
+    }
+
+    res = addRotateCropTags();
+    if (OK != res) {
+        ALOGE("%s: Unable to add default SCALER_ROTATE_AND_CROP tags: %s (%d)", __FUNCTION__,
+                strerror(-res), res);
+    }
+    res = addPreCorrectionActiveArraySize();
+    if (OK != res) {
+        ALOGE("%s: Unable to add PRE_CORRECTION_ACTIVE_ARRAY_SIZE: %s (%d)", __FUNCTION__,
+                strerror(-res), res);
+    }
+    res = camera3::ZoomRatioMapper::overrideZoomRatioTags(
+            &mCameraCharacteristics, &mSupportNativeZoomRatio);
+    if (OK != res) {
+        ALOGE("%s: Unable to override zoomRatio related tags: %s (%d)",
+                __FUNCTION__, strerror(-res), res);
+    }
+
+    camera_metadata_entry flashAvailable =
+            mCameraCharacteristics.find(ANDROID_FLASH_INFO_AVAILABLE);
+    if (flashAvailable.count == 1 &&
+            flashAvailable.data.u8[0] == ANDROID_FLASH_INFO_AVAILABLE_TRUE) {
+        mHasFlashUnit = true;
+    } else {
+        mHasFlashUnit = false;
+    }
+
+    queryPhysicalCameraIds();
+
+    // Get physical camera characteristics if applicable
+    auto castResult = device::V3_5::ICameraDevice::castFrom(interface);
+    if (!castResult.isOk()) {
+        ALOGV("%s: Unable to convert ICameraDevice instance to version 3.5", __FUNCTION__);
+        return;
+    }
+    sp<device::V3_5::ICameraDevice> interface_3_5 = castResult;
+    if (interface_3_5 == nullptr) {
+        ALOGE("%s: Converted ICameraDevice instance to nullptr", __FUNCTION__);
+        return;
+    }
+
+    if (mIsLogicalCamera) {
+        for (auto& id : mPhysicalIds) {
+            if (std::find(mPublicCameraIds.begin(), mPublicCameraIds.end(), id) !=
+                    mPublicCameraIds.end()) {
+                continue;
+            }
+
+            hardware::hidl_string hidlId(id);
+            ret = interface_3_5->getPhysicalCameraCharacteristics(hidlId,
+                    [&status, &id, this](Status s, device::V3_2::CameraMetadata metadata) {
+                status = s;
+                if (s == Status::OK) {
+                    camera_metadata_t *buffer =
+                            reinterpret_cast<camera_metadata_t*>(metadata.data());
+                    size_t expectedSize = metadata.size();
+                    int res = validate_camera_metadata_structure(buffer, &expectedSize);
+                    if (res == OK || res == CAMERA_METADATA_VALIDATION_SHIFTED) {
+                        set_camera_metadata_vendor_id(buffer, mProviderTagid);
+                        mPhysicalCameraCharacteristics[id] = buffer;
+                    } else {
+                        ALOGE("%s: Malformed camera metadata received from HAL", __FUNCTION__);
+                        status = Status::INTERNAL_ERROR;
+                    }
+                }
+            });
+
+            if (!ret.isOk()) {
+                ALOGE("%s: Transaction error getting physical camera %s characteristics for %s: %s",
+                        __FUNCTION__, id.c_str(), id.c_str(), ret.description().c_str());
+                return;
+            }
+            if (status != Status::OK) {
+                ALOGE("%s: Unable to get physical camera %s characteristics for device %s: %s (%d)",
+                        __FUNCTION__, id.c_str(), mId.c_str(),
+                        CameraProviderManager::statusToString(status), status);
+                return;
+            }
+
+            res = camera3::ZoomRatioMapper::overrideZoomRatioTags(
+                    &mPhysicalCameraCharacteristics[id], &mSupportNativeZoomRatio);
+            if (OK != res) {
+                ALOGE("%s: Unable to override zoomRatio related tags: %s (%d)",
+                        __FUNCTION__, strerror(-res), res);
+            }
+        }
+    }
+
+    if (!kEnableLazyHal) {
+        // Save HAL reference indefinitely
+        mSavedInterface = interface;
+    }
+}
+
+CameraProviderManager::ProviderInfo::DeviceInfo3::~DeviceInfo3() {}
+
+void CameraProviderManager::ProviderInfo::DeviceInfo3::notifyDeviceStateChange(
+        hardware::hidl_bitfield<hardware::camera::provider::V2_5::DeviceState> newState) {
 
-void CameraProviderManager::ProviderInfo::DeviceInfo3::notifyDeviceStateChange(int64_t newState) {
     if (!mDeviceStateOrientationMap.empty() &&
             (mDeviceStateOrientationMap.find(newState) != mDeviceStateOrientationMap.end())) {
         mCameraCharacteristics.update(ANDROID_SENSOR_ORIENTATION,
@@ -2292,6 +2453,10 @@ void CameraProviderManager::ProviderInfo::DeviceInfo3::notifyDeviceStateChange(i
     }
 }
 
+status_t CameraProviderManager::ProviderInfo::DeviceInfo3::setTorchMode(bool enabled) {
+    return setTorchModeForDevice<InterfaceT>(enabled);
+}
+
 status_t CameraProviderManager::ProviderInfo::DeviceInfo3::getCameraInfo(
         hardware::CameraInfo *info) const {
     if (info == nullptr) return BAD_VALUE;
@@ -2347,6 +2512,21 @@ bool CameraProviderManager::ProviderInfo::DeviceInfo3::isAPI1Compatible() const
     return isBackwardCompatible;
 }
 
+status_t CameraProviderManager::ProviderInfo::DeviceInfo3::dumpState(int fd) {
+    native_handle_t* handle = native_handle_create(1,0);
+    handle->data[0] = fd;
+    const sp<InterfaceT> interface = startDeviceInterface<InterfaceT>();
+    if (interface == nullptr) {
+        return DEAD_OBJECT;
+    }
+    auto ret = interface->dumpState(handle);
+    native_handle_delete(handle);
+    if (!ret.isOk()) {
+        return INVALID_OPERATION;
+    }
+    return OK;
+}
+
 status_t CameraProviderManager::ProviderInfo::DeviceInfo3::getCameraCharacteristics(
         bool overrideForPerfClass, CameraMetadata *characteristics) const {
     if (characteristics == nullptr) return BAD_VALUE;
@@ -2372,6 +2552,63 @@ status_t CameraProviderManager::ProviderInfo::DeviceInfo3::getPhysicalCameraChar
     return OK;
 }
 
+status_t CameraProviderManager::ProviderInfo::DeviceInfo3::isSessionConfigurationSupported(
+        const hardware::camera::device::V3_7::StreamConfiguration &configuration,
+        bool *status /*out*/) {
+
+    const sp<CameraProviderManager::ProviderInfo::DeviceInfo3::InterfaceT> interface =
+            this->startDeviceInterface<CameraProviderManager::ProviderInfo::DeviceInfo3::InterfaceT>();
+    if (interface == nullptr) {
+        return DEAD_OBJECT;
+    }
+    auto castResult_3_5 = device::V3_5::ICameraDevice::castFrom(interface);
+    sp<hardware::camera::device::V3_5::ICameraDevice> interface_3_5 = castResult_3_5;
+    auto castResult_3_7 = device::V3_7::ICameraDevice::castFrom(interface);
+    sp<hardware::camera::device::V3_7::ICameraDevice> interface_3_7 = castResult_3_7;
+
+    status_t res;
+    Status callStatus;
+    ::android::hardware::Return<void> ret;
+    auto halCb =
+            [&callStatus, &status] (Status s, bool combStatus) {
+                callStatus = s;
+                *status = combStatus;
+            };
+    if (interface_3_7 != nullptr) {
+        ret = interface_3_7->isStreamCombinationSupported_3_7(configuration, halCb);
+    } else if (interface_3_5 != nullptr) {
+        hardware::camera::device::V3_4::StreamConfiguration configuration_3_4;
+        bool success = SessionConfigurationUtils::convertHALStreamCombinationFromV37ToV34(
+                configuration_3_4, configuration);
+        if (!success) {
+            *status = false;
+            return OK;
+        }
+        ret = interface_3_5->isStreamCombinationSupported(configuration_3_4, halCb);
+    } else {
+        return INVALID_OPERATION;
+    }
+    if (ret.isOk()) {
+        switch (callStatus) {
+            case Status::OK:
+                // Expected case, do nothing.
+                res = OK;
+                break;
+            case Status::METHOD_NOT_SUPPORTED:
+                res = INVALID_OPERATION;
+                break;
+            default:
+                ALOGE("%s: Session configuration query failed: %d", __FUNCTION__, callStatus);
+                res = UNKNOWN_ERROR;
+        }
+    } else {
+        ALOGE("%s: Unexpected binder error: %s", __FUNCTION__, ret.description().c_str());
+        res = UNKNOWN_ERROR;
+    }
+
+    return res;
+}
+
 status_t CameraProviderManager::ProviderInfo::DeviceInfo3::filterSmallJpegSizes() {
     int32_t thresholdW = SessionConfigurationUtils::PERF_CLASS_JPEG_THRESH_W;
     int32_t thresholdH = SessionConfigurationUtils::PERF_CLASS_JPEG_THRESH_H;
@@ -2623,6 +2860,8 @@ status_t CameraProviderManager::ProviderInfo::parseDeviceName(const std::string&
     return OK;
 }
 
+
+
 CameraProviderManager::ProviderInfo::~ProviderInfo() {
     if (mInitialStatusCallbackFuture.valid()) {
         mInitialStatusCallbackFuture.wait();
@@ -2631,6 +2870,167 @@ CameraProviderManager::ProviderInfo::~ProviderInfo() {
     // CameraProvider interface dies, so do not unregister callbacks.
 }
 
+status_t CameraProviderManager::mapToStatusT(const Status& s)  {
+    switch(s) {
+        case Status::OK:
+            return OK;
+        case Status::ILLEGAL_ARGUMENT:
+            return BAD_VALUE;
+        case Status::CAMERA_IN_USE:
+            return -EBUSY;
+        case Status::MAX_CAMERAS_IN_USE:
+            return -EUSERS;
+        case Status::METHOD_NOT_SUPPORTED:
+            return UNKNOWN_TRANSACTION;
+        case Status::OPERATION_NOT_SUPPORTED:
+            return INVALID_OPERATION;
+        case Status::CAMERA_DISCONNECTED:
+            return DEAD_OBJECT;
+        case Status::INTERNAL_ERROR:
+            return INVALID_OPERATION;
+    }
+    ALOGW("Unexpected HAL status code %d", s);
+    return INVALID_OPERATION;
+}
+
+const char* CameraProviderManager::statusToString(const Status& s) {
+    switch(s) {
+        case Status::OK:
+            return "OK";
+        case Status::ILLEGAL_ARGUMENT:
+            return "ILLEGAL_ARGUMENT";
+        case Status::CAMERA_IN_USE:
+            return "CAMERA_IN_USE";
+        case Status::MAX_CAMERAS_IN_USE:
+            return "MAX_CAMERAS_IN_USE";
+        case Status::METHOD_NOT_SUPPORTED:
+            return "METHOD_NOT_SUPPORTED";
+        case Status::OPERATION_NOT_SUPPORTED:
+            return "OPERATION_NOT_SUPPORTED";
+        case Status::CAMERA_DISCONNECTED:
+            return "CAMERA_DISCONNECTED";
+        case Status::INTERNAL_ERROR:
+            return "INTERNAL_ERROR";
+    }
+    ALOGW("Unexpected HAL status code %d", s);
+    return "UNKNOWN_ERROR";
+}
+
+const char* CameraProviderManager::deviceStatusToString(const CameraDeviceStatus& s) {
+    switch(s) {
+        case CameraDeviceStatus::NOT_PRESENT:
+            return "NOT_PRESENT";
+        case CameraDeviceStatus::PRESENT:
+            return "PRESENT";
+        case CameraDeviceStatus::ENUMERATING:
+            return "ENUMERATING";
+    }
+    ALOGW("Unexpected HAL device status code %d", s);
+    return "UNKNOWN_STATUS";
+}
+
+const char* CameraProviderManager::torchStatusToString(const TorchModeStatus& s) {
+    switch(s) {
+        case TorchModeStatus::NOT_AVAILABLE:
+            return "NOT_AVAILABLE";
+        case TorchModeStatus::AVAILABLE_OFF:
+            return "AVAILABLE_OFF";
+        case TorchModeStatus::AVAILABLE_ON:
+            return "AVAILABLE_ON";
+    }
+    ALOGW("Unexpected HAL torch mode status code %d", s);
+    return "UNKNOWN_STATUS";
+}
+
+
+status_t HidlVendorTagDescriptor::createDescriptorFromHidl(
+        const hardware::hidl_vec<common::V1_0::VendorTagSection>& vts,
+        /*out*/
+        sp<VendorTagDescriptor>& descriptor) {
+
+    int tagCount = 0;
+
+    for (size_t s = 0; s < vts.size(); s++) {
+        tagCount += vts[s].tags.size();
+    }
+
+    if (tagCount < 0 || tagCount > INT32_MAX) {
+        ALOGE("%s: tag count %d from vendor tag sections is invalid.", __FUNCTION__, tagCount);
+        return BAD_VALUE;
+    }
+
+    Vector<uint32_t> tagArray;
+    LOG_ALWAYS_FATAL_IF(tagArray.resize(tagCount) != tagCount,
+            "%s: too many (%u) vendor tags defined.", __FUNCTION__, tagCount);
+
+
+    sp<HidlVendorTagDescriptor> desc = new HidlVendorTagDescriptor();
+    desc->mTagCount = tagCount;
+
+    SortedVector<String8> sections;
+    KeyedVector<uint32_t, String8> tagToSectionMap;
+
+    int idx = 0;
+    for (size_t s = 0; s < vts.size(); s++) {
+        const common::V1_0::VendorTagSection& section = vts[s];
+        const char *sectionName = section.sectionName.c_str();
+        if (sectionName == NULL) {
+            ALOGE("%s: no section name defined for vendor tag section %zu.", __FUNCTION__, s);
+            return BAD_VALUE;
+        }
+        String8 sectionString(sectionName);
+        sections.add(sectionString);
+
+        for (size_t j = 0; j < section.tags.size(); j++) {
+            uint32_t tag = section.tags[j].tagId;
+            if (tag < CAMERA_METADATA_VENDOR_TAG_BOUNDARY) {
+                ALOGE("%s: vendor tag %d not in vendor tag section.", __FUNCTION__, tag);
+                return BAD_VALUE;
+            }
+
+            tagArray.editItemAt(idx++) = section.tags[j].tagId;
+
+            const char *tagName = section.tags[j].tagName.c_str();
+            if (tagName == NULL) {
+                ALOGE("%s: no tag name defined for vendor tag %d.", __FUNCTION__, tag);
+                return BAD_VALUE;
+            }
+            desc->mTagToNameMap.add(tag, String8(tagName));
+            tagToSectionMap.add(tag, sectionString);
+
+            int tagType = (int) section.tags[j].tagType;
+            if (tagType < 0 || tagType >= NUM_TYPES) {
+                ALOGE("%s: tag type %d from vendor ops does not exist.", __FUNCTION__, tagType);
+                return BAD_VALUE;
+            }
+            desc->mTagToTypeMap.add(tag, tagType);
+        }
+    }
+
+    desc->mSections = sections;
+
+    for (size_t i = 0; i < tagArray.size(); ++i) {
+        uint32_t tag = tagArray[i];
+        String8 sectionString = tagToSectionMap.valueFor(tag);
+
+        // Set up tag to section index map
+        ssize_t index = sections.indexOf(sectionString);
+        LOG_ALWAYS_FATAL_IF(index < 0, "index %zd must be non-negative", index);
+        desc->mTagToSectionMap.add(tag, static_cast<uint32_t>(index));
+
+        // Set up reverse mapping
+        ssize_t reverseIndex = -1;
+        if ((reverseIndex = desc->mReverseMapping.indexOfKey(sectionString)) < 0) {
+            KeyedVector<String8, uint32_t>* nameMapper = new KeyedVector<String8, uint32_t>();
+            reverseIndex = desc->mReverseMapping.add(sectionString, nameMapper);
+        }
+        desc->mReverseMapping[reverseIndex]->add(desc->mTagToNameMap.valueFor(tag), tag);
+    }
+
+    descriptor = std::move(desc);
+    return OK;
+}
+
 // Expects to have mInterfaceMutex locked
 std::vector<std::unordered_set<std::string>>
 CameraProviderManager::getConcurrentCameraIds() const {
@@ -2644,6 +3044,59 @@ CameraProviderManager::getConcurrentCameraIds() const {
     return deviceIdCombinations;
 }
 
+status_t CameraProviderManager::convertToHALStreamCombinationAndCameraIdsLocked(
+        const std::vector<CameraIdAndSessionConfiguration> &cameraIdsAndSessionConfigs,
+        const std::set<std::string>& perfClassPrimaryCameraIds,
+        int targetSdkVersion,
+        hardware::hidl_vec<CameraIdAndStreamCombination> *halCameraIdsAndStreamCombinations,
+        bool *earlyExit) {
+    binder::Status bStatus = binder::Status::ok();
+    std::vector<CameraIdAndStreamCombination> halCameraIdsAndStreamsV;
+    bool shouldExit = false;
+    status_t res = OK;
+    for (auto &cameraIdAndSessionConfig : cameraIdsAndSessionConfigs) {
+        const std::string& cameraId = cameraIdAndSessionConfig.mCameraId;
+        hardware::camera::device::V3_7::StreamConfiguration streamConfiguration;
+        CameraMetadata deviceInfo;
+        bool overrideForPerfClass =
+                SessionConfigurationUtils::targetPerfClassPrimaryCamera(
+                        perfClassPrimaryCameraIds, cameraId, targetSdkVersion);
+        res = getCameraCharacteristicsLocked(cameraId, overrideForPerfClass, &deviceInfo);
+        if (res != OK) {
+            return res;
+        }
+        camera3::metadataGetter getMetadata =
+                [this](const String8 &id, bool overrideForPerfClass) {
+                    CameraMetadata physicalDeviceInfo;
+                    getCameraCharacteristicsLocked(id.string(), overrideForPerfClass,
+                                                   &physicalDeviceInfo);
+                    return physicalDeviceInfo;
+                };
+        std::vector<std::string> physicalCameraIds;
+        isLogicalCameraLocked(cameraId, &physicalCameraIds);
+        bStatus =
+            SessionConfigurationUtils::convertToHALStreamCombination(
+                    cameraIdAndSessionConfig.mSessionConfiguration,
+                    String8(cameraId.c_str()), deviceInfo, getMetadata,
+                    physicalCameraIds, streamConfiguration,
+                    overrideForPerfClass, &shouldExit);
+        if (!bStatus.isOk()) {
+            ALOGE("%s: convertToHALStreamCombination failed", __FUNCTION__);
+            return INVALID_OPERATION;
+        }
+        if (shouldExit) {
+            *earlyExit = true;
+            return OK;
+        }
+        CameraIdAndStreamCombination halCameraIdAndStream;
+        halCameraIdAndStream.cameraId = cameraId;
+        halCameraIdAndStream.streamConfiguration = streamConfiguration;
+        halCameraIdsAndStreamsV.push_back(halCameraIdAndStream);
+    }
+    *halCameraIdsAndStreamCombinations = halCameraIdsAndStreamsV;
+    return OK;
+}
+
 // Checks if the containing vector of sets has any set that contains all of the
 // camera ids in cameraIdsAndSessionConfigs.
 static bool checkIfSetContainsAll(
@@ -2678,9 +3131,27 @@ status_t CameraProviderManager::isConcurrentSessionConfigurationSupported(
     for (auto &provider : mProviders) {
         if (checkIfSetContainsAll(cameraIdsAndSessionConfigs,
                 provider->getConcurrentCameraIdCombinations())) {
+            // For each camera device in cameraIdsAndSessionConfigs collect
+            // the streamConfigs and create the HAL
+            // CameraIdAndStreamCombination, exit early if needed
+            hardware::hidl_vec<CameraIdAndStreamCombination> halCameraIdsAndStreamCombinations;
+            bool knowUnsupported = false;
+            status_t res = convertToHALStreamCombinationAndCameraIdsLocked(
+                    cameraIdsAndSessionConfigs, perfClassPrimaryCameraIds,
+                    targetSdkVersion, &halCameraIdsAndStreamCombinations, &knowUnsupported);
+            if (res != OK) {
+                ALOGE("%s unable to convert session configurations provided to HAL stream"
+                      "combinations", __FUNCTION__);
+                return res;
+            }
+            if (knowUnsupported) {
+                // We got to know the streams aren't valid before doing the HAL
+                // call itself.
+                *isSupported = false;
+                return OK;
+            }
             return provider->isConcurrentSessionConfigurationSupported(
-                    cameraIdsAndSessionConfigs, perfClassPrimaryCameraIds, targetSdkVersion,
-                    isSupported);
+                    halCameraIdsAndStreamCombinations, isSupported);
         }
     }
     *isSupported = false;
@@ -2690,7 +3161,7 @@ status_t CameraProviderManager::isConcurrentSessionConfigurationSupported(
 
 status_t CameraProviderManager::getCameraCharacteristicsLocked(const std::string &id,
         bool overrideForPerfClass, CameraMetadata* characteristics) const {
-    auto deviceInfo = findDeviceInfoLocked(id);
+    auto deviceInfo = findDeviceInfoLocked(id, /*minVersion*/ {3,0}, /*maxVersion*/ {5,0});
     if (deviceInfo != nullptr) {
         return deviceInfo->getCameraCharacteristics(overrideForPerfClass, characteristics);
     }
diff --git a/services/camera/libcameraservice/common/CameraProviderManager.h b/services/camera/libcameraservice/common/CameraProviderManager.h
index a66598d9b2..8a1652b4b6 100644
--- a/services/camera/libcameraservice/common/CameraProviderManager.h
+++ b/services/camera/libcameraservice/common/CameraProviderManager.h
@@ -29,12 +29,7 @@
 #include <camera/CameraParameters2.h>
 #include <camera/CameraMetadata.h>
 #include <camera/CameraBase.h>
-#include <utils/Condition.h>
 #include <utils/Errors.h>
-#include <android/hardware/ICameraService.h>
-#include <utils/IPCTransport.h>
-#include <utils/SessionConfigurationUtils.h>
-#include <aidl/android/hardware/camera/provider/ICameraProvider.h>
 #include <android/hardware/camera/common/1.0/types.h>
 #include <android/hardware/camera/provider/2.5/ICameraProvider.h>
 #include <android/hardware/camera/provider/2.6/ICameraProviderCallback.h>
@@ -42,28 +37,26 @@
 #include <android/hardware/camera/provider/2.7/ICameraProvider.h>
 #include <android/hardware/camera/device/3.7/types.h>
 #include <android/hidl/manager/1.0/IServiceNotification.h>
-#include <binder/IServiceManager.h>
 #include <camera/VendorTagDescriptor.h>
 
 namespace android {
-
-using hardware::camera2::utils::CameraIdAndSessionConfiguration;
-
-enum class CameraDeviceStatus : uint32_t {
-  NOT_PRESENT = 0,
-  PRESENT = 1,
-  ENUMERATING = 2
-};
-
-enum class TorchModeStatus : uint32_t {
-  NOT_AVAILABLE = 0,
-  AVAILABLE_OFF = 1,
-  AVAILABLE_ON = 2
-};
-
-struct CameraResourceCost {
-  uint32_t resourceCost;
-  std::vector<std::string> conflictingDevices;
+/**
+ * The vendor tag descriptor class that takes HIDL vendor tag information as
+ * input. Not part of VendorTagDescriptor class because that class is used
+ * in AIDL generated sources which don't have access to HIDL headers.
+ */
+class HidlVendorTagDescriptor : public VendorTagDescriptor {
+public:
+    /**
+     * Create a VendorTagDescriptor object from the HIDL VendorTagSection
+     * vector.
+     *
+     * Returns OK on success, or a negative error code.
+     */
+    static status_t createDescriptorFromHidl(
+            const hardware::hidl_vec<hardware::camera::common::V1_0::VendorTagSection>& vts,
+            /*out*/
+            sp<VendorTagDescriptor>& descriptor);
 };
 
 enum SystemCameraKind {
@@ -96,26 +89,6 @@ enum SystemCameraKind {
 #define CAMERA_DEVICE_API_VERSION_3_6 HARDWARE_DEVICE_API_VERSION(3, 6)
 #define CAMERA_DEVICE_API_VERSION_3_7 HARDWARE_DEVICE_API_VERSION(3, 7)
 
-/**
- * The vendor tag descriptor class that takes HIDL/AIDL vendor tag information as
- * input. Not part of VendorTagDescriptor class because that class is used
- * in AIDL generated sources which don't have access to AIDL / HIDL headers.
- */
-class IdlVendorTagDescriptor : public VendorTagDescriptor {
-public:
-    /**
-     * Create a VendorTagDescriptor object from the HIDL/AIDL VendorTagSection
-     * vector.
-     *
-     * Returns OK on success, or a negative error code.
-     */
-    template <class VendorTagSectionVectorType, class VendorTagSectionType>
-    static status_t createDescriptorFromIdl(
-            const VendorTagSectionVectorType& vts,
-            /*out*/
-            sp<VendorTagDescriptor>& descriptor);
-};
-
 /**
  * A manager for all camera providers available on an Android device.
  *
@@ -126,18 +99,14 @@ public:
  * opening them for active use.
  *
  */
-class CameraProviderManager : virtual public hidl::manager::V1_0::IServiceNotification,
-        public virtual IServiceManager::LocalRegistrationCallback {
+class CameraProviderManager : virtual public hidl::manager::V1_0::IServiceNotification {
 public:
-    // needs to be made friend strict since HidlProviderInfo needs to inherit
-    // from CameraProviderManager::ProviderInfo which isn't a public member.
-    friend struct HidlProviderInfo;
-    friend struct AidlProviderInfo;
+
     ~CameraProviderManager();
 
     // Tiny proxy for the static methods in a HIDL interface that communicate with the hardware
     // service manager, to be replacable in unit tests with a fake.
-    struct HidlServiceInteractionProxy {
+    struct ServiceInteractionProxy {
         virtual bool registerForNotifications(
                 const std::string &serviceName,
                 const sp<hidl::manager::V1_0::IServiceNotification>
@@ -149,12 +118,12 @@ public:
         virtual sp<hardware::camera::provider::V2_4::ICameraProvider> getService(
                 const std::string &serviceName) = 0;
         virtual hardware::hidl_vec<hardware::hidl_string> listServices() = 0;
-        virtual ~HidlServiceInteractionProxy() {}
+        virtual ~ServiceInteractionProxy() {}
     };
 
     // Standard use case - call into the normal generated static methods which invoke
     // the real hardware service manager
-    struct HidlServiceInteractionProxyImpl : public HidlServiceInteractionProxy {
+    struct HardwareServiceInteractionProxy : public ServiceInteractionProxy {
         virtual bool registerForNotifications(
                 const std::string &serviceName,
                 const sp<hidl::manager::V1_0::IServiceNotification>
@@ -181,15 +150,12 @@ public:
         ~StatusListener() {}
 
         virtual void onDeviceStatusChanged(const String8 &cameraId,
-                CameraDeviceStatus newStatus) = 0;
+                hardware::camera::common::V1_0::CameraDeviceStatus newStatus) = 0;
         virtual void onDeviceStatusChanged(const String8 &cameraId,
                 const String8 &physicalCameraId,
-                CameraDeviceStatus newStatus) = 0;
+                hardware::camera::common::V1_0::CameraDeviceStatus newStatus) = 0;
         virtual void onTorchStatusChanged(const String8 &cameraId,
-                TorchModeStatus newStatus,
-                SystemCameraKind kind) = 0;
-        virtual void onTorchStatusChanged(const String8 &cameraId,
-                TorchModeStatus newStatus) = 0;
+                hardware::camera::common::V1_0::TorchModeStatus newStatus) = 0;
         virtual void onNewProviderRegistered() = 0;
     };
 
@@ -209,10 +175,7 @@ public:
      * used for testing. The lifetime of the proxy must exceed the lifetime of the manager.
      */
     status_t initialize(wp<StatusListener> listener,
-            HidlServiceInteractionProxy *hidlProxy = &sHidlServiceInteractionProxy);
-
-    status_t getCameraIdIPCTransport(const std::string &id,
-            IPCTransport *providerTransport) const;
+            ServiceInteractionProxy *proxy = &sHardwareServiceInteractionProxy);
 
     /**
      * Retrieve the total number of available cameras.
@@ -230,6 +193,11 @@ public:
      */
     std::vector<std::string> getAPI1CompatibleCameraDeviceIds() const;
 
+    /**
+     * Return true if a device with a given ID and major version exists
+     */
+    bool isValidDevice(const std::string &id, uint16_t majorVersion) const;
+
     /**
      * Return true if a device with a given ID has a flash unit. Returns false
      * for devices that are unknown.
@@ -245,7 +213,7 @@ public:
      * Return the resource cost of this camera device
      */
     status_t getResourceCost(const std::string &id,
-            CameraResourceCost* cost) const;
+            hardware::camera::common::V1_0::CameraResourceCost* cost) const;
 
     /**
      * Return the old camera API camera info
@@ -271,32 +239,20 @@ public:
      * Check for device support of specific stream combination.
      */
     status_t isSessionConfigurationSupported(const std::string& id,
-            const SessionConfiguration &configuration,
-            bool overrideForPerfClass, camera3::metadataGetter getMetadata,
+            const hardware::camera::device::V3_7::StreamConfiguration &configuration,
             bool *status /*out*/) const;
 
     /**
      * Return the highest supported device interface version for this ID
      */
     status_t getHighestSupportedVersion(const std::string &id,
-            hardware::hidl_version *v, IPCTransport *transport);
+            hardware::hidl_version *v);
 
     /**
      * Check if a given camera device support setTorchMode API.
      */
     bool supportSetTorchMode(const std::string &id) const;
 
-    /**
-     * Check if torch strength update should be skipped or not.
-     */
-    bool shouldSkipTorchStrengthUpdate(const std::string &id, int32_t torchStrength) const;
-
-    /**
-     * Return the default torch strength level if the torch strength control
-     * feature is supported.
-     */
-    int32_t getTorchDefaultStrengthLevel(const std::string &id) const;
-
     /**
      * Turn on or off the flashlight on a given camera device.
      * May fail if the device does not support this API, is in active use, or if the device
@@ -304,24 +260,6 @@ public:
      */
     status_t setTorchMode(const std::string &id, bool enabled);
 
-    /**
-     * Change the brightness level of the flash unit associated with the cameraId and
-     * set it to the value in torchStrength.
-     * If the torch is OFF and torchStrength > 0, the torch will be turned ON with the
-     * specified strength level. If the torch is ON, only the brightness level will be
-     * changed.
-     *
-     * This operation will fail if the device does not have flash unit, has flash unit
-     * but does not support this API, torchStrength is invalid or if the device doesn't
-     * exist etc.
-     */
-    status_t turnOnTorchWithStrengthLevel(const std::string &id, int32_t torchStrength);
-
-    /**
-     * Return the torch strength level of this camera device.
-     */
-    status_t getTorchStrengthLevel(const std::string &id, int32_t* torchStrength);
-
     /**
      * Setup vendor tags for all registered providers
      */
@@ -330,19 +268,8 @@ public:
     /**
      * Inform registered providers about a device state change, such as folding or unfolding
      */
-    status_t notifyDeviceStateChange(int64_t newState);
-
-    status_t openAidlSession(const std::string &id,
-        const std::shared_ptr<
-                aidl::android::hardware::camera::device::ICameraDeviceCallback>& callback,
-        /*out*/
-        std::shared_ptr<aidl::android::hardware::camera::device::ICameraDeviceSession> *session);
-
-    status_t openAidlInjectionSession(const std::string &id,
-        const std::shared_ptr<
-                aidl::android::hardware::camera::device::ICameraDeviceCallback>& callback,
-        /*out*/
-        std::shared_ptr<aidl::android::hardware::camera::device::ICameraInjectionSession> *session);
+    status_t notifyDeviceStateChange(
+        android::hardware::hidl_bitfield<hardware::camera::provider::V2_5::DeviceState> newState);
 
     /**
      * Open an active session to a camera device.
@@ -350,7 +277,7 @@ public:
      * This fully powers on the camera device hardware, and returns a handle to a
      * session to be used for hardware configuration and operation.
      */
-    status_t openHidlSession(const std::string &id,
+    status_t openSession(const std::string &id,
             const sp<hardware::camera::device::V3_2::ICameraDeviceCallback>& callback,
             /*out*/
             sp<hardware::camera::device::V3_2::ICameraDeviceSession> *session);
@@ -368,9 +295,6 @@ public:
             const hardware::hidl_string& name,
             bool preexisting) override;
 
-    // LocalRegistrationCallback::onServiceRegistration
-    virtual void onServiceRegistration(const String16& name, const sp<IBinder> &binder) override;
-
     /**
      * Dump out information about available providers and devices
      */
@@ -385,7 +309,9 @@ public:
     /*
      * Return provider type for a specific device.
      */
-    metadata_vendor_id_t getProviderTagIdLocked(const std::string& id) const;
+    metadata_vendor_id_t getProviderTagIdLocked(const std::string& id,
+            hardware::hidl_version minVersion = hardware::hidl_version{0,0},
+            hardware::hidl_version maxVersion = hardware::hidl_version{1000,0}) const;
 
     /*
      * Check if a camera is a logical camera. And if yes, return
@@ -398,91 +324,106 @@ public:
 
     status_t filterSmallJpegSizes(const std::string& cameraId);
 
-    status_t notifyUsbDeviceEvent(int32_t eventId, const std::string &usbDeviceId);
-
     static const float kDepthARTolerance;
 private:
     // All private members, unless otherwise noted, expect mInterfaceMutex to be locked before use
     mutable std::mutex mInterfaceMutex;
 
+    // the status listener update callbacks will lock mStatusMutex
+    mutable std::mutex mStatusListenerMutex;
     wp<StatusListener> mListener;
-    HidlServiceInteractionProxy* mHidlServiceProxy;
+    ServiceInteractionProxy* mServiceProxy;
 
     // Current overall Android device physical status
-    int64_t mDeviceState;
+    android::hardware::hidl_bitfield<hardware::camera::provider::V2_5::DeviceState> mDeviceState;
 
     // mProviderLifecycleLock is locked during onRegistration and removeProvider
     mutable std::mutex mProviderLifecycleLock;
 
-    static HidlServiceInteractionProxyImpl sHidlServiceInteractionProxy;
-
-    struct HalCameraProvider {
-      // Empty parent struct for storing either aidl / hidl camera provider reference
-      HalCameraProvider(const char *descriptor) : mDescriptor(descriptor) { };
-      virtual ~HalCameraProvider() {};
-      std::string mDescriptor;
-    };
-
-    struct HidlHalCameraProvider : public HalCameraProvider {
-        HidlHalCameraProvider(
-                const sp<hardware::camera::provider::V2_4::ICameraProvider> &provider,
-                const char *descriptor) :
-                HalCameraProvider(descriptor), mCameraProvider(provider) { };
-     private:
-        sp<hardware::camera::provider::V2_4::ICameraProvider> mCameraProvider;
-    };
-
-    struct AidlHalCameraProvider : public HalCameraProvider {
-        AidlHalCameraProvider(
-                const std::shared_ptr<
-                        aidl::android::hardware::camera::provider::ICameraProvider> &provider,
-                const char *descriptor) :
-                HalCameraProvider(descriptor), mCameraProvider(provider) { };
-     private:
-        std::shared_ptr<aidl::android::hardware::camera::provider::ICameraProvider> mCameraProvider;
-    };
-
+    static HardwareServiceInteractionProxy sHardwareServiceInteractionProxy;
 
     // Mapping from CameraDevice IDs to CameraProviders. This map is used to keep the
     // ICameraProvider alive while it is in use by the camera with the given ID for camera
     // capabilities
-    std::unordered_map<std::string, std::shared_ptr<HalCameraProvider>>
+    std::unordered_map<std::string, sp<hardware::camera::provider::V2_4::ICameraProvider>>
             mCameraProviderByCameraId;
 
     // Mapping from CameraDevice IDs to CameraProviders. This map is used to keep the
     // ICameraProvider alive while it is in use by the camera with the given ID for torch
     // capabilities
-    std::unordered_map<std::string, std::shared_ptr<HalCameraProvider>>
+    std::unordered_map<std::string, sp<hardware::camera::provider::V2_4::ICameraProvider>>
             mTorchProviderByCameraId;
 
     // Lock for accessing mCameraProviderByCameraId and mTorchProviderByCameraId
     std::mutex mProviderInterfaceMapLock;
-    struct ProviderInfo : public virtual RefBase {
-        friend struct HidlProviderInfo;
-        friend struct AidlProviderInfo;
+
+    struct ProviderInfo :
+            virtual public hardware::camera::provider::V2_6::ICameraProviderCallback,
+            virtual public hardware::hidl_death_recipient
+    {
         const std::string mProviderName;
         const std::string mProviderInstance;
         const metadata_vendor_id_t mProviderTagid;
-        int32_t mMinorVersion;
+        int mMinorVersion;
         sp<VendorTagDescriptor> mVendorTagDescriptor;
         bool mSetTorchModeSupported;
         bool mIsRemote;
 
+        // Current overall Android device physical status
+        hardware::hidl_bitfield<hardware::camera::provider::V2_5::DeviceState> mDeviceState;
+
+        // This pointer is used to keep a reference to the ICameraProvider that was last accessed.
+        wp<hardware::camera::provider::V2_4::ICameraProvider> mActiveInterface;
+
+        sp<hardware::camera::provider::V2_4::ICameraProvider> mSavedInterface;
+
         ProviderInfo(const std::string &providerName, const std::string &providerInstance,
                 CameraProviderManager *manager);
         ~ProviderInfo();
 
-        virtual IPCTransport getIPCTransport() = 0;
+        status_t initialize(sp<hardware::camera::provider::V2_4::ICameraProvider>& interface,
+                hardware::hidl_bitfield<hardware::camera::provider::V2_5::DeviceState>
+                    currentDeviceState);
+
+        const sp<hardware::camera::provider::V2_4::ICameraProvider> startProviderInterface();
 
         const std::string& getType() const;
 
+        status_t addDevice(const std::string& name,
+                hardware::camera::common::V1_0::CameraDeviceStatus initialStatus =
+                hardware::camera::common::V1_0::CameraDeviceStatus::PRESENT,
+                /*out*/ std::string *parsedId = nullptr);
+
         status_t dump(int fd, const Vector<String16>& args) const;
 
-        void initializeProviderInfoCommon(const std::vector<std::string> &devices);
+        // ICameraProviderCallbacks interface - these lock the parent mInterfaceMutex
+        hardware::Return<void> cameraDeviceStatusChange(
+                const hardware::hidl_string& cameraDeviceName,
+                hardware::camera::common::V1_0::CameraDeviceStatus newStatus) override;
+        hardware::Return<void> torchModeStatusChange(
+                const hardware::hidl_string& cameraDeviceName,
+                hardware::camera::common::V1_0::TorchModeStatus newStatus) override;
+        hardware::Return<void> physicalCameraDeviceStatusChange(
+                const hardware::hidl_string& cameraDeviceName,
+                const hardware::hidl_string& physicalCameraDeviceName,
+                hardware::camera::common::V1_0::CameraDeviceStatus newStatus) override;
+
+        status_t cameraDeviceStatusChangeLocked(
+                std::string* id, const hardware::hidl_string& cameraDeviceName,
+                hardware::camera::common::V1_0::CameraDeviceStatus newStatus);
+        status_t physicalCameraDeviceStatusChangeLocked(
+                std::string* id, std::string* physicalId,
+                const hardware::hidl_string& cameraDeviceName,
+                const hardware::hidl_string& physicalCameraDeviceName,
+                hardware::camera::common::V1_0::CameraDeviceStatus newStatus);
+
+        // hidl_death_recipient interface - this locks the parent mInterfaceMutex
+        virtual void serviceDied(uint64_t cookie, const wp<hidl::base::V1_0::IBase>& who) override;
+
         /**
          * Setup vendor tags for this provider
          */
-        virtual status_t setUpVendorTags() = 0;
+        status_t setUpVendorTags();
 
         /**
          * Notify provider about top-level device physical state changes
@@ -491,11 +432,9 @@ private:
          * It is possible for camera providers to add/remove devices and try to
          * acquire it.
          */
-        virtual status_t notifyDeviceStateChange(int64_t newDeviceState) = 0;
-
-        virtual bool successfullyStartedProviderInterface() = 0;
-
-        virtual int64_t getDeviceState() = 0;
+        status_t notifyDeviceStateChange(
+                hardware::hidl_bitfield<hardware::camera::provider::V2_5::DeviceState>
+                    newDeviceState);
 
         std::vector<std::unordered_set<std::string>> getConcurrentCameraIdCombinations();
 
@@ -504,62 +443,40 @@ private:
          *
          * Note that 'mInterfaceMutex' should be held when calling this method.
          */
-        void notifyDeviceInfoStateChangeLocked(int64_t newDeviceState);
+        void notifyDeviceInfoStateChangeLocked(
+               hardware::hidl_bitfield<hardware::camera::provider::V2_5::DeviceState>
+                   newDeviceState);
 
         /**
          * Query the camera provider for concurrent stream configuration support
          */
-        virtual status_t isConcurrentSessionConfigurationSupported(
-                    const std::vector<CameraIdAndSessionConfiguration> &cameraIdsAndSessionConfigs,
-                    const std::set<std::string>& perfClassPrimaryCameraIds,
-                    int targetSdkVersion, bool *isSupported) = 0;
-
-        /**
-         * Remove all devices associated with this provider and notify listeners
-         * with NOT_PRESENT state.
-         */
-        void removeAllDevices();
-
-        /**
-         * Provider is an external lazy HAL
-         */
-        bool isExternalLazyHAL() const;
+        status_t isConcurrentSessionConfigurationSupported(
+                const hardware::hidl_vec<
+                        hardware::camera::provider::V2_7::CameraIdAndStreamCombination>
+                                &halCameraIdsAndStreamCombinations,
+                bool *isSupported);
 
         // Basic device information, common to all camera devices
         struct DeviceInfo {
             const std::string mName;  // Full instance name
             const std::string mId;    // ID section of full name
-            //Both hidl and aidl DeviceInfos. Aidl deviceInfos get {3, 8} to
-            //start off.
             const hardware::hidl_version mVersion;
             const metadata_vendor_id_t mProviderTagid;
             bool mIsLogicalCamera;
             std::vector<std::string> mPhysicalIds;
             hardware::CameraInfo mInfo;
+            sp<IBase> mSavedInterface;
             SystemCameraKind mSystemCameraKind = SystemCameraKind::PUBLIC;
 
-            const CameraResourceCost mResourceCost;
+            const hardware::camera::common::V1_0::CameraResourceCost mResourceCost;
 
-            CameraDeviceStatus mStatus;
+            hardware::camera::common::V1_0::CameraDeviceStatus mStatus;
 
             wp<ProviderInfo> mParentProvider;
-            // Torch strength default, maximum levels if the torch strength control
-            // feature is supported.
-            int32_t mTorchStrengthLevel;
-            int32_t mTorchMaximumStrengthLevel;
-            int32_t mTorchDefaultStrengthLevel;
-
-            // Wait for lazy HALs to confirm device availability
-            static const nsecs_t kDeviceAvailableTimeout = 2000e6; // 2000 ms
-            Mutex     mDeviceAvailableLock;
-            Condition mDeviceAvailableSignal;
-            bool mIsDeviceAvailable = true;
 
             bool hasFlashUnit() const { return mHasFlashUnit; }
             bool supportNativeZoomRatio() const { return mSupportNativeZoomRatio; }
             virtual status_t setTorchMode(bool enabled) = 0;
-            virtual status_t turnOnTorchWithStrengthLevel(int32_t torchStrength) = 0;
-            virtual status_t getTorchStrengthLevel(int32_t *torchStrength) = 0;
             virtual status_t getCameraInfo(hardware::CameraInfo *info) const = 0;
             virtual bool isAPI1Compatible() const = 0;
             virtual status_t dumpState(int fd) = 0;
@@ -577,33 +494,44 @@ private:
             }
 
             virtual status_t isSessionConfigurationSupported(
-                    const SessionConfiguration &/*configuration*/,
-                    bool /*overrideForPerfClass*/,
-                    camera3::metadataGetter /*getMetadata*/,
+                    const hardware::camera::device::V3_7::StreamConfiguration &/*configuration*/,
                     bool * /*status*/) {
                 return INVALID_OPERATION;
             }
             virtual status_t filterSmallJpegSizes() = 0;
-            virtual void notifyDeviceStateChange(int64_t /*newState*/) {}
+            virtual void notifyDeviceStateChange(
+                    hardware::hidl_bitfield<hardware::camera::provider::V2_5::DeviceState>
+                        /*newState*/) {}
+
+            template<class InterfaceT>
+            sp<InterfaceT> startDeviceInterface();
 
             DeviceInfo(const std::string& name, const metadata_vendor_id_t tagId,
                     const std::string &id, const hardware::hidl_version& version,
                     const std::vector<std::string>& publicCameraIds,
-                    const CameraResourceCost& resourceCost,
+                    const hardware::camera::common::V1_0::CameraResourceCost& resourceCost,
                     sp<ProviderInfo> parentProvider) :
                     mName(name), mId(id), mVersion(version), mProviderTagid(tagId),
                     mIsLogicalCamera(false), mResourceCost(resourceCost),
-                    mStatus(CameraDeviceStatus::PRESENT),
-                    mParentProvider(parentProvider), mTorchStrengthLevel(0),
-                    mTorchMaximumStrengthLevel(0), mTorchDefaultStrengthLevel(0),
-                    mHasFlashUnit(false), mSupportNativeZoomRatio(false),
-                    mPublicCameraIds(publicCameraIds) {}
-            virtual ~DeviceInfo() {}
+                    mStatus(hardware::camera::common::V1_0::CameraDeviceStatus::PRESENT),
+                    mParentProvider(parentProvider), mHasFlashUnit(false),
+                    mSupportNativeZoomRatio(false), mPublicCameraIds(publicCameraIds) {}
+            virtual ~DeviceInfo();
         protected:
-
             bool mHasFlashUnit; // const after constructor
             bool mSupportNativeZoomRatio; // const after constructor
             const std::vector<std::string>& mPublicCameraIds;
+
+            template<class InterfaceT>
+            static status_t setTorchMode(InterfaceT& interface, bool enabled);
+
+            template<class InterfaceT>
+            status_t setTorchModeForDevice(bool enabled) {
+                // Don't save the ICameraProvider interface here because we assume that this was
+                // called from CameraProviderManager::setTorchMode(), which does save it.
+                const sp<InterfaceT> interface = startDeviceInterface<InterfaceT>();
+                return DeviceInfo::setTorchMode(interface, enabled);
+            }
         };
         std::vector<std::unique_ptr<DeviceInfo>> mDevices;
         std::unordered_set<std::string> mUniqueCameraIds;
@@ -618,47 +546,43 @@ private:
 
         // HALv3-specific camera fields, including the actual device interface
         struct DeviceInfo3 : public DeviceInfo {
+            typedef hardware::camera::device::V3_2::ICameraDevice InterfaceT;
 
-            virtual status_t setTorchMode(bool enabled) = 0;
-            virtual status_t turnOnTorchWithStrengthLevel(int32_t torchStrength) = 0;
-            virtual status_t getTorchStrengthLevel(int32_t *torchStrength) = 0;
+            virtual status_t setTorchMode(bool enabled) override;
             virtual status_t getCameraInfo(hardware::CameraInfo *info) const override;
             virtual bool isAPI1Compatible() const override;
-            virtual status_t dumpState(int fd) = 0;
+            virtual status_t dumpState(int fd) override;
             virtual status_t getCameraCharacteristics(
                     bool overrideForPerfClass,
                     CameraMetadata *characteristics) const override;
             virtual status_t getPhysicalCameraCharacteristics(const std::string& physicalCameraId,
                     CameraMetadata *characteristics) const override;
             virtual status_t isSessionConfigurationSupported(
-                    const SessionConfiguration &configuration, bool /*overrideForPerfClass*/,
-                    camera3::metadataGetter /*getMetadata*/,
-                    bool *status /*out*/) = 0;
+                    const hardware::camera::device::V3_7::StreamConfiguration &configuration,
+                    bool *status /*out*/)
+                    override;
             virtual status_t filterSmallJpegSizes() override;
             virtual void notifyDeviceStateChange(
-                        int64_t newState) override;
+                    hardware::hidl_bitfield<hardware::camera::provider::V2_5::DeviceState>
+                        newState) override;
 
             DeviceInfo3(const std::string& name, const metadata_vendor_id_t tagId,
                     const std::string &id, uint16_t minorVersion,
-                    const CameraResourceCost& resourceCost,
+                    const hardware::camera::common::V1_0::CameraResourceCost& resourceCost,
                     sp<ProviderInfo> parentProvider,
-                    const std::vector<std::string>& publicCameraIds);
-            virtual ~DeviceInfo3() {};
-        protected:
-            // Modified by derived transport specific (hidl / aidl) class
+                    const std::vector<std::string>& publicCameraIds, sp<InterfaceT> interface);
+            virtual ~DeviceInfo3();
+        private:
             CameraMetadata mCameraCharacteristics;
             // Map device states to sensor orientations
             std::unordered_map<int64_t, int32_t> mDeviceStateOrientationMap;
             // A copy of mCameraCharacteristics without performance class
             // override
             std::unique_ptr<CameraMetadata> mCameraCharNoPCOverride;
-            // Only contains characteristics for hidden physical cameras,
-            // not for public physical cameras.
             std::unordered_map<std::string, CameraMetadata> mPhysicalCameraCharacteristics;
             void queryPhysicalCameraIds();
             SystemCameraKind getSystemCameraKind();
             status_t fixupMonochromeTags();
-            status_t fixupTorchStrengthTags();
             status_t addDynamicDepthTags(bool maxResolution = false);
             status_t deriveHeicTags(bool maxResolution = false);
             status_t addRotateCropTags();
@@ -688,7 +612,8 @@ private:
                     const camera_metadata_entry& halStreamConfigs,
                     const camera_metadata_entry& halStreamDurations);
         };
-    protected:
+
+    private:
         std::string mType;
         uint32_t mId;
 
@@ -698,12 +623,12 @@ private:
 
         struct CameraStatusInfoT {
             bool isPhysicalCameraStatus = false;
-            std::string cameraId;
-            std::string physicalCameraId;
-            CameraDeviceStatus status;
-            CameraStatusInfoT(bool isForPhysicalCamera, const std::string& id,
-                    const std::string& physicalId,
-                    CameraDeviceStatus s) :
+            hardware::hidl_string cameraId;
+            hardware::hidl_string physicalCameraId;
+            hardware::camera::common::V1_0::CameraDeviceStatus status;
+            CameraStatusInfoT(bool isForPhysicalCamera, const hardware::hidl_string& id,
+                    const hardware::hidl_string& physicalId,
+                    hardware::camera::common::V1_0::CameraDeviceStatus s) :
                     isPhysicalCameraStatus(isForPhysicalCamera), cameraId(id),
                     physicalCameraId(physicalId), status(s) {}
         };
@@ -715,19 +640,22 @@ private:
         // End of scope for mInitLock
 
         std::future<void> mInitialStatusCallbackFuture;
-
-        std::unique_ptr<ProviderInfo::DeviceInfo>
-        virtual initializeDeviceInfo(
-                const std::string &name, const metadata_vendor_id_t tagId,
-                const std::string &id, uint16_t minorVersion) = 0;
-
-        virtual status_t reCacheConcurrentStreamingCameraIdsLocked() = 0;
-
         void notifyInitialStatusChange(sp<StatusListener> listener,
                 std::unique_ptr<std::vector<CameraStatusInfoT>> cachedStatus);
 
         std::vector<std::unordered_set<std::string>> mConcurrentCameraIdCombinations;
 
+        // Templated method to instantiate the right kind of DeviceInfo and call the
+        // right CameraProvider getCameraDeviceInterface_* method.
+        template<class DeviceInfoT>
+        std::unique_ptr<DeviceInfo> initializeDeviceInfo(const std::string &name,
+                const metadata_vendor_id_t tagId, const std::string &id,
+                uint16_t minorVersion);
+
+        // Helper for initializeDeviceInfo to use the right CameraProvider get method.
+        template<class InterfaceT>
+        sp<InterfaceT> startDeviceInterface(const std::string &name);
+
         // Parse provider instance name for type and id
         static status_t parseProviderName(const std::string& name,
                 std::string *type, uint32_t *id);
@@ -739,71 +667,33 @@ private:
         // Generate vendor tag id
         static metadata_vendor_id_t generateVendorTagId(const std::string &name);
 
-        status_t addDevice(
-                const std::string& name, CameraDeviceStatus initialStatus,
-                /*out*/ std::string* parsedId);
-
-        void cameraDeviceStatusChangeInternal(const std::string& cameraDeviceName,
-                CameraDeviceStatus newStatus);
-
-        status_t cameraDeviceStatusChangeLocked(
-                std::string* id, const std::string& cameraDeviceName,
-                CameraDeviceStatus newStatus);
-
-        void physicalCameraDeviceStatusChangeInternal(const std::string& cameraDeviceName,
-                const std::string& physicalCameraDeviceName,
-                CameraDeviceStatus newStatus);
-
-      status_t physicalCameraDeviceStatusChangeLocked(
-            std::string* id, std::string* physicalId,
-            const std::string& cameraDeviceName,
-            const std::string& physicalCameraDeviceName,
-            CameraDeviceStatus newStatus);
-
-        void torchModeStatusChangeInternal(const std::string& cameraDeviceName,
-                TorchModeStatus newStatus);
-
         void removeDevice(std::string id);
 
+        // Expects to have mLock locked
+        status_t reCacheConcurrentStreamingCameraIdsLocked();
+        // Expects to have mLock locked
+        status_t getConcurrentCameraIdsInternalLocked(
+                sp<hardware::camera::provider::V2_6::ICameraProvider> &interface2_6);
     };
 
-    template <class ProviderInfoType, class HalCameraProviderType>
-    status_t setTorchModeT(sp<ProviderInfo> &parentProvider,
-            std::shared_ptr<HalCameraProvider> *halCameraProvider);
-
-    // Try to get hidl provider services declared. Expects mInterfaceMutex to be
-    // locked. Also registers for hidl provider service notifications.
-    status_t tryToInitAndAddHidlProvidersLocked(HidlServiceInteractionProxy *hidlProxy);
-
-    // Try to get aidl provider services declared. Expects mInterfaceMutex to be
-    // locked. Also registers for aidl provider service notifications.
-    status_t tryToAddAidlProvidersLocked();
-
     /**
      * Save the ICameraProvider while it is being used by a camera or torch client
      */
     void saveRef(DeviceMode usageType, const std::string &cameraId,
-            std::shared_ptr<HalCameraProvider> provider);
+            sp<hardware::camera::provider::V2_4::ICameraProvider> provider);
 
     // Utility to find a DeviceInfo by ID; pointer is only valid while mInterfaceMutex is held
     // and the calling code doesn't mutate the list of providers or their lists of devices.
+    // Finds the first device of the given ID that falls within the requested version range
+    //   minVersion <= deviceVersion < maxVersion
     // No guarantees on the order of traversal
-    ProviderInfo::DeviceInfo* findDeviceInfoLocked(const std::string& id) const;
-
-    // Map external providers to USB devices in order to handle USB hotplug
-    // events for lazy HALs
-    std::pair<std::vector<std::string>, sp<ProviderInfo>>
-        mExternalUsbDevicesForProvider;
-    sp<ProviderInfo> startExternalLazyProvider() const;
-
-    status_t addHidlProviderLocked(const std::string& newProvider, bool preexisting = false);
+    ProviderInfo::DeviceInfo* findDeviceInfoLocked(const std::string& id,
+            hardware::hidl_version minVersion = hardware::hidl_version{0,0},
+            hardware::hidl_version maxVersion = hardware::hidl_version{1000,0}) const;
 
-    status_t addAidlProviderLocked(const std::string& newProvider);
+    status_t addProviderLocked(const std::string& newProvider, bool preexisting = false);
 
-    status_t tryToInitializeHidlProviderLocked(const std::string& providerName,
-            const sp<ProviderInfo>& providerInfo);
-
-    status_t tryToInitializeAidlProviderLocked(const std::string& providerName,
+    status_t tryToInitializeProviderLocked(const std::string& providerName,
             const sp<ProviderInfo>& providerInfo);
 
     bool isLogicalCameraLocked(const std::string& id, std::vector<std::string>* physicalCameraIds);
@@ -815,13 +705,18 @@ private:
     status_t removeProvider(const std::string& provider);
     sp<StatusListener> getStatusListener() const;
 
-    bool isValidDeviceLocked(const std::string &id, uint16_t majorVersion,
-            IPCTransport transport) const;
+    bool isValidDeviceLocked(const std::string &id, uint16_t majorVersion) const;
 
     size_t mProviderInstanceId = 0;
     std::vector<sp<ProviderInfo>> mProviders;
-    // Provider names of AIDL providers with retrieved binders.
-    std::set<std::string> mAidlProviderWithBinders;
+
+    void addProviderToMap(
+            const std::string &cameraId,
+            sp<hardware::camera::provider::V2_4::ICameraProvider> provider,
+            bool isTorchUsage);
+    void removeCameraIdFromMap(
+        std::unordered_map<std::string, sp<hardware::camera::provider::V2_4::ICameraProvider>> &map,
+        const std::string &cameraId);
 
     static const char* deviceStatusToString(
         const hardware::camera::common::V1_0::CameraDeviceStatus&);
@@ -833,16 +728,20 @@ private:
     void filterLogicalCameraIdsLocked(std::vector<std::string>& deviceIds) const;
 
     status_t getSystemCameraKindLocked(const std::string& id, SystemCameraKind *kind) const;
-    std::pair<bool, ProviderInfo::DeviceInfo *> isHiddenPhysicalCameraInternal(
-            const std::string& cameraId) const;
+    std::pair<bool, ProviderInfo::DeviceInfo *> isHiddenPhysicalCameraInternal(const std::string& cameraId) const;
 
     void collectDeviceIdsLocked(const std::vector<std::string> deviceIds,
             std::vector<std::string>& normalDeviceIds,
             std::vector<std::string>& systemCameraDeviceIds) const;
 
-    status_t usbDeviceDetached(const std::string &usbDeviceId);
-    ndk::ScopedAStatus onAidlRegistration(const std::string& in_name,
-            const ::ndk::SpAIBinder& in_binder);
+    status_t convertToHALStreamCombinationAndCameraIdsLocked(
+              const std::vector<hardware::camera2::utils::CameraIdAndSessionConfiguration>
+                      &cameraIdsAndSessionConfigs,
+              const std::set<std::string>& perfClassPrimaryCameraIds,
+              int targetSdkVersion,
+              hardware::hidl_vec<hardware::camera::provider::V2_7::CameraIdAndStreamCombination>
+                      *halCameraIdsAndStreamCombinations,
+              bool *earlyExit);
 };
 
 } // namespace android
diff --git a/services/camera/libcameraservice/common/DepthPhotoProcessor.cpp b/services/camera/libcameraservice/common/DepthPhotoProcessor.cpp
index 719ff2c975..c9956702dc 100644
--- a/services/camera/libcameraservice/common/DepthPhotoProcessor.cpp
+++ b/services/camera/libcameraservice/common/DepthPhotoProcessor.cpp
@@ -42,10 +42,6 @@
 #include <xmpmeta/xmp_data.h>
 #include <xmpmeta/xmp_writer.h>
 
-#ifndef __unused
-#define __unused __attribute__((__unused__))
-#endif
-
 using dynamic_depth::Camera;
 using dynamic_depth::Cameras;
 using dynamic_depth::CameraParams;
diff --git a/services/camera/libcameraservice/common/HalConversionsTemplated.h b/services/camera/libcameraservice/common/HalConversionsTemplated.h
deleted file mode 100644
index 96a715c7b8..0000000000
--- a/services/camera/libcameraservice/common/HalConversionsTemplated.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef ANDROID_SERVERS_CAMERA_HAL_CONVERSION_TEMPLATED_H
-#define ANDROID_SERVERS_CAMERA_HAL_CONVERSION_TEMPLATED_H
-
-#include "common/CameraProviderManager.h"
-
-#include <device3/Camera3StreamInterface.h>
-
-namespace android {
-
-template <class HalCameraDeviceStatus>
-HalCameraDeviceStatus mapFrameworkToHalCameraDeviceStatus(
-        const CameraDeviceStatus& s)  {
-    switch(s) {
-        case CameraDeviceStatus::PRESENT:
-            return HalCameraDeviceStatus::PRESENT;
-        case CameraDeviceStatus::NOT_PRESENT:
-            return HalCameraDeviceStatus::NOT_PRESENT;
-        case CameraDeviceStatus::ENUMERATING:
-            return HalCameraDeviceStatus::ENUMERATING;
-    }
-    ALOGW("Unexpectedcamera device status code %d", s);
-    return HalCameraDeviceStatus::NOT_PRESENT;
-}
-
-template <class HalCameraDeviceStatus>
-CameraDeviceStatus HalToFrameworkCameraDeviceStatus(
-        const HalCameraDeviceStatus& s)  {
-    switch(s) {
-        case HalCameraDeviceStatus::PRESENT:
-            return CameraDeviceStatus::PRESENT;
-        case HalCameraDeviceStatus::NOT_PRESENT:
-            return CameraDeviceStatus::NOT_PRESENT;
-        case HalCameraDeviceStatus::ENUMERATING:
-            return CameraDeviceStatus::ENUMERATING;
-    }
-    ALOGW("Unexpectedcamera device status code %d", s);
-    return CameraDeviceStatus::NOT_PRESENT;
-}
-
-template <class HalCameraResourceCost>
-CameraResourceCost HalToFrameworkResourceCost(
-        const HalCameraResourceCost& s)  {
-    CameraResourceCost internalResourceCost;
-    internalResourceCost.resourceCost = (uint32_t)s.resourceCost;
-    for (const auto device : s.conflictingDevices) {
-        internalResourceCost.conflictingDevices.emplace_back(device.c_str());
-    }
-    return internalResourceCost;
-}
-
-template <class HalTorchModeStatus>
-TorchModeStatus HalToFrameworkTorchModeStatus(
-        const HalTorchModeStatus& s)  {
-    switch(s) {
-        case HalTorchModeStatus::NOT_AVAILABLE:
-            return TorchModeStatus::NOT_AVAILABLE;
-        case HalTorchModeStatus::AVAILABLE_OFF:
-            return TorchModeStatus::AVAILABLE_OFF;
-        case HalTorchModeStatus::AVAILABLE_ON:
-            return TorchModeStatus::AVAILABLE_ON;
-    }
-    ALOGW("Unexpectedcamera torch mode status code %d", s);
-    return TorchModeStatus::NOT_AVAILABLE;
-}
-
-template <class HalCameraDeviceStatus>
- const char* HalDeviceStatusToString(const HalCameraDeviceStatus& s) {
-    switch(s) {
-        case HalCameraDeviceStatus::NOT_PRESENT:
-            return "NOT_PRESENT";
-        case HalCameraDeviceStatus::PRESENT:
-            return "PRESENT";
-        case HalCameraDeviceStatus::ENUMERATING:
-            return "ENUMERATING";
-    }
-    ALOGW("Unexpected HAL device status code %d", s);
-    return "UNKNOWN_STATUS";
-}
-
-}
-
-#endif
diff --git a/services/camera/libcameraservice/common/aidl/AidlProviderInfo.cpp b/services/camera/libcameraservice/common/aidl/AidlProviderInfo.cpp
deleted file mode 100644
index 81b4779eb6..0000000000
--- a/services/camera/libcameraservice/common/aidl/AidlProviderInfo.cpp
+++ /dev/null
@@ -1,832 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "AidlProviderInfo.h"
-#include "common/HalConversionsTemplated.h"
-#include "common/CameraProviderInfoTemplated.h"
-
-#include <cutils/properties.h>
-
-#include <aidlcommonsupport/NativeHandle.h>
-#include <android/binder_manager.h>
-#include <android/hardware/ICameraService.h>
-#include <camera_metadata_hidden.h>
-
-#include "device3/ZoomRatioMapper.h"
-#include <utils/SessionConfigurationUtils.h>
-#include <utils/Trace.h>
-
-namespace {
-const bool kEnableLazyHal(property_get_bool("ro.camera.enableLazyHal", false));
-} // anonymous namespace
-
-namespace android {
-
-namespace SessionConfigurationUtils = ::android::camera3::SessionConfigurationUtils;
-
-using namespace aidl::android::hardware;
-using namespace hardware::camera;
-using hardware::camera2::utils::CameraIdAndSessionConfiguration;
-using hardware::ICameraService;
-
-using HalDeviceStatusType = aidl::android::hardware::camera::common::CameraDeviceStatus;
-using ICameraProvider = aidl::android::hardware::camera::provider::ICameraProvider;
-using StatusListener = CameraProviderManager::StatusListener;
-
-static status_t mapExceptionCodeToStatusT(binder_exception_t binderException) {
-    switch (binderException) {
-        case EX_NONE:
-            return OK;
-        case EX_ILLEGAL_ARGUMENT:
-        case EX_NULL_POINTER:
-        case EX_BAD_PARCELABLE:
-        case EX_ILLEGAL_STATE:
-            return BAD_VALUE;
-        case EX_UNSUPPORTED_OPERATION:
-            return INVALID_OPERATION;
-        case EX_TRANSACTION_FAILED:
-            return DEAD_OBJECT;
-        default:
-            return UNKNOWN_ERROR;
-    }
-}
-
-status_t AidlProviderInfo::mapToStatusT(const ndk::ScopedAStatus& s) {
-    using Status = aidl::android::hardware::camera::common::Status;
-    auto exceptionCode = s.getExceptionCode();
-    if (exceptionCode != EX_SERVICE_SPECIFIC) {
-        return mapExceptionCodeToStatusT(exceptionCode);
-    }
-    Status st = static_cast<Status>(s.getServiceSpecificError());
-    switch (st) {
-        case Status::OK:
-            return OK;
-        case Status::ILLEGAL_ARGUMENT:
-            return BAD_VALUE;
-        case Status::CAMERA_IN_USE:
-            return -EBUSY;
-        case Status::MAX_CAMERAS_IN_USE:
-            return -EUSERS;
-        case Status::OPERATION_NOT_SUPPORTED:
-            return INVALID_OPERATION;
-        case Status::CAMERA_DISCONNECTED:
-            return DEAD_OBJECT;
-        case Status::INTERNAL_ERROR:
-            return INVALID_OPERATION;
-    }
-    ALOGW("Unexpected HAL status code %d", static_cast<int>(st));
-    return INVALID_OPERATION;
-}
-
-AidlProviderInfo::AidlProviderInfo(
-            const std::string &providerName,
-            const std::string &providerInstance,
-            CameraProviderManager *manager) :
-            CameraProviderManager::ProviderInfo(providerName, providerInstance, manager) {}
-
-status_t AidlProviderInfo::initializeAidlProvider(
-        std::shared_ptr<ICameraProvider>& interface, int64_t currentDeviceState) {
-
-    status_t res = parseProviderName(mProviderName, &mType, &mId);
-    if (res != OK) {
-        ALOGE("%s: Invalid provider name, ignoring", __FUNCTION__);
-        return BAD_VALUE;
-    }
-    ALOGI("Connecting to new camera provider: %s, isRemote? %d",
-            mProviderName.c_str(), interface->isRemote());
-
-    // cameraDeviceStatusChange callbacks may be called (and causing new devices added)
-    // before setCallback returns
-    mCallbacks =
-            ndk::SharedRefBase::make<AidlProviderCallbacks>(this);
-    ndk::ScopedAStatus status =
-            interface->setCallback(mCallbacks);
-    if (!status.isOk()) {
-        ALOGE("%s: Transaction error setting up callbacks with camera provider '%s': %s",
-                __FUNCTION__, mProviderName.c_str(), status.getMessage());
-        return mapToStatusT(status);
-    }
-
-    mDeathRecipient = ndk::ScopedAIBinder_DeathRecipient(AIBinder_DeathRecipient_new(binderDied));
-    auto link = AIBinder_linkToDeath(interface->asBinder().get(), mDeathRecipient.get(), this);
-    if (link != STATUS_OK) {
-        ALOGW("%s: Unable to link to provider '%s' death notifications",
-                __FUNCTION__, mProviderName.c_str());
-        return DEAD_OBJECT;
-    }
-
-    if (!kEnableLazyHal) {
-        // Save HAL reference indefinitely
-        mSavedInterface = interface;
-    } else {
-        mActiveInterface = interface;
-    }
-
-    ALOGV("%s: Setting device state for %s: 0x%" PRIx64,
-            __FUNCTION__, mProviderName.c_str(), mDeviceState);
-    notifyDeviceStateChange(currentDeviceState);
-
-    res = setUpVendorTags();
-    if (res != OK) {
-        ALOGE("%s: Unable to set up vendor tags from provider '%s'",
-                __FUNCTION__, mProviderName.c_str());
-        return res;
-     }
-
-    // Get initial list of camera devices, if any
-    std::vector<std::string> devices;
-    std::vector<std::string> retDevices;
-    status = interface->getCameraIdList(&retDevices);
-    if (!status.isOk()) {
-        ALOGE("%s: Transaction error in getting camera ID list from provider '%s': %s",
-                __FUNCTION__, mProviderName.c_str(), status.getMessage());
-        return mapToStatusT(status);
-    }
-
-    for (auto& name : retDevices) {
-        uint16_t major, minor;
-        std::string type, id;
-        status_t res = parseDeviceName(name, &major, &minor, &type, &id);
-        if (res != OK) {
-            ALOGE("%s: Error parsing deviceName: %s: %d", __FUNCTION__, name.c_str(), res);
-            return res;
-        } else {
-            devices.push_back(name);
-            mProviderPublicCameraIds.push_back(id);
-        }
-    }
-
-    // Get list of concurrent streaming camera device combinations
-    res = getConcurrentCameraIdsInternalLocked(interface);
-    if (res != OK) {
-        return res;
-    }
-
-    mSetTorchModeSupported = true;
-
-    mIsRemote = interface->isRemote();
-
-    initializeProviderInfoCommon(devices);
-    return OK;
-}
-
-void AidlProviderInfo::binderDied(void *cookie) {
-    AidlProviderInfo *provider = reinterpret_cast<AidlProviderInfo *>(cookie);
-    ALOGI("Camera provider '%s' has died; removing it", provider->mProviderInstance.c_str());
-    provider->mManager->removeProvider(provider->mProviderInstance);
-}
-
-status_t AidlProviderInfo::setUpVendorTags() {
-    if (mVendorTagDescriptor != nullptr)
-        return OK;
-
-    std::vector<camera::common::VendorTagSection> vts;
-    ::ndk::ScopedAStatus status;
-    const std::shared_ptr<ICameraProvider> interface = startProviderInterface();
-    if (interface == nullptr) {
-        return DEAD_OBJECT;
-    }
-    status = interface->getVendorTags(&vts);
-    if (!status.isOk()) {
-        ALOGE("%s: Transaction error getting vendor tags from provider '%s': %s",
-                __FUNCTION__, mProviderName.c_str(), status.getMessage());
-        return mapToStatusT(status);
-    }
-
-    // Read all vendor tag definitions into a descriptor
-    status_t res;
-    if ((res =
-            IdlVendorTagDescriptor::
-                    createDescriptorFromIdl<std::vector<camera::common::VendorTagSection>,
-                            camera::common::VendorTagSection>(vts, /*out*/mVendorTagDescriptor))
-            != OK) {
-        ALOGE("%s: Could not generate descriptor from vendor tag operations,"
-                "received error %s (%d). Camera clients will not be able to use"
-                "vendor tags", __FUNCTION__, strerror(res), res);
-        return res;
-    }
-
-    return OK;
-}
-
-status_t AidlProviderInfo::notifyDeviceStateChange(int64_t newDeviceState) {
-
-    mDeviceState = newDeviceState;
-    // Check if the provider is currently active - not going to start it up for this notification
-    auto interface = mSavedInterface != nullptr ? mSavedInterface : mActiveInterface.lock();
-    if (interface != nullptr) {
-        // Send current device state
-        interface->notifyDeviceStateChange(mDeviceState);
-    }
-    return OK;
-}
-
-bool AidlProviderInfo::successfullyStartedProviderInterface() {
-    return startProviderInterface() != nullptr;
-}
-
-std::shared_ptr<camera::device::ICameraDevice>
-AidlProviderInfo::startDeviceInterface(const std::string &name) {
-    ::ndk::ScopedAStatus status;
-    std::shared_ptr<camera::device::ICameraDevice> cameraInterface;
-    const std::shared_ptr<ICameraProvider> interface = startProviderInterface();
-    if (interface == nullptr) {
-        return nullptr;
-    }
-    status = interface->getCameraDeviceInterface(name, &cameraInterface);
-    if (!status.isOk()) {
-        ALOGE("%s: Transaction error trying to obtain interface for camera device %s: %s",
-                __FUNCTION__, name.c_str(), status.getMessage());
-        return nullptr;
-    }
-    return cameraInterface;
-}
-
-const std::shared_ptr<ICameraProvider> AidlProviderInfo::startProviderInterface() {
-    ATRACE_CALL();
-    ALOGV("Request to start camera provider: %s", mProviderName.c_str());
-    if (mSavedInterface != nullptr) {
-        return mSavedInterface;
-    }
-    if (!kEnableLazyHal) {
-        ALOGE("Bad provider state! Should not be here on a non-lazy HAL!");
-        return nullptr;
-    }
-
-    auto interface = mActiveInterface.lock();
-    if (interface == nullptr) {
-        // Try to get service without starting
-        interface =
-                    ICameraProvider::fromBinder(
-                            ndk::SpAIBinder(AServiceManager_checkService(mProviderName.c_str())));
-        if (interface == nullptr) {
-            ALOGV("Camera provider actually needs restart, calling getService(%s)",
-                  mProviderName.c_str());
-            interface =
-                            ICameraProvider::fromBinder(
-                                    ndk::SpAIBinder(
-                                                AServiceManager_getService(mProviderName.c_str())));
-
-            // Set all devices as ENUMERATING, provider should update status
-            // to PRESENT after initializing.
-            // This avoids failing getCameraDeviceInterface_V3_x before devices
-            // are ready.
-            for (auto& device : mDevices) {
-              device->mIsDeviceAvailable = false;
-            }
-
-            interface->setCallback(mCallbacks);
-            auto link = AIBinder_linkToDeath(interface->asBinder().get(), mDeathRecipient.get(),
-                    this);
-            if (link != STATUS_OK) {
-                ALOGW("%s: Unable to link to provider '%s' death notifications",
-                        __FUNCTION__, mProviderName.c_str());
-                mManager->removeProvider(mProviderName);
-                return nullptr;
-            }
-
-            // Send current device state
-            interface->notifyDeviceStateChange(mDeviceState);
-        }
-        mActiveInterface = interface;
-    } else {
-        ALOGV("Camera provider (%s) already in use. Re-using instance.",
-              mProviderName.c_str());
-    }
-
-    return interface;
-}
-
-::ndk::ScopedAStatus AidlProviderInfo::AidlProviderCallbacks::cameraDeviceStatusChange(
-    const std::string& cameraDeviceName,
-    HalDeviceStatusType newStatus) {
-    sp<AidlProviderInfo> parent = mParent.promote();
-    if (parent == nullptr) {
-        ALOGE("%s: Parent provider not alive", __FUNCTION__);
-        return ::ndk::ScopedAStatus::ok();
-    }
-    return parent->cameraDeviceStatusChange(cameraDeviceName, newStatus);
-}
-
-::ndk::ScopedAStatus AidlProviderInfo::AidlProviderCallbacks::torchModeStatusChange(
-            const std::string& cameraDeviceName,
-            aidl::android::hardware::camera::common::TorchModeStatus newStatus) {
-    sp<AidlProviderInfo> parent = mParent.promote();
-    if (parent == nullptr) {
-        ALOGE("%s: Parent provider not alive", __FUNCTION__);
-        return ::ndk::ScopedAStatus::ok();
-    }
-    return parent->torchModeStatusChange(cameraDeviceName, newStatus);
-
-};
-
-::ndk::ScopedAStatus AidlProviderInfo::AidlProviderCallbacks::physicalCameraDeviceStatusChange(
-            const std::string& cameraDeviceName,
-            const std::string& physicalCameraDeviceName,
-            HalDeviceStatusType newStatus) {
-    sp<AidlProviderInfo> parent = mParent.promote();
-    if (parent == nullptr) {
-        ALOGE("%s: Parent provider not alive", __FUNCTION__);
-        return ::ndk::ScopedAStatus::ok();
-    }
-    return parent->physicalCameraDeviceStatusChange(cameraDeviceName, physicalCameraDeviceName,
-            newStatus);
-};
-
-::ndk::ScopedAStatus AidlProviderInfo::cameraDeviceStatusChange(const std::string& cameraDeviceName,
-            HalDeviceStatusType newStatus) {
-    cameraDeviceStatusChangeInternal(cameraDeviceName, HalToFrameworkCameraDeviceStatus(newStatus));
-    return ::ndk::ScopedAStatus::ok();
-}
-
-::ndk::ScopedAStatus AidlProviderInfo::torchModeStatusChange(const std::string& cameraDeviceName,
-            aidl::android::hardware::camera::common::TorchModeStatus newStatus) {
-    torchModeStatusChangeInternal(cameraDeviceName, HalToFrameworkTorchModeStatus(newStatus));
-    return ::ndk::ScopedAStatus::ok();
-};
-
-::ndk::ScopedAStatus AidlProviderInfo::physicalCameraDeviceStatusChange(
-            const std::string& cameraDeviceName,
-            const std::string& physicalCameraDeviceName,
-            HalDeviceStatusType newStatus) {
-    physicalCameraDeviceStatusChangeInternal(cameraDeviceName, physicalCameraDeviceName,
-            HalToFrameworkCameraDeviceStatus(newStatus));
-    return ::ndk::ScopedAStatus::ok();
-};
-
-std::unique_ptr<CameraProviderManager::ProviderInfo::DeviceInfo>
-    AidlProviderInfo::initializeDeviceInfo(
-        const std::string &name, const metadata_vendor_id_t tagId,
-        const std::string &id, uint16_t minorVersion) {
-    ::ndk::ScopedAStatus status;
-
-    auto cameraInterface = startDeviceInterface(name);
-    if (cameraInterface == nullptr) return nullptr;
-
-    camera::common::CameraResourceCost resourceCost;
-    status = cameraInterface->getResourceCost(&resourceCost);
-    if (!status.isOk()) {
-        ALOGE("%s: Unable to obtain resource costs for camera device %s: %s", __FUNCTION__,
-                name.c_str(), status.getMessage());
-        return nullptr;
-    }
-
-    for (auto& conflictName : resourceCost.conflictingDevices) {
-        uint16_t major, minor;
-        std::string type, id;
-        status_t res = parseDeviceName(conflictName, &major, &minor, &type, &id);
-        if (res != OK) {
-            ALOGE("%s: Failed to parse conflicting device %s", __FUNCTION__, conflictName.c_str());
-            return nullptr;
-        }
-        conflictName = id;
-    }
-
-    return std::unique_ptr<DeviceInfo3>(
-        new AidlDeviceInfo3(name, tagId, id, minorVersion, HalToFrameworkResourceCost(resourceCost),
-                this, mProviderPublicCameraIds, cameraInterface));
-}
-
-status_t AidlProviderInfo::reCacheConcurrentStreamingCameraIdsLocked() {
-
-    // Check if the provider is currently active - not going to start it up for this notification
-    auto interface = mSavedInterface != nullptr ? mSavedInterface : mActiveInterface.lock();
-    if (interface == nullptr) {
-        ALOGE("%s: camera provider interface for %s is not valid", __FUNCTION__,
-                mProviderName.c_str());
-        return INVALID_OPERATION;
-    }
-
-    return getConcurrentCameraIdsInternalLocked(interface);
-}
-
-status_t AidlProviderInfo::getConcurrentCameraIdsInternalLocked(
-        std::shared_ptr<ICameraProvider> &interface) {
-    if (interface == nullptr) {
-        ALOGE("%s: null interface provided", __FUNCTION__);
-        return BAD_VALUE;
-    }
-
-    std::vector<aidl::android::hardware::camera::provider::ConcurrentCameraIdCombination> combs;
-    ::ndk::ScopedAStatus status = interface->getConcurrentCameraIds(&combs);
-
-    if (!status.isOk()) {
-        ALOGE("%s: Transaction error in getting concurrent camera ID list from provider '%s'",
-                __FUNCTION__, mProviderName.c_str());
-        return mapToStatusT(status);
-    }
-    mConcurrentCameraIdCombinations.clear();
-    for (const auto& combination : combs) {
-        std::unordered_set<std::string> deviceIds;
-        for (const auto &cameraDeviceId : combination.combination) {
-            deviceIds.insert(cameraDeviceId.c_str());
-        }
-        mConcurrentCameraIdCombinations.push_back(std::move(deviceIds));
-    }
-
-    return OK;
-}
-
-AidlProviderInfo::AidlDeviceInfo3::AidlDeviceInfo3(
-        const std::string& name,
-        const metadata_vendor_id_t tagId,
-        const std::string &id, uint16_t minorVersion,
-        const CameraResourceCost& resourceCost,
-        sp<CameraProviderManager::ProviderInfo> parentProvider,
-        const std::vector<std::string>& publicCameraIds,
-        std::shared_ptr<aidl::android::hardware::camera::device::ICameraDevice> interface) :
-        DeviceInfo3(name, tagId, id, minorVersion, resourceCost, parentProvider, publicCameraIds) {
-
-    // Get camera characteristics and initialize flash unit availability
-    aidl::android::hardware::camera::device::CameraMetadata chars;
-    ::ndk::ScopedAStatus status = interface->getCameraCharacteristics(&chars);
-    std::vector<uint8_t> &metadata = chars.metadata;
-    camera_metadata_t *buffer = reinterpret_cast<camera_metadata_t*>(metadata.data());
-    size_t expectedSize = metadata.size();
-    int resV = validate_camera_metadata_structure(buffer, &expectedSize);
-    if (resV == OK || resV == CAMERA_METADATA_VALIDATION_SHIFTED) {
-        set_camera_metadata_vendor_id(buffer, mProviderTagid);
-        mCameraCharacteristics = buffer;
-    } else {
-        ALOGE("%s: Malformed camera metadata received from HAL", __FUNCTION__);
-        return;
-    }
-
-    if (!status.isOk()) {
-        ALOGE("%s: Transaction error getting camera characteristics for device %s"
-                " to check for a flash unit: %s", __FUNCTION__, id.c_str(),
-                status.getMessage());
-        return;
-    }
-
-    if (mCameraCharacteristics.exists(ANDROID_INFO_DEVICE_STATE_ORIENTATIONS)) {
-        const auto &stateMap = mCameraCharacteristics.find(ANDROID_INFO_DEVICE_STATE_ORIENTATIONS);
-        if ((stateMap.count > 0) && ((stateMap.count % 2) == 0)) {
-            for (size_t i = 0; i < stateMap.count; i += 2) {
-                mDeviceStateOrientationMap.emplace(stateMap.data.i64[i], stateMap.data.i64[i+1]);
-            }
-        } else {
-            ALOGW("%s: Invalid ANDROID_INFO_DEVICE_STATE_ORIENTATIONS map size: %zu", __FUNCTION__,
-                    stateMap.count);
-        }
-    }
-
-    mSystemCameraKind = getSystemCameraKind();
-
-    status_t res = fixupMonochromeTags();
-    if (OK != res) {
-        ALOGE("%s: Unable to fix up monochrome tags based for older HAL version: %s (%d)",
-                __FUNCTION__, strerror(-res), res);
-        return;
-    }
-    auto stat = addDynamicDepthTags();
-    if (OK != stat) {
-        ALOGE("%s: Failed appending dynamic depth tags: %s (%d)", __FUNCTION__, strerror(-stat),
-                stat);
-    }
-    res = deriveHeicTags();
-    if (OK != res) {
-        ALOGE("%s: Unable to derive HEIC tags based on camera and media capabilities: %s (%d)",
-                __FUNCTION__, strerror(-res), res);
-    }
-
-    if (camera3::SessionConfigurationUtils::isUltraHighResolutionSensor(mCameraCharacteristics)) {
-        status_t status = addDynamicDepthTags(/*maxResolution*/true);
-        if (OK != status) {
-            ALOGE("%s: Failed appending dynamic depth tags for maximum resolution mode: %s (%d)",
-                    __FUNCTION__, strerror(-status), status);
-        }
-
-        status = deriveHeicTags(/*maxResolution*/true);
-        if (OK != status) {
-            ALOGE("%s: Unable to derive HEIC tags based on camera and media capabilities for"
-                    "maximum resolution mode: %s (%d)", __FUNCTION__, strerror(-status), status);
-        }
-    }
-
-    res = addRotateCropTags();
-    if (OK != res) {
-        ALOGE("%s: Unable to add default SCALER_ROTATE_AND_CROP tags: %s (%d)", __FUNCTION__,
-                strerror(-res), res);
-    }
-    res = addPreCorrectionActiveArraySize();
-    if (OK != res) {
-        ALOGE("%s: Unable to add PRE_CORRECTION_ACTIVE_ARRAY_SIZE: %s (%d)", __FUNCTION__,
-                strerror(-res), res);
-    }
-    res = camera3::ZoomRatioMapper::overrideZoomRatioTags(
-            &mCameraCharacteristics, &mSupportNativeZoomRatio);
-    if (OK != res) {
-        ALOGE("%s: Unable to override zoomRatio related tags: %s (%d)",
-                __FUNCTION__, strerror(-res), res);
-    }
-
-    camera_metadata_entry flashAvailable =
-            mCameraCharacteristics.find(ANDROID_FLASH_INFO_AVAILABLE);
-    if (flashAvailable.count == 1 &&
-            flashAvailable.data.u8[0] == ANDROID_FLASH_INFO_AVAILABLE_TRUE) {
-        mHasFlashUnit = true;
-        // Fix up flash strength tags for devices without these keys.
-        res = fixupTorchStrengthTags();
-        if (OK != res) {
-            ALOGE("%s: Unable to add default ANDROID_FLASH_INFO_STRENGTH_DEFAULT_LEVEL and"
-                    "ANDROID_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL tags: %s (%d)", __FUNCTION__,
-                    strerror(-res), res);
-        }
-    } else {
-        mHasFlashUnit = false;
-    }
-
-    camera_metadata_entry entry =
-            mCameraCharacteristics.find(ANDROID_FLASH_INFO_STRENGTH_DEFAULT_LEVEL);
-    if (entry.count == 1) {
-        mTorchDefaultStrengthLevel = entry.data.i32[0];
-    } else {
-        mTorchDefaultStrengthLevel = 0;
-    }
-    entry = mCameraCharacteristics.find(ANDROID_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL);
-    if (entry.count == 1) {
-        mTorchMaximumStrengthLevel = entry.data.i32[0];
-    } else {
-        mTorchMaximumStrengthLevel = 0;
-    }
-
-    mTorchStrengthLevel = 0;
-
-    queryPhysicalCameraIds();
-
-    // Get physical camera characteristics if applicable
-    if (mIsLogicalCamera) {
-        for (auto& id : mPhysicalIds) {
-            if (std::find(mPublicCameraIds.begin(), mPublicCameraIds.end(), id) !=
-                    mPublicCameraIds.end()) {
-                continue;
-            }
-
-            aidl::android::hardware::camera::device::CameraMetadata pChars;
-            status = interface->getPhysicalCameraCharacteristics(id, &pChars);
-            if (!status.isOk()) {
-                ALOGE("%s: Transaction error getting physical camera %s characteristics for %s: %s",
-                        __FUNCTION__, id.c_str(), id.c_str(), status.getMessage());
-                return;
-            }
-            std::vector<uint8_t> &pMetadata = pChars.metadata;
-            camera_metadata_t *pBuffer =
-                    reinterpret_cast<camera_metadata_t*>(pMetadata.data());
-            size_t expectedSize = pMetadata.size();
-            int res = validate_camera_metadata_structure(pBuffer, &expectedSize);
-            if (res == OK || res == CAMERA_METADATA_VALIDATION_SHIFTED) {
-                set_camera_metadata_vendor_id(pBuffer, mProviderTagid);
-                mPhysicalCameraCharacteristics[id] = pBuffer;
-            } else {
-                ALOGE("%s: Malformed camera metadata received from HAL", __FUNCTION__);
-                return;
-            }
-
-            res = camera3::ZoomRatioMapper::overrideZoomRatioTags(
-                    &mPhysicalCameraCharacteristics[id], &mSupportNativeZoomRatio);
-            if (OK != res) {
-                ALOGE("%s: Unable to override zoomRatio related tags: %s (%d)",
-                        __FUNCTION__, strerror(-res), res);
-            }
-        }
-    }
-
-    if (!kEnableLazyHal) {
-        // Save HAL reference indefinitely
-        mSavedInterface = interface;
-    }
-}
-
-status_t AidlProviderInfo::AidlDeviceInfo3::setTorchMode(bool enabled) {
-    const std::shared_ptr<camera::device::ICameraDevice> interface = startDeviceInterface();
-    ::ndk::ScopedAStatus s = interface->setTorchMode(enabled);
-    if (!s.isOk()) {
-        ALOGE("%s Unable to set torch mode: %s", __FUNCTION__, s.getMessage());
-        return mapToStatusT(s);
-    }
-    return OK;
-}
-
-status_t AidlProviderInfo::AidlDeviceInfo3::turnOnTorchWithStrengthLevel(
-        int32_t torchStrength) {
-    const std::shared_ptr<camera::device::ICameraDevice> interface = startDeviceInterface();
-    if (interface == nullptr) {
-        return DEAD_OBJECT;
-    }
-
-    ::ndk::ScopedAStatus s = interface->turnOnTorchWithStrengthLevel(torchStrength);
-    if (!s.isOk()) {
-        ALOGE("%s Unable to set torch mode strength %d : %s", __FUNCTION__, torchStrength,
-                s.getMessage());
-        return mapToStatusT(s);
-    }
-    mTorchStrengthLevel = torchStrength;
-    return OK;
-}
-
-status_t AidlProviderInfo::AidlDeviceInfo3::getTorchStrengthLevel(int32_t *torchStrength) {
-    if (torchStrength == nullptr) {
-        return BAD_VALUE;
-    }
-    const std::shared_ptr<camera::device::ICameraDevice> interface = startDeviceInterface();
-    if (interface == nullptr) {
-        return DEAD_OBJECT;
-    }
-
-    ::ndk::ScopedAStatus status = interface->getTorchStrengthLevel(torchStrength);
-    if (!status.isOk()) {
-        ALOGE("%s: Couldn't get torch strength level: %s", __FUNCTION__, status.getMessage());
-        return mapToStatusT(status);
-    }
-    return OK;
-}
-
-std::shared_ptr<aidl::android::hardware::camera::device::ICameraDevice>
-AidlProviderInfo::AidlDeviceInfo3::startDeviceInterface() {
-    Mutex::Autolock l(mDeviceAvailableLock);
-    std::shared_ptr<camera::device::ICameraDevice> device;
-    ATRACE_CALL();
-    if (mSavedInterface == nullptr) {
-        sp<AidlProviderInfo> parentProvider =
-                static_cast<AidlProviderInfo *>(mParentProvider.promote().get());
-        if (parentProvider != nullptr) {
-            // Wait for lazy HALs to confirm device availability
-            if (parentProvider->isExternalLazyHAL() && !mIsDeviceAvailable) {
-                ALOGV("%s: Wait for external device to become available %s",
-                      __FUNCTION__,
-                      mId.c_str());
-
-                auto res = mDeviceAvailableSignal.waitRelative(mDeviceAvailableLock,
-                                                         kDeviceAvailableTimeout);
-                if (res != OK) {
-                    ALOGE("%s: Failed waiting for device to become available",
-                          __FUNCTION__);
-                    return nullptr;
-                }
-            }
-
-            device = parentProvider->startDeviceInterface(mName);
-        }
-    } else {
-        device = mSavedInterface;
-    }
-    return device;
-}
-
-status_t AidlProviderInfo::AidlDeviceInfo3::dumpState(int fd) {
-    const std::shared_ptr<camera::device::ICameraDevice> interface = startDeviceInterface();
-    if (interface == nullptr) {
-        return DEAD_OBJECT;
-    }
-    const char *args = nullptr;
-    auto ret = interface->dump(fd, &args, /*numArgs*/0);
-    if (ret != OK) {
-        return ret;
-    }
-    return OK;
-}
-
-status_t AidlProviderInfo::AidlDeviceInfo3::isSessionConfigurationSupported(
-        const SessionConfiguration &configuration, bool overrideForPerfClass,
-        camera3::metadataGetter getMetadata, bool *status) {
-
-    camera::device::StreamConfiguration streamConfiguration;
-    bool earlyExit = false;
-    auto bRes = SessionConfigurationUtils::convertToHALStreamCombination(configuration,
-            String8(mId.c_str()), mCameraCharacteristics, getMetadata, mPhysicalIds,
-            streamConfiguration, overrideForPerfClass, &earlyExit);
-
-    if (!bRes.isOk()) {
-        return UNKNOWN_ERROR;
-    }
-
-    if (earlyExit) {
-        *status = false;
-        return OK;
-    }
-
-    const std::shared_ptr<camera::device::ICameraDevice> interface =
-            startDeviceInterface();
-
-    if (interface == nullptr) {
-        return DEAD_OBJECT;
-    }
-
-    ::ndk::ScopedAStatus ret =
-        interface->isStreamCombinationSupported(streamConfiguration, status);
-    if (!ret.isOk()) {
-        *status = false;
-        ALOGE("%s: Unexpected binder error: %s", __FUNCTION__, ret.getMessage());
-        return mapToStatusT(ret);
-    }
-    return OK;
-
-}
-
-status_t AidlProviderInfo::convertToAidlHALStreamCombinationAndCameraIdsLocked(
-        const std::vector<CameraIdAndSessionConfiguration> &cameraIdsAndSessionConfigs,
-        const std::set<std::string>& perfClassPrimaryCameraIds,
-        int targetSdkVersion,
-        std::vector<camera::provider::CameraIdAndStreamCombination>
-                *halCameraIdsAndStreamCombinations,
-        bool *earlyExit) {
-    binder::Status bStatus = binder::Status::ok();
-    std::vector<camera::provider::CameraIdAndStreamCombination> halCameraIdsAndStreamsV;
-    bool shouldExit = false;
-    status_t res = OK;
-    for (auto &cameraIdAndSessionConfig : cameraIdsAndSessionConfigs) {
-        const std::string& cameraId = cameraIdAndSessionConfig.mCameraId;
-        camera::device::StreamConfiguration streamConfiguration;
-        CameraMetadata deviceInfo;
-        bool overrideForPerfClass =
-                SessionConfigurationUtils::targetPerfClassPrimaryCamera(
-                        perfClassPrimaryCameraIds, cameraId, targetSdkVersion);
-        res = mManager->getCameraCharacteristicsLocked(cameraId, overrideForPerfClass, &deviceInfo);
-        if (res != OK) {
-            return res;
-        }
-        camera3::metadataGetter getMetadata =
-                [this](const String8 &id, bool overrideForPerfClass) {
-                    CameraMetadata physicalDeviceInfo;
-                    mManager->getCameraCharacteristicsLocked(id.string(), overrideForPerfClass,
-                                                   &physicalDeviceInfo);
-                    return physicalDeviceInfo;
-                };
-        std::vector<std::string> physicalCameraIds;
-        mManager->isLogicalCameraLocked(cameraId, &physicalCameraIds);
-        bStatus =
-            SessionConfigurationUtils::convertToHALStreamCombination(
-                    cameraIdAndSessionConfig.mSessionConfiguration,
-                    String8(cameraId.c_str()), deviceInfo, getMetadata,
-                    physicalCameraIds, streamConfiguration,
-                    overrideForPerfClass, &shouldExit);
-        if (!bStatus.isOk()) {
-            ALOGE("%s: convertToHALStreamCombination failed", __FUNCTION__);
-            return INVALID_OPERATION;
-        }
-        if (shouldExit) {
-            *earlyExit = true;
-            return OK;
-        }
-        camera::provider::CameraIdAndStreamCombination halCameraIdAndStream;
-        halCameraIdAndStream.cameraId = cameraId;
-        halCameraIdAndStream.streamConfiguration = streamConfiguration;
-        halCameraIdsAndStreamsV.push_back(halCameraIdAndStream);
-    }
-    *halCameraIdsAndStreamCombinations = halCameraIdsAndStreamsV;
-    return OK;
-}
-
-status_t AidlProviderInfo::isConcurrentSessionConfigurationSupported(
-        const std::vector<CameraIdAndSessionConfiguration> &cameraIdsAndSessionConfigs,
-        const std::set<std::string>& perfClassPrimaryCameraIds,
-        int targetSdkVersion, bool *isSupported) {
-
-      std::vector<camera::provider::CameraIdAndStreamCombination> halCameraIdsAndStreamCombinations;
-      bool knowUnsupported = false;
-      status_t res = convertToAidlHALStreamCombinationAndCameraIdsLocked(
-              cameraIdsAndSessionConfigs, perfClassPrimaryCameraIds,
-              targetSdkVersion, &halCameraIdsAndStreamCombinations, &knowUnsupported);
-      if (res != OK) {
-          ALOGE("%s unable to convert session configurations provided to HAL stream"
-                "combinations", __FUNCTION__);
-          return res;
-      }
-      if (knowUnsupported) {
-          // We got to know the streams aren't valid before doing the HAL
-          // call itself.
-          *isSupported = false;
-          return OK;
-      }
-
-      // Check if the provider is currently active - not going to start it up for this notification
-      auto interface = mSavedInterface != nullptr ? mSavedInterface : mActiveInterface.lock();
-      if (interface == nullptr) {
-          // TODO: This might be some other problem
-          return INVALID_OPERATION;
-      }
-      ::ndk::ScopedAStatus status = interface->isConcurrentStreamCombinationSupported(
-              halCameraIdsAndStreamCombinations, isSupported);
-      if (!status.isOk()) {
-          *isSupported = false;
-          ALOGE("%s: hal interface session configuration query failed", __FUNCTION__);
-          return mapToStatusT(status);
-      }
-
-    return OK;
-}
-
-} //namespace android
diff --git a/services/camera/libcameraservice/common/aidl/AidlProviderInfo.h b/services/camera/libcameraservice/common/aidl/AidlProviderInfo.h
deleted file mode 100644
index 97a8fed521..0000000000
--- a/services/camera/libcameraservice/common/aidl/AidlProviderInfo.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SERVERS_CAMERA_CAMERAPROVIDER_AIDLPROVIDERINFOH
-#define ANDROID_SERVERS_CAMERA_CAMERAPROVIDER_AIDLPROVIDERINFOH
-
-#include "common/CameraProviderManager.h"
-
-#include <aidl/android/hardware/camera/common/Status.h>
-#include <aidl/android/hardware/camera/provider/BnCameraProviderCallback.h>
-#include <aidl/android/hardware/camera/device/ICameraDevice.h>
-
-namespace android {
-
-struct AidlProviderInfo : public CameraProviderManager::ProviderInfo {
-    // Current overall Android device physical status
-    int64_t mDeviceState;
-
-    // This pointer is used to keep a reference to the ICameraProvider that was last accessed.
-    std::weak_ptr<aidl::android::hardware::camera::provider::ICameraProvider> mActiveInterface;
-
-    std::shared_ptr<aidl::android::hardware::camera::provider::ICameraProvider> mSavedInterface;
-
-    AidlProviderInfo(
-            const std::string &providerName,
-            const std::string &providerInstance,
-            CameraProviderManager *manager);
-
-    static status_t mapToStatusT(const ndk::ScopedAStatus& s);
-
-    // Start camera device interface, start the camera provider process for lazy
-    // hals, if needed
-    status_t initializeAidlProvider(
-        std::shared_ptr<aidl::android::hardware::camera::provider::ICameraProvider>& interface,
-        int64_t currentDeviceState);
-
-    static void binderDied(void *cookie);
-
-    virtual IPCTransport getIPCTransport() override {return IPCTransport::AIDL;}
-
-    const std::shared_ptr<aidl::android::hardware::camera::provider::ICameraProvider>
-    startProviderInterface();
-
-    virtual status_t setUpVendorTags() override;
-    virtual status_t notifyDeviceStateChange(int64_t newDeviceState) override;
-
-    virtual bool successfullyStartedProviderInterface() override;
-
-    virtual int64_t getDeviceState() override { return mDeviceState; };
-
-    /**
-     * Query the camera provider for concurrent stream configuration support
-     */
-    virtual status_t isConcurrentSessionConfigurationSupported(
-        const std::vector<CameraIdAndSessionConfiguration> &cameraIdsAndSessionConfigs,
-        const std::set<std::string>& perfClassPrimaryCameraIds,
-        int targetSdkVersion, bool *isSupported) override;
-
-    std::shared_ptr<aidl::android::hardware::camera::device::ICameraDevice>
-            startDeviceInterface(const std::string &deviceName);
-
-    // AIDL ICameraProviderCallback interface - these lock the parent
-    // mInterfaceMutex
-
-    ::ndk::ScopedAStatus cameraDeviceStatusChange(const std::string& cameraDeviceName,
-            ::aidl::android::hardware::camera::common::CameraDeviceStatus newStatus);
-
-    ::ndk::ScopedAStatus torchModeStatusChange(const std::string& cameraDeviceName,
-            ::aidl::android::hardware::camera::common::TorchModeStatus newStatus);
-
-    ::ndk::ScopedAStatus physicalCameraDeviceStatusChange(
-            const std::string& cameraDeviceName,
-            const std::string& physicalCameraDeviceName,
-            ::aidl::android::hardware::camera::common::CameraDeviceStatus newStatus);
-
-    struct AidlProviderCallbacks :
-            public aidl::android::hardware::camera::provider::BnCameraProviderCallback {
-        AidlProviderCallbacks(wp<AidlProviderInfo> parent) : mParent(parent) { }
-        virtual ::ndk::ScopedAStatus cameraDeviceStatusChange(const std::string& cameraDeviceName,
-                ::aidl::android::hardware::camera::common::CameraDeviceStatus newStatus) override;
-
-        virtual ::ndk::ScopedAStatus torchModeStatusChange(const std::string& cameraDeviceName,
-                ::aidl::android::hardware::camera::common::TorchModeStatus newStatus) override;
-
-        virtual ::ndk::ScopedAStatus physicalCameraDeviceStatusChange(
-                const std::string& cameraDeviceName,
-                const std::string& physicalCameraDeviceName,
-                ::aidl::android::hardware::camera::common::CameraDeviceStatus newStatus) override;
-
-       private:
-        wp<AidlProviderInfo> mParent = nullptr;
-
-    };
-
-    struct AidlDeviceInfo3 : public CameraProviderManager::ProviderInfo::DeviceInfo3 {
-
-        //TODO: fix init
-        const hardware::hidl_version mVersion = hardware::hidl_version{3, 2};
-        std::shared_ptr<aidl::android::hardware::camera::device::ICameraDevice>
-                mSavedInterface = nullptr;
-
-        AidlDeviceInfo3(const std::string& , const metadata_vendor_id_t ,
-                const std::string &, uint16_t ,
-                const CameraResourceCost& ,
-                sp<ProviderInfo> ,
-                const std::vector<std::string>& ,
-                std::shared_ptr<aidl::android::hardware::camera::device::ICameraDevice>);
-
-        ~AidlDeviceInfo3() {}
-
-        virtual status_t setTorchMode(bool enabled) override;
-        virtual status_t turnOnTorchWithStrengthLevel(int32_t torchStrength) override;
-        virtual status_t getTorchStrengthLevel(int32_t *torchStrength) override;
-
-        virtual status_t dumpState(int fd) override;
-
-        virtual status_t isSessionConfigurationSupported(
-                const SessionConfiguration &/*configuration*/,
-                bool overrideForPerfClass, camera3::metadataGetter /*getMetadata*/,
-                bool *status/*status*/);
-
-        std::shared_ptr<aidl::android::hardware::camera::device::ICameraDevice>
-                startDeviceInterface();
-    };
-
- private:
-
-    // Helper for initializeDeviceInfo to use the right CameraProvider get method.
-    virtual std::unique_ptr<DeviceInfo> initializeDeviceInfo(const std::string &,
-            const metadata_vendor_id_t , const std::string &,
-            uint16_t ) override;
-
-    virtual status_t reCacheConcurrentStreamingCameraIdsLocked() override;
-
-    //Expects to have mLock locked
-
-    status_t getConcurrentCameraIdsInternalLocked(
-        std::shared_ptr<aidl::android::hardware::camera::provider::ICameraProvider> &interface);
-
-    //expects to have mManager->mInterfaceMutex locked
-
-    status_t convertToAidlHALStreamCombinationAndCameraIdsLocked(
-        const std::vector<CameraIdAndSessionConfiguration> &cameraIdsAndSessionConfigs,
-        const std::set<std::string>& perfClassPrimaryCameraIds,
-        int targetSdkVersion,
-        std::vector<aidl::android::hardware::camera::provider::CameraIdAndStreamCombination>
-                *halCameraIdsAndStreamCombinations,
-        bool *earlyExit);
-    std::shared_ptr<AidlProviderCallbacks> mCallbacks = nullptr;
-    ndk::ScopedAIBinder_DeathRecipient mDeathRecipient;
-
-};
-
-} // namespace android
-#endif
diff --git a/services/camera/libcameraservice/common/hidl/HidlProviderInfo.cpp b/services/camera/libcameraservice/common/hidl/HidlProviderInfo.cpp
deleted file mode 100644
index bded9aafec..0000000000
--- a/services/camera/libcameraservice/common/hidl/HidlProviderInfo.cpp
+++ /dev/null
@@ -1,1050 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "HidlProviderInfo.h"
-#include "common/HalConversionsTemplated.h"
-#include "common/CameraProviderInfoTemplated.h"
-
-#include <cutils/properties.h>
-
-#include <android/hardware/ICameraService.h>
-#include <camera_metadata_hidden.h>
-
-#include "device3/ZoomRatioMapper.h"
-#include <utils/SessionConfigurationUtilsHidl.h>
-#include <utils/Trace.h>
-
-#include <android/hardware/camera/device/3.7/ICameraDevice.h>
-
-namespace {
-const bool kEnableLazyHal(property_get_bool("ro.camera.enableLazyHal", false));
-} // anonymous namespace
-
-namespace android {
-
-using namespace android::camera3;
-using namespace hardware::camera;
-using hardware::camera::common::V1_0::VendorTagSection;
-using hardware::camera::common::V1_0::Status;
-using hardware::camera::provider::V2_7::CameraIdAndStreamCombination;
-using hardware::camera2::utils::CameraIdAndSessionConfiguration;
-
-
-using StatusListener = CameraProviderManager::StatusListener;
-using HalDeviceStatusType = android::hardware::camera::common::V1_0::CameraDeviceStatus;
-
-using hardware::camera::provider::V2_5::DeviceState;
-using hardware::ICameraService;
-
-status_t HidlProviderInfo::mapToStatusT(const Status& s)  {
-    switch(s) {
-        case Status::OK:
-            return OK;
-        case Status::ILLEGAL_ARGUMENT:
-            return BAD_VALUE;
-        case Status::CAMERA_IN_USE:
-            return -EBUSY;
-        case Status::MAX_CAMERAS_IN_USE:
-            return -EUSERS;
-        case Status::METHOD_NOT_SUPPORTED:
-            return UNKNOWN_TRANSACTION;
-        case Status::OPERATION_NOT_SUPPORTED:
-            return INVALID_OPERATION;
-        case Status::CAMERA_DISCONNECTED:
-            return DEAD_OBJECT;
-        case Status::INTERNAL_ERROR:
-            return INVALID_OPERATION;
-    }
-    ALOGW("Unexpected HAL status code %d", s);
-    return INVALID_OPERATION;
-}
-
-static hardware::hidl_bitfield<DeviceState> mapToHidlDeviceState(int64_t newState) {
-    hardware::hidl_bitfield<DeviceState> newDeviceState{};
-    if (newState & ICameraService::DEVICE_STATE_BACK_COVERED) {
-        newDeviceState |= DeviceState::BACK_COVERED;
-    }
-    if (newState & ICameraService::DEVICE_STATE_FRONT_COVERED) {
-        newDeviceState |= DeviceState::FRONT_COVERED;
-    }
-    if (newState & ICameraService::DEVICE_STATE_FOLDED) {
-        newDeviceState |= DeviceState::FOLDED;
-    }
-    // Only map vendor bits directly
-    uint64_t vendorBits = static_cast<uint64_t>(newState) & 0xFFFFFFFF00000000l;
-    newDeviceState |= vendorBits;
-
-    ALOGV("%s: New device state 0x%" PRIx64, __FUNCTION__, newDeviceState);
-    return newDeviceState;
-}
-
-const char* statusToString(const Status& s) {
-    switch(s) {
-        case Status::OK:
-            return "OK";
-        case Status::ILLEGAL_ARGUMENT:
-            return "ILLEGAL_ARGUMENT";
-        case Status::CAMERA_IN_USE:
-            return "CAMERA_IN_USE";
-        case Status::MAX_CAMERAS_IN_USE:
-            return "MAX_CAMERAS_IN_USE";
-        case Status::METHOD_NOT_SUPPORTED:
-            return "METHOD_NOT_SUPPORTED";
-        case Status::OPERATION_NOT_SUPPORTED:
-            return "OPERATION_NOT_SUPPORTED";
-        case Status::CAMERA_DISCONNECTED:
-            return "CAMERA_DISCONNECTED";
-        case Status::INTERNAL_ERROR:
-            return "INTERNAL_ERROR";
-    }
-    ALOGW("Unexpected HAL status code %d", s);
-    return "UNKNOWN_ERROR";
-}
-
-status_t HidlProviderInfo::initializeHidlProvider(
-        sp<provider::V2_4::ICameraProvider>& interface,
-        int64_t currentDeviceState) {
-    status_t res = parseProviderName(mProviderName, &mType, &mId);
-    if (res != OK) {
-        ALOGE("%s: Invalid provider name, ignoring", __FUNCTION__);
-        return BAD_VALUE;
-    }
-    ALOGI("Connecting to new camera provider: %s, isRemote? %d",
-            mProviderName.c_str(), interface->isRemote());
-
-    // Determine minor version
-    mMinorVersion = 4;
-    auto cast2_6 = provider::V2_6::ICameraProvider::castFrom(interface);
-    sp<provider::V2_6::ICameraProvider> interface2_6 = nullptr;
-    if (cast2_6.isOk()) {
-        interface2_6 = cast2_6;
-        if (interface2_6 != nullptr) {
-            mMinorVersion = 6;
-        }
-    }
-    // We need to check again since cast2_6.isOk() succeeds even if the provider
-    // version isn't actually 2.6.
-    if (interface2_6 == nullptr){
-        auto cast2_5 =
-                provider::V2_5::ICameraProvider::castFrom(interface);
-        sp<provider::V2_5::ICameraProvider> interface2_5 = nullptr;
-        if (cast2_5.isOk()) {
-            interface2_5 = cast2_5;
-            if (interface != nullptr) {
-                mMinorVersion = 5;
-            }
-        }
-    } else {
-        auto cast2_7 = provider::V2_7::ICameraProvider::castFrom(interface);
-        if (cast2_7.isOk()) {
-            sp<provider::V2_7::ICameraProvider> interface2_7 = cast2_7;
-            if (interface2_7 != nullptr) {
-                mMinorVersion = 7;
-            }
-        }
-    }
-
-    // cameraDeviceStatusChange callbacks may be called (and causing new devices added)
-    // before setCallback returns
-    hardware::Return<Status> status = interface->setCallback(this);
-    if (!status.isOk()) {
-        ALOGE("%s: Transaction error setting up callbacks with camera provider '%s': %s",
-                __FUNCTION__, mProviderName.c_str(), status.description().c_str());
-        return DEAD_OBJECT;
-    }
-    if (status != Status::OK) {
-        ALOGE("%s: Unable to register callbacks with camera provider '%s'",
-                __FUNCTION__, mProviderName.c_str());
-        return mapToStatusT(status);
-    }
-
-    hardware::Return<bool> linked = interface->linkToDeath(this, /*cookie*/ mId);
-    if (!linked.isOk()) {
-        ALOGE("%s: Transaction error in linking to camera provider '%s' death: %s",
-                __FUNCTION__, mProviderName.c_str(), linked.description().c_str());
-        return DEAD_OBJECT;
-    } else if (!linked) {
-        ALOGW("%s: Unable to link to provider '%s' death notifications",
-                __FUNCTION__, mProviderName.c_str());
-    }
-
-    if (!kEnableLazyHal) {
-        // Save HAL reference indefinitely
-        mSavedInterface = interface;
-    } else {
-        mActiveInterface = interface;
-    }
-
-    ALOGV("%s: Setting device state for %s: 0x%" PRIx64,
-            __FUNCTION__, mProviderName.c_str(), mDeviceState);
-    notifyDeviceStateChange(currentDeviceState);
-
-    res = setUpVendorTags();
-    if (res != OK) {
-        ALOGE("%s: Unable to set up vendor tags from provider '%s'",
-                __FUNCTION__, mProviderName.c_str());
-        return res;
-    }
-
-    // Get initial list of camera devices, if any
-    std::vector<std::string> devices;
-    hardware::Return<void> ret = interface->getCameraIdList([&status, this, &devices](
-            Status idStatus,
-            const hardware::hidl_vec<hardware::hidl_string>& cameraDeviceNames) {
-        status = idStatus;
-        if (status == Status::OK) {
-            for (auto& name : cameraDeviceNames) {
-                uint16_t major, minor;
-                std::string type, id;
-                status_t res = parseDeviceName(name, &major, &minor, &type, &id);
-                if (res != OK) {
-                    ALOGE("%s: Error parsing deviceName: %s: %d", __FUNCTION__, name.c_str(), res);
-                    status = Status::INTERNAL_ERROR;
-                } else {
-                    devices.push_back(name);
-                    mProviderPublicCameraIds.push_back(id);
-                }
-            }
-        } });
-    if (!ret.isOk()) {
-        ALOGE("%s: Transaction error in getting camera ID list from provider '%s': %s",
-                __FUNCTION__, mProviderName.c_str(), linked.description().c_str());
-        return DEAD_OBJECT;
-    }
-    if (status != Status::OK) {
-        ALOGE("%s: Unable to query for camera devices from provider '%s'",
-                __FUNCTION__, mProviderName.c_str());
-        return mapToStatusT(status);
-    }
-
-    // Get list of concurrent streaming camera device combinations
-    if (mMinorVersion >= 6) {
-        res = getConcurrentCameraIdsInternalLocked(interface2_6);
-        if (res != OK) {
-            return res;
-        }
-    }
-
-    ret = interface->isSetTorchModeSupported(
-        [this](auto status, bool supported) {
-            if (status == Status::OK) {
-                mSetTorchModeSupported = supported;
-            }
-        });
-    if (!ret.isOk()) {
-        ALOGE("%s: Transaction error checking torch mode support '%s': %s",
-                __FUNCTION__, mProviderName.c_str(), ret.description().c_str());
-        return DEAD_OBJECT;
-    }
-
-    mIsRemote = interface->isRemote();
-
-    initializeProviderInfoCommon(devices);
-
-    return OK;
-}
-
-status_t HidlProviderInfo::setUpVendorTags() {
-    if (mVendorTagDescriptor != nullptr)
-        return OK;
-
-    hardware::hidl_vec<VendorTagSection> vts;
-    Status status;
-    hardware::Return<void> ret;
-    const sp<hardware::camera::provider::V2_4::ICameraProvider> interface =
-            startProviderInterface();
-    if (interface == nullptr) {
-        return DEAD_OBJECT;
-    }
-    ret = interface->getVendorTags(
-        [&](auto s, const auto& vendorTagSecs) {
-            status = s;
-            if (s == Status::OK) {
-                vts = vendorTagSecs;
-            }
-    });
-    if (!ret.isOk()) {
-        ALOGE("%s: Transaction error getting vendor tags from provider '%s': %s",
-                __FUNCTION__, mProviderName.c_str(), ret.description().c_str());
-        return DEAD_OBJECT;
-    }
-    if (status != Status::OK) {
-        return mapToStatusT(status);
-    }
-
-    // Read all vendor tag definitions into a descriptor
-    status_t res;
-    if ((res = IdlVendorTagDescriptor::createDescriptorFromIdl<
-                hardware::hidl_vec<hardware::camera::common::V1_0::VendorTagSection>,
-                        hardware::camera::common::V1_0::VendorTagSection>(vts,
-                                /*out*/mVendorTagDescriptor))
-            != OK) {
-        ALOGE("%s: Could not generate descriptor from vendor tag operations,"
-                "received error %s (%d). Camera clients will not be able to use"
-                "vendor tags", __FUNCTION__, strerror(res), res);
-        return res;
-    }
-
-    return OK;
-}
-
-status_t HidlProviderInfo::notifyDeviceStateChange(int64_t newDeviceState) {
-    mDeviceState = mapToHidlDeviceState(newDeviceState);
-    if (mMinorVersion >= 5) {
-        // Check if the provider is currently active - not going to start it for this notification
-        auto interface = mSavedInterface != nullptr ? mSavedInterface : mActiveInterface.promote();
-        if (interface != nullptr) {
-            // Send current device state
-            auto castResult = provider::V2_5::ICameraProvider::castFrom(interface);
-            if (castResult.isOk()) {
-                sp<provider::V2_5::ICameraProvider> interface_2_5 = castResult;
-                if (interface_2_5 != nullptr) {
-                    interface_2_5->notifyDeviceStateChange(mDeviceState);
-                }
-            }
-        }
-    }
-    return OK;
-}
-
-sp<device::V3_2::ICameraDevice>
-HidlProviderInfo::startDeviceInterface(const std::string &name) {
-    Status status;
-    sp<device::V3_2::ICameraDevice> cameraInterface;
-    hardware::Return<void> ret;
-    const sp<provider::V2_4::ICameraProvider> interface = startProviderInterface();
-    if (interface == nullptr) {
-        return nullptr;
-    }
-    ret = interface->getCameraDeviceInterface_V3_x(name, [&status, &cameraInterface](
-        Status s, sp<device::V3_2::ICameraDevice> interface) {
-                status = s;
-                cameraInterface = interface;
-            });
-    if (!ret.isOk()) {
-        ALOGE("%s: Transaction error trying to obtain interface for camera device %s: %s",
-                __FUNCTION__, name.c_str(), ret.description().c_str());
-        return nullptr;
-    }
-    if (status != Status::OK) {
-        ALOGE("%s: Unable to obtain interface for camera device %s: %s", __FUNCTION__,
-                name.c_str(), statusToString(status));
-        return nullptr;
-    }
-    return cameraInterface;
-}
-
-bool HidlProviderInfo::successfullyStartedProviderInterface() {
-    return startProviderInterface() != nullptr;
-}
-
-const sp<provider::V2_4::ICameraProvider>
-HidlProviderInfo::startProviderInterface() {
-    ATRACE_CALL();
-    ALOGV("Request to start camera provider: %s", mProviderName.c_str());
-    if (mSavedInterface != nullptr) {
-        return mSavedInterface;
-    }
-    if (!kEnableLazyHal) {
-        ALOGE("Bad provider state! Should not be here on a non-lazy HAL!");
-        return nullptr;
-    }
-
-    auto interface = mActiveInterface.promote();
-    if (interface == nullptr) {
-        // Try to get service without starting
-        interface = mManager->mHidlServiceProxy->tryGetService(mProviderName);
-        if (interface == nullptr) {
-            ALOGV("Camera provider actually needs restart, calling getService(%s)",
-                  mProviderName.c_str());
-            interface = mManager->mHidlServiceProxy->getService(mProviderName);
-
-            // Set all devices as ENUMERATING, provider should update status
-            // to PRESENT after initializing.
-            // This avoids failing getCameraDeviceInterface_V3_x before devices
-            // are ready.
-            for (auto& device : mDevices) {
-              device->mIsDeviceAvailable = false;
-            }
-
-            interface->setCallback(this);
-            hardware::Return<bool>
-                linked = interface->linkToDeath(this, /*cookie*/ mId);
-            if (!linked.isOk()) {
-              ALOGE(
-                  "%s: Transaction error in linking to camera provider '%s' death: %s",
-                  __FUNCTION__,
-                  mProviderName.c_str(),
-                  linked.description().c_str());
-              mManager->removeProvider(mProviderName);
-              return nullptr;
-            } else if (!linked) {
-              ALOGW("%s: Unable to link to provider '%s' death notifications",
-                    __FUNCTION__, mProviderName.c_str());
-            }
-            // Send current device state
-            if (mMinorVersion >= 5) {
-              auto castResult =
-                  provider::V2_5::ICameraProvider::castFrom(interface);
-              if (castResult.isOk()) {
-                sp<provider::V2_5::ICameraProvider> interface_2_5 = castResult;
-                if (interface_2_5 != nullptr) {
-                  ALOGV("%s: Initial device state for %s: 0x %" PRIx64,
-                        __FUNCTION__, mProviderName.c_str(), mDeviceState);
-                  interface_2_5->notifyDeviceStateChange(mDeviceState);
-                }
-              }
-            }
-        }
-        mActiveInterface = interface;
-    } else {
-        ALOGV("Camera provider (%s) already in use. Re-using instance.",
-              mProviderName.c_str());
-    }
-
-    return interface;
-}
-
-hardware::Return<void> HidlProviderInfo::cameraDeviceStatusChange(
-        const hardware::hidl_string& cameraDeviceName,
-        HalDeviceStatusType newStatus) {
-    cameraDeviceStatusChangeInternal(cameraDeviceName, HalToFrameworkCameraDeviceStatus(newStatus));
-    return hardware::Void();
-}
-
-hardware::Return<void> HidlProviderInfo::physicalCameraDeviceStatusChange(
-        const hardware::hidl_string& cameraDeviceName,
-        const hardware::hidl_string& physicalCameraDeviceName,
-        HalDeviceStatusType newStatus) {
-    physicalCameraDeviceStatusChangeInternal(cameraDeviceName, physicalCameraDeviceName,
-            HalToFrameworkCameraDeviceStatus(newStatus));
-    return hardware::Void();
-}
-
-hardware::Return<void> HidlProviderInfo::torchModeStatusChange(
-        const hardware::hidl_string& cameraDeviceName,
-        hardware::camera::common::V1_0::TorchModeStatus newStatus) {
-
-    torchModeStatusChangeInternal(cameraDeviceName, HalToFrameworkTorchModeStatus(newStatus));
-    return hardware::Void();
-}
-
-void HidlProviderInfo::serviceDied(uint64_t cookie,
-        const wp<hidl::base::V1_0::IBase>& who) {
-    (void) who;
-    ALOGI("Camera provider '%s' has died; removing it", mProviderInstance.c_str());
-    if (cookie != mId) {
-        ALOGW("%s: Unexpected serviceDied cookie %" PRIu64 ", expected %" PRIu32,
-                __FUNCTION__, cookie, mId);
-    }
-    mManager->removeProvider(mProviderInstance);
-}
-
-std::unique_ptr<CameraProviderManager::ProviderInfo::DeviceInfo>
-    HidlProviderInfo::initializeDeviceInfo(
-        const std::string &name, const metadata_vendor_id_t tagId,
-        const std::string &id, uint16_t minorVersion) {
-    Status status;
-
-    auto cameraInterface = startDeviceInterface(name);
-    if (cameraInterface == nullptr) return nullptr;
-
-    common::V1_0::CameraResourceCost resourceCost;
-    cameraInterface->getResourceCost([&status, &resourceCost](
-        Status s, common::V1_0::CameraResourceCost cost) {
-                status = s;
-                resourceCost = cost;
-            });
-    if (status != Status::OK) {
-        ALOGE("%s: Unable to obtain resource costs for camera device %s: %s", __FUNCTION__,
-                name.c_str(), statusToString(status));
-        return nullptr;
-    }
-
-    for (auto& conflictName : resourceCost.conflictingDevices) {
-        uint16_t major, minor;
-        std::string type, id;
-        status_t res = parseDeviceName(conflictName, &major, &minor, &type, &id);
-        if (res != OK) {
-            ALOGE("%s: Failed to parse conflicting device %s", __FUNCTION__, conflictName.c_str());
-            return nullptr;
-        }
-        conflictName = id;
-    }
-
-    return std::unique_ptr<DeviceInfo3>(
-        new HidlDeviceInfo3(name, tagId, id, minorVersion, HalToFrameworkResourceCost(resourceCost),
-                this, mProviderPublicCameraIds, cameraInterface));
-}
-
-status_t HidlProviderInfo::reCacheConcurrentStreamingCameraIdsLocked() {
-    if (mMinorVersion < 6) {
-      // Unsupported operation, nothing to do here
-      return OK;
-    }
-    // Check if the provider is currently active - not going to start it up for this notification
-    auto interface = mSavedInterface != nullptr ? mSavedInterface : mActiveInterface.promote();
-    if (interface == nullptr) {
-        ALOGE("%s: camera provider interface for %s is not valid", __FUNCTION__,
-                mProviderName.c_str());
-        return INVALID_OPERATION;
-    }
-    auto castResult = provider::V2_6::ICameraProvider::castFrom(interface);
-
-    if (castResult.isOk()) {
-        sp<provider::V2_6::ICameraProvider> interface2_6 = castResult;
-        if (interface2_6 != nullptr) {
-            return getConcurrentCameraIdsInternalLocked(interface2_6);
-        } else {
-            // This should not happen since mMinorVersion >= 6
-            ALOGE("%s: mMinorVersion was >= 6, but interface2_6 was nullptr", __FUNCTION__);
-            return UNKNOWN_ERROR;
-        }
-    }
-    return OK;
-}
-
-status_t HidlProviderInfo::getConcurrentCameraIdsInternalLocked(
-        sp<provider::V2_6::ICameraProvider> &interface2_6) {
-    if (interface2_6 == nullptr) {
-        ALOGE("%s: null interface provided", __FUNCTION__);
-        return BAD_VALUE;
-    }
-    Status status = Status::OK;
-    hardware::Return<void> ret =
-            interface2_6->getConcurrentStreamingCameraIds([&status, this](
-            Status concurrentIdStatus, // TODO: Move all instances of hidl_string to 'using'
-            const hardware::hidl_vec<hardware::hidl_vec<hardware::hidl_string>>&
-                        cameraDeviceIdCombinations) {
-            status = concurrentIdStatus;
-            if (status == Status::OK) {
-                mConcurrentCameraIdCombinations.clear();
-                for (auto& combination : cameraDeviceIdCombinations) {
-                    std::unordered_set<std::string> deviceIds;
-                    for (auto &cameraDeviceId : combination) {
-                        deviceIds.insert(cameraDeviceId.c_str());
-                    }
-                    mConcurrentCameraIdCombinations.push_back(std::move(deviceIds));
-                }
-            } });
-    if (!ret.isOk()) {
-        ALOGE("%s: Transaction error in getting concurrent camera ID list from provider '%s'",
-                __FUNCTION__, mProviderName.c_str());
-            return DEAD_OBJECT;
-    }
-    if (status != Status::OK) {
-        ALOGE("%s: Unable to query for camera devices from provider '%s'",
-                    __FUNCTION__, mProviderName.c_str());
-        return mapToStatusT(status);
-    }
-    return OK;
-}
-
-HidlProviderInfo::HidlDeviceInfo3::HidlDeviceInfo3(
-        const std::string& name,
-        const metadata_vendor_id_t tagId,
-        const std::string &id, uint16_t minorVersion,
-        const CameraResourceCost& resourceCost,
-        sp<CameraProviderManager::ProviderInfo> parentProvider,
-        const std::vector<std::string>& publicCameraIds,
-        sp<hardware::camera::device::V3_2::ICameraDevice> interface) :
-        DeviceInfo3(name, tagId, id, minorVersion, resourceCost, parentProvider, publicCameraIds) {
-
-    // Get camera characteristics and initialize flash unit availability
-    Status status;
-    hardware::Return<void> ret;
-    ret = interface->getCameraCharacteristics([&status, this](Status s,
-                    device::V3_2::CameraMetadata metadata) {
-                status = s;
-                if (s == Status::OK) {
-                    camera_metadata_t *buffer =
-                            reinterpret_cast<camera_metadata_t*>(metadata.data());
-                    size_t expectedSize = metadata.size();
-                    int res = validate_camera_metadata_structure(buffer, &expectedSize);
-                    if (res == OK || res == CAMERA_METADATA_VALIDATION_SHIFTED) {
-                        set_camera_metadata_vendor_id(buffer, mProviderTagid);
-                        mCameraCharacteristics = buffer;
-                    } else {
-                        ALOGE("%s: Malformed camera metadata received from HAL", __FUNCTION__);
-                        status = Status::INTERNAL_ERROR;
-                    }
-                }
-            });
-    if (!ret.isOk()) {
-        ALOGE("%s: Transaction error getting camera characteristics for device %s"
-                " to check for a flash unit: %s", __FUNCTION__, id.c_str(),
-                ret.description().c_str());
-        return;
-    }
-    if (status != Status::OK) {
-        ALOGE("%s: Unable to get camera characteristics for device %s: %s (%d)",
-                __FUNCTION__, id.c_str(), statusToString(status), status);
-        return;
-    }
-
-    if (mCameraCharacteristics.exists(ANDROID_INFO_DEVICE_STATE_ORIENTATIONS)) {
-        const auto &stateMap = mCameraCharacteristics.find(ANDROID_INFO_DEVICE_STATE_ORIENTATIONS);
-        if ((stateMap.count > 0) && ((stateMap.count % 2) == 0)) {
-            for (size_t i = 0; i < stateMap.count; i += 2) {
-                mDeviceStateOrientationMap.emplace(stateMap.data.i64[i], stateMap.data.i64[i+1]);
-            }
-        } else {
-            ALOGW("%s: Invalid ANDROID_INFO_DEVICE_STATE_ORIENTATIONS map size: %zu", __FUNCTION__,
-                    stateMap.count);
-        }
-    }
-
-    mSystemCameraKind = getSystemCameraKind();
-
-    status_t res = fixupMonochromeTags();
-    if (OK != res) {
-        ALOGE("%s: Unable to fix up monochrome tags based for older HAL version: %s (%d)",
-                __FUNCTION__, strerror(-res), res);
-        return;
-    }
-    auto stat = addDynamicDepthTags();
-    if (OK != stat) {
-        ALOGE("%s: Failed appending dynamic depth tags: %s (%d)", __FUNCTION__, strerror(-stat),
-                stat);
-    }
-    res = deriveHeicTags();
-    if (OK != res) {
-        ALOGE("%s: Unable to derive HEIC tags based on camera and media capabilities: %s (%d)",
-                __FUNCTION__, strerror(-res), res);
-    }
-
-    if (SessionConfigurationUtils::isUltraHighResolutionSensor(mCameraCharacteristics)) {
-        status_t status = addDynamicDepthTags(/*maxResolution*/true);
-        if (OK != status) {
-            ALOGE("%s: Failed appending dynamic depth tags for maximum resolution mode: %s (%d)",
-                    __FUNCTION__, strerror(-status), status);
-        }
-
-        status = deriveHeicTags(/*maxResolution*/true);
-        if (OK != status) {
-            ALOGE("%s: Unable to derive HEIC tags based on camera and media capabilities for"
-                    "maximum resolution mode: %s (%d)", __FUNCTION__, strerror(-status), status);
-        }
-    }
-
-    res = addRotateCropTags();
-    if (OK != res) {
-        ALOGE("%s: Unable to add default SCALER_ROTATE_AND_CROP tags: %s (%d)", __FUNCTION__,
-                strerror(-res), res);
-    }
-    res = addPreCorrectionActiveArraySize();
-    if (OK != res) {
-        ALOGE("%s: Unable to add PRE_CORRECTION_ACTIVE_ARRAY_SIZE: %s (%d)", __FUNCTION__,
-                strerror(-res), res);
-    }
-    res = camera3::ZoomRatioMapper::overrideZoomRatioTags(
-            &mCameraCharacteristics, &mSupportNativeZoomRatio);
-    if (OK != res) {
-        ALOGE("%s: Unable to override zoomRatio related tags: %s (%d)",
-                __FUNCTION__, strerror(-res), res);
-    }
-
-    camera_metadata_entry flashAvailable =
-            mCameraCharacteristics.find(ANDROID_FLASH_INFO_AVAILABLE);
-    if (flashAvailable.count == 1 &&
-            flashAvailable.data.u8[0] == ANDROID_FLASH_INFO_AVAILABLE_TRUE) {
-        mHasFlashUnit = true;
-        // Fix up flash strength tags for devices without these keys.
-        res = fixupTorchStrengthTags();
-        if (OK != res) {
-            ALOGE("%s: Unable to add default ANDROID_FLASH_INFO_STRENGTH_DEFAULT_LEVEL and"
-                    "ANDROID_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL tags: %s (%d)", __FUNCTION__,
-                    strerror(-res), res);
-        }
-    } else {
-        mHasFlashUnit = false;
-    }
-
-    camera_metadata_entry entry =
-            mCameraCharacteristics.find(ANDROID_FLASH_INFO_STRENGTH_DEFAULT_LEVEL);
-    if (entry.count == 1) {
-        mTorchDefaultStrengthLevel = entry.data.i32[0];
-    } else {
-        mTorchDefaultStrengthLevel = 0;
-    }
-    entry = mCameraCharacteristics.find(ANDROID_FLASH_INFO_STRENGTH_MAXIMUM_LEVEL);
-    if (entry.count == 1) {
-        mTorchMaximumStrengthLevel = entry.data.i32[0];
-    } else {
-        mTorchMaximumStrengthLevel = 0;
-    }
-
-    mTorchStrengthLevel = 0;
-
-    queryPhysicalCameraIds();
-
-    // Get physical camera characteristics if applicable
-    auto castResult = device::V3_5::ICameraDevice::castFrom(interface);
-    if (!castResult.isOk()) {
-        ALOGV("%s: Unable to convert ICameraDevice instance to version 3.5", __FUNCTION__);
-        return;
-    }
-    sp<device::V3_5::ICameraDevice> interface_3_5 = castResult;
-    if (interface_3_5 == nullptr) {
-        ALOGE("%s: Converted ICameraDevice instance to nullptr", __FUNCTION__);
-        return;
-    }
-
-    if (mIsLogicalCamera) {
-        for (auto& id : mPhysicalIds) {
-            if (std::find(mPublicCameraIds.begin(), mPublicCameraIds.end(), id) !=
-                    mPublicCameraIds.end()) {
-                continue;
-            }
-
-            hardware::hidl_string hidlId(id);
-            ret = interface_3_5->getPhysicalCameraCharacteristics(hidlId,
-                    [&status, &id, this](Status s, device::V3_2::CameraMetadata metadata) {
-                status = s;
-                if (s == Status::OK) {
-                    camera_metadata_t *buffer =
-                            reinterpret_cast<camera_metadata_t*>(metadata.data());
-                    size_t expectedSize = metadata.size();
-                    int res = validate_camera_metadata_structure(buffer, &expectedSize);
-                    if (res == OK || res == CAMERA_METADATA_VALIDATION_SHIFTED) {
-                        set_camera_metadata_vendor_id(buffer, mProviderTagid);
-                        mPhysicalCameraCharacteristics[id] = buffer;
-                    } else {
-                        ALOGE("%s: Malformed camera metadata received from HAL", __FUNCTION__);
-                        status = Status::INTERNAL_ERROR;
-                    }
-                }
-            });
-
-            if (!ret.isOk()) {
-                ALOGE("%s: Transaction error getting physical camera %s characteristics for %s: %s",
-                        __FUNCTION__, id.c_str(), id.c_str(), ret.description().c_str());
-                return;
-            }
-            if (status != Status::OK) {
-                ALOGE("%s: Unable to get physical camera %s characteristics for device %s: %s (%d)",
-                        __FUNCTION__, id.c_str(), mId.c_str(),
-                        statusToString(status), status);
-                return;
-            }
-
-            res = camera3::ZoomRatioMapper::overrideZoomRatioTags(
-                    &mPhysicalCameraCharacteristics[id], &mSupportNativeZoomRatio);
-            if (OK != res) {
-                ALOGE("%s: Unable to override zoomRatio related tags: %s (%d)",
-                        __FUNCTION__, strerror(-res), res);
-            }
-        }
-    }
-
-    if (!kEnableLazyHal) {
-        // Save HAL reference indefinitely
-        mSavedInterface = interface;
-    }
-
-
-}
-
-status_t HidlProviderInfo::HidlDeviceInfo3::setTorchMode(bool enabled) {
-    using hardware::camera::common::V1_0::TorchMode;
-    const sp<hardware::camera::device::V3_2::ICameraDevice> interface = startDeviceInterface();
-    Status s = interface->setTorchMode(enabled ? TorchMode::ON : TorchMode::OFF);
-    return mapToStatusT(s);
-}
-
-status_t HidlProviderInfo::HidlDeviceInfo3::turnOnTorchWithStrengthLevel(
-        int32_t /*torchStrengthLevel*/) {
-    ALOGE("%s HIDL does not support turning on torch with variable strength", __FUNCTION__);
-    return INVALID_OPERATION;
-}
-
-status_t HidlProviderInfo::HidlDeviceInfo3::getTorchStrengthLevel(int32_t * /*torchStrength*/) {
-    ALOGE("%s HIDL does not support variable torch strength level", __FUNCTION__);
-    return INVALID_OPERATION;
-}
-
-sp<hardware::camera::device::V3_2::ICameraDevice>
-HidlProviderInfo::HidlDeviceInfo3::startDeviceInterface() {
-    Mutex::Autolock l(mDeviceAvailableLock);
-    sp<hardware::camera::device::V3_2::ICameraDevice> device;
-    ATRACE_CALL();
-    if (mSavedInterface == nullptr) {
-        sp<HidlProviderInfo> parentProvider =
-                static_cast<HidlProviderInfo *>(mParentProvider.promote().get());
-        if (parentProvider != nullptr) {
-            // Wait for lazy HALs to confirm device availability
-            if (parentProvider->isExternalLazyHAL() && !mIsDeviceAvailable) {
-                ALOGV("%s: Wait for external device to become available %s",
-                      __FUNCTION__,
-                      mId.c_str());
-
-                auto res = mDeviceAvailableSignal.waitRelative(mDeviceAvailableLock,
-                                                         kDeviceAvailableTimeout);
-                if (res != OK) {
-                    ALOGE("%s: Failed waiting for device to become available",
-                          __FUNCTION__);
-                    return nullptr;
-                }
-            }
-
-            device = parentProvider->startDeviceInterface(mName);
-        }
-    } else {
-        device = (hardware::camera::device::V3_2::ICameraDevice *) mSavedInterface.get();
-    }
-    return device;
-}
-
-status_t HidlProviderInfo::HidlDeviceInfo3::dumpState(int fd) {
-    native_handle_t* handle = native_handle_create(1,0);
-    handle->data[0] = fd;
-    const sp<hardware::camera::device::V3_2::ICameraDevice> interface =
-            startDeviceInterface();
-    if (interface == nullptr) {
-        return DEAD_OBJECT;
-    }
-    auto ret = interface->dumpState(handle);
-    native_handle_delete(handle);
-    if (!ret.isOk()) {
-        return INVALID_OPERATION;
-    }
-    return OK;
-}
-
-status_t HidlProviderInfo::HidlDeviceInfo3::isSessionConfigurationSupported(
-        const SessionConfiguration &configuration, bool overrideForPerfClass,
-        metadataGetter getMetadata, bool *status) {
-
-    hardware::camera::device::V3_7::StreamConfiguration configuration_3_7;
-    bool earlyExit = false;
-    auto bRes = SessionConfigurationUtils::convertToHALStreamCombination(configuration,
-            String8(mId.c_str()), mCameraCharacteristics, getMetadata, mPhysicalIds,
-            configuration_3_7, overrideForPerfClass, &earlyExit);
-
-    if (!bRes.isOk()) {
-        return UNKNOWN_ERROR;
-    }
-
-    if (earlyExit) {
-        *status = false;
-        return OK;
-    }
-
-    const sp<hardware::camera::device::V3_2::ICameraDevice> interface =
-            startDeviceInterface();
-
-    if (interface == nullptr) {
-        return DEAD_OBJECT;
-    }
-
-    auto castResult_3_5 = device::V3_5::ICameraDevice::castFrom(interface);
-    sp<hardware::camera::device::V3_5::ICameraDevice> interface_3_5 = castResult_3_5;
-    auto castResult_3_7 = device::V3_7::ICameraDevice::castFrom(interface);
-    sp<hardware::camera::device::V3_7::ICameraDevice> interface_3_7 = castResult_3_7;
-
-    status_t res;
-    Status callStatus;
-    ::android::hardware::Return<void> ret;
-    auto halCb =
-            [&callStatus, &status] (Status s, bool combStatus) {
-                callStatus = s;
-                *status = combStatus;
-            };
-    if (interface_3_7 != nullptr) {
-        ret = interface_3_7->isStreamCombinationSupported_3_7(configuration_3_7, halCb);
-    } else if (interface_3_5 != nullptr) {
-        hardware::camera::device::V3_4::StreamConfiguration configuration_3_4;
-        bool success = SessionConfigurationUtils::convertHALStreamCombinationFromV37ToV34(
-                configuration_3_4, configuration_3_7);
-        if (!success) {
-            *status = false;
-            return OK;
-        }
-        ret = interface_3_5->isStreamCombinationSupported(configuration_3_4, halCb);
-    } else {
-        return INVALID_OPERATION;
-    }
-    if (ret.isOk()) {
-        switch (callStatus) {
-            case Status::OK:
-                // Expected case, do nothing.
-                res = OK;
-                break;
-            case Status::METHOD_NOT_SUPPORTED:
-                res = INVALID_OPERATION;
-                break;
-            default:
-                ALOGE("%s: Session configuration query failed: %d", __FUNCTION__, callStatus);
-                res = UNKNOWN_ERROR;
-        }
-    } else {
-        ALOGE("%s: Unexpected binder error: %s", __FUNCTION__, ret.description().c_str());
-        res = UNKNOWN_ERROR;
-    }
-
-    return res;
-}
-
-status_t HidlProviderInfo::convertToHALStreamCombinationAndCameraIdsLocked(
-        const std::vector<CameraIdAndSessionConfiguration> &cameraIdsAndSessionConfigs,
-        const std::set<std::string>& perfClassPrimaryCameraIds,
-        int targetSdkVersion,
-        hardware::hidl_vec<CameraIdAndStreamCombination> *halCameraIdsAndStreamCombinations,
-        bool *earlyExit) {
-    binder::Status bStatus = binder::Status::ok();
-    std::vector<CameraIdAndStreamCombination> halCameraIdsAndStreamsV;
-    bool shouldExit = false;
-    status_t res = OK;
-    for (auto &cameraIdAndSessionConfig : cameraIdsAndSessionConfigs) {
-        const std::string& cameraId = cameraIdAndSessionConfig.mCameraId;
-        hardware::camera::device::V3_7::StreamConfiguration streamConfiguration;
-        CameraMetadata deviceInfo;
-        bool overrideForPerfClass =
-                SessionConfigurationUtils::targetPerfClassPrimaryCamera(
-                        perfClassPrimaryCameraIds, cameraId, targetSdkVersion);
-        res = mManager->getCameraCharacteristicsLocked(cameraId, overrideForPerfClass, &deviceInfo);
-        if (res != OK) {
-            return res;
-        }
-        camera3::metadataGetter getMetadata =
-                [this](const String8 &id, bool overrideForPerfClass) {
-                    CameraMetadata physicalDeviceInfo;
-                    mManager->getCameraCharacteristicsLocked(id.string(), overrideForPerfClass,
-                                                   &physicalDeviceInfo);
-                    return physicalDeviceInfo;
-                };
-        std::vector<std::string> physicalCameraIds;
-        mManager->isLogicalCameraLocked(cameraId, &physicalCameraIds);
-        bStatus =
-            SessionConfigurationUtils::convertToHALStreamCombination(
-                    cameraIdAndSessionConfig.mSessionConfiguration,
-                    String8(cameraId.c_str()), deviceInfo, getMetadata,
-                    physicalCameraIds, streamConfiguration,
-                    overrideForPerfClass, &shouldExit);
-        if (!bStatus.isOk()) {
-            ALOGE("%s: convertToHALStreamCombination failed", __FUNCTION__);
-            return INVALID_OPERATION;
-        }
-        if (shouldExit) {
-            *earlyExit = true;
-            return OK;
-        }
-        CameraIdAndStreamCombination halCameraIdAndStream;
-        halCameraIdAndStream.cameraId = cameraId;
-        halCameraIdAndStream.streamConfiguration = streamConfiguration;
-        halCameraIdsAndStreamsV.push_back(halCameraIdAndStream);
-    }
-    *halCameraIdsAndStreamCombinations = halCameraIdsAndStreamsV;
-    return OK;
-}
-
-status_t HidlProviderInfo::isConcurrentSessionConfigurationSupported(
-        const std::vector<CameraIdAndSessionConfiguration> &cameraIdsAndSessionConfigs,
-        const std::set<std::string>& perfClassPrimaryCameraIds,
-        int targetSdkVersion, bool *isSupported) {
-
-      hardware::hidl_vec<CameraIdAndStreamCombination> halCameraIdsAndStreamCombinations;
-      bool knowUnsupported = false;
-      status_t res = convertToHALStreamCombinationAndCameraIdsLocked(
-              cameraIdsAndSessionConfigs, perfClassPrimaryCameraIds,
-              targetSdkVersion, &halCameraIdsAndStreamCombinations, &knowUnsupported);
-      if (res != OK) {
-          ALOGE("%s unable to convert session configurations provided to HAL stream"
-                "combinations", __FUNCTION__);
-          return res;
-      }
-      if (knowUnsupported) {
-          // We got to know the streams aren't valid before doing the HAL
-          // call itself.
-          *isSupported = false;
-          return OK;
-      }
-
-    if (mMinorVersion >= 6) {
-        // Check if the provider is currently active - not going to start it for this notification
-        auto interface = mSavedInterface != nullptr ? mSavedInterface : mActiveInterface.promote();
-        if (interface == nullptr) {
-            // TODO: This might be some other problem
-            return INVALID_OPERATION;
-        }
-        auto castResult2_6 = provider::V2_6::ICameraProvider::castFrom(interface);
-        auto castResult2_7 = provider::V2_7::ICameraProvider::castFrom(interface);
-        Status callStatus;
-        auto cb =
-                [&isSupported, &callStatus](Status s, bool supported) {
-                      callStatus = s;
-                      *isSupported = supported; };
-
-        ::android::hardware::Return<void> ret;
-        sp<provider::V2_7::ICameraProvider> interface_2_7;
-        sp<provider::V2_6::ICameraProvider> interface_2_6;
-        if (mMinorVersion >= 7 && castResult2_7.isOk()) {
-            interface_2_7 = castResult2_7;
-            if (interface_2_7 != nullptr) {
-                ret = interface_2_7->isConcurrentStreamCombinationSupported_2_7(
-                        halCameraIdsAndStreamCombinations, cb);
-            }
-        } else if (mMinorVersion == 6 && castResult2_6.isOk()) {
-            interface_2_6 = castResult2_6;
-            if (interface_2_6 != nullptr) {
-                hardware::hidl_vec<provider::V2_6::CameraIdAndStreamCombination>
-                        halCameraIdsAndStreamCombinations_2_6;
-                size_t numStreams = halCameraIdsAndStreamCombinations.size();
-                halCameraIdsAndStreamCombinations_2_6.resize(numStreams);
-                for (size_t i = 0; i < numStreams; i++) {
-                    using namespace camera3;
-                    auto const& combination = halCameraIdsAndStreamCombinations[i];
-                    halCameraIdsAndStreamCombinations_2_6[i].cameraId = combination.cameraId;
-                    bool success =
-                            SessionConfigurationUtils::convertHALStreamCombinationFromV37ToV34(
-                                    halCameraIdsAndStreamCombinations_2_6[i].streamConfiguration,
-                                    combination.streamConfiguration);
-                    if (!success) {
-                        *isSupported = false;
-                        return OK;
-                    }
-                }
-                ret = interface_2_6->isConcurrentStreamCombinationSupported(
-                        halCameraIdsAndStreamCombinations_2_6, cb);
-            }
-        }
-
-        if (interface_2_7 != nullptr || interface_2_6 != nullptr) {
-            if (ret.isOk()) {
-                switch (callStatus) {
-                    case Status::OK:
-                        // Expected case, do nothing.
-                        res = OK;
-                        break;
-                    case Status::METHOD_NOT_SUPPORTED:
-                        res = INVALID_OPERATION;
-                        break;
-                    default:
-                        ALOGE("%s: Session configuration query failed: %d", __FUNCTION__,
-                                  callStatus);
-                        res = UNKNOWN_ERROR;
-                }
-            } else {
-                ALOGE("%s: Unexpected binder error: %s", __FUNCTION__, ret.description().c_str());
-                res = UNKNOWN_ERROR;
-            }
-            return res;
-        }
-    }
-    // unsupported operation
-    return INVALID_OPERATION;
-}
-
-} //namespace android
diff --git a/services/camera/libcameraservice/common/hidl/HidlProviderInfo.h b/services/camera/libcameraservice/common/hidl/HidlProviderInfo.h
deleted file mode 100644
index e0f1646ab9..0000000000
--- a/services/camera/libcameraservice/common/hidl/HidlProviderInfo.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SERVERS_CAMERA_CAMERAPROVIDER_HIDLPROVIDERINFOH
-#define ANDROID_SERVERS_CAMERA_CAMERAPROVIDER_HIDLPROVIDERINFOH
-
-#include "common/CameraProviderManager.h"
-
-namespace android {
-
-struct HidlProviderInfo : public CameraProviderManager::ProviderInfo,
-            virtual public hardware::camera::provider::V2_6::ICameraProviderCallback,
-            virtual public hardware::hidl_death_recipient {
-    // Current overall Android device physical status
-    hardware::hidl_bitfield<hardware::camera::provider::V2_5::DeviceState> mDeviceState;
-
-    // This pointer is used to keep a reference to the ICameraProvider that was last accessed.
-    wp<hardware::camera::provider::V2_4::ICameraProvider> mActiveInterface;
-
-    sp<hardware::camera::provider::V2_4::ICameraProvider> mSavedInterface;
-    HidlProviderInfo(
-            const std::string &providerName,
-            const std::string &providerInstance,
-            CameraProviderManager *manager) :
-            CameraProviderManager::ProviderInfo(providerName, providerInstance, manager) {}
-
-    virtual ~HidlProviderInfo() {}
-
-    static status_t mapToStatusT(const hardware::camera::common::V1_0::Status &status);
-
-    status_t initializeHidlProvider(
-            sp<hardware::camera::provider::V2_4::ICameraProvider>& interface,
-            int64_t currentDeviceState);
-
-    IPCTransport getIPCTransport() override {return IPCTransport::HIDL;}
-
-    const sp<hardware::camera::provider::V2_4::ICameraProvider> startProviderInterface();
-
-    virtual bool successfullyStartedProviderInterface() override;
-
-    virtual int64_t getDeviceState() override {return mDeviceState;};
-
-    virtual status_t setUpVendorTags() override;
-    virtual status_t notifyDeviceStateChange(int64_t) override;
-
-    /**
-     * Query the camera provider for concurrent stream configuration support
-     */
-    virtual status_t isConcurrentSessionConfigurationSupported(
-        const std::vector<CameraIdAndSessionConfiguration> &cameraIdsAndSessionConfigs,
-        const std::set<std::string>& perfClassPrimaryCameraIds,
-        int targetSdkVersion, bool *isSupported) override;
-
-    // Helper for initializeDeviceInfo to use the right CameraProvider get method.
-    sp<hardware::camera::device::V3_2::ICameraDevice>
-            startDeviceInterface(const std::string &deviceName);
-
-    // ICameraProviderCallbacks interface - these lock the parent mInterfaceMutex
-    hardware::Return<void> cameraDeviceStatusChange(
-            const hardware::hidl_string& ,
-            hardware::camera::common::V1_0::CameraDeviceStatus ) override;
-    hardware::Return<void> torchModeStatusChange(
-            const hardware::hidl_string& ,
-            hardware::camera::common::V1_0::TorchModeStatus ) override;
-    hardware::Return<void> physicalCameraDeviceStatusChange(
-            const hardware::hidl_string& ,
-            const hardware::hidl_string& ,
-            hardware::camera::common::V1_0::CameraDeviceStatus ) override;
-
-    // hidl_death_recipient interface - this locks the parent mInterfaceMutex
-    virtual void serviceDied(uint64_t , const wp<hidl::base::V1_0::IBase>& ) override;
-
-    struct HidlDeviceInfo3 : public CameraProviderManager::ProviderInfo::DeviceInfo3 {
-
-        const hardware::hidl_version mVersion = hardware::hidl_version{3, 2};
-        sp<IBase> mSavedInterface = nullptr;
-
-        HidlDeviceInfo3(const std::string& , const metadata_vendor_id_t ,
-                const std::string &, uint16_t ,
-                const CameraResourceCost& ,
-                sp<ProviderInfo> ,
-                const std::vector<std::string>& ,
-                sp<hardware::camera::device::V3_2::ICameraDevice>);
-
-        ~HidlDeviceInfo3() {}
-
-        virtual status_t setTorchMode(bool enabled) override;
-        virtual status_t turnOnTorchWithStrengthLevel(int32_t torchStrength) override;
-        virtual status_t getTorchStrengthLevel(int32_t *torchStrength) override;
-
-        virtual status_t dumpState(int fd) override;
-
-        virtual status_t isSessionConfigurationSupported(
-                const SessionConfiguration &/*configuration*/,
-                bool overrideForPerfClass, camera3::metadataGetter getMetadata,
-                bool *status/*status*/);
-        sp<hardware::camera::device::V3_2::ICameraDevice> startDeviceInterface();
-    };
-
- private:
-
-    virtual std::unique_ptr<DeviceInfo> initializeDeviceInfo(const std::string &,
-            const metadata_vendor_id_t , const std::string &,
-            uint16_t ) override;
-    virtual status_t reCacheConcurrentStreamingCameraIdsLocked() override;
-
-    //Expects to have mLock locked
-    status_t getConcurrentCameraIdsInternalLocked(
-            sp<hardware::camera::provider::V2_6::ICameraProvider> &);
-
-    //expects to have mManager->mInterfaceMutex locked
-    status_t convertToHALStreamCombinationAndCameraIdsLocked(
-        const std::vector<hardware::camera2::utils::CameraIdAndSessionConfiguration>&
-                cameraIdsAndSessionConfigs,
-        const std::set<std::string>& perfClassPrimaryCameraIds,
-        int targetSdkVersion,
-        hardware::hidl_vec<hardware::camera::provider::V2_7::CameraIdAndStreamCombination>*
-                halCameraIdsAndStreamCombinations,
-        bool *earlyExit);
-}; // HidlProviderInfo
-
-} // namespace android
-#endif
diff --git a/services/camera/libcameraservice/device3/BufferUtils.cpp b/services/camera/libcameraservice/device3/BufferUtils.cpp
index c0d47d5497..f3adf20a47 100644
--- a/services/camera/libcameraservice/device3/BufferUtils.cpp
+++ b/services/camera/libcameraservice/device3/BufferUtils.cpp
@@ -28,6 +28,16 @@
 namespace android {
 namespace camera3 {
 
+camera_buffer_status_t mapHidlBufferStatus(hardware::camera::device::V3_2::BufferStatus status) {
+    using hardware::camera::device::V3_2::BufferStatus;
+
+    switch (status) {
+        case BufferStatus::OK: return CAMERA_BUFFER_STATUS_OK;
+        case BufferStatus::ERROR: return CAMERA_BUFFER_STATUS_ERROR;
+    }
+    return CAMERA_BUFFER_STATUS_ERROR;
+}
+
 void BufferRecords::takeInflightBufferMap(BufferRecords& other) {
     std::lock_guard<std::mutex> oLock(other.mInflightLock);
     std::lock_guard<std::mutex> lock(mInflightLock);
diff --git a/services/camera/libcameraservice/device3/BufferUtils.h b/services/camera/libcameraservice/device3/BufferUtils.h
index 96fc1110e2..03112ecc2f 100644
--- a/services/camera/libcameraservice/device3/BufferUtils.h
+++ b/services/camera/libcameraservice/device3/BufferUtils.h
@@ -154,6 +154,9 @@ namespace camera3 {
     }; // class BufferRecords
 
     static const uint64_t BUFFER_ID_NO_BUFFER = 0;
+
+    camera_buffer_status_t mapHidlBufferStatus(
+            hardware::camera::device::V3_2::BufferStatus status);
 } // namespace camera3
 
 } // namespace android
diff --git a/services/camera/libcameraservice/device3/Camera3Device.cpp b/services/camera/libcameraservice/device3/Camera3Device.cpp
index 7c2f34f46e..1d47ef2301 100644
--- a/services/camera/libcameraservice/device3/Camera3Device.cpp
+++ b/services/camera/libcameraservice/device3/Camera3Device.cpp
@@ -70,6 +70,8 @@
 
 using namespace android::camera3;
 using namespace android::hardware::camera;
+using namespace android::hardware::camera::device::V3_2;
+using android::hardware::camera::metadata::V3_6::CameraMetadataEnumAndroidSensorPixelMode;
 
 namespace android {
 
@@ -82,7 +84,6 @@ Camera3Device::Camera3Device(const String8 &id, bool overrideForPerfClass, bool
         mStatusWaiters(0),
         mUsePartialResult(false),
         mNumPartialResults(1),
-        mDeviceTimeBaseIsRealtime(false),
         mTimestampOffset(0),
         mNextResultFrameNumber(0),
         mNextReprocessResultFrameNumber(0),
@@ -111,11 +112,165 @@ const String8& Camera3Device::getId() const {
     return mId;
 }
 
-status_t Camera3Device::initializeCommonLocked() {
+status_t Camera3Device::initialize(sp<CameraProviderManager> manager, const String8& monitorTags) {
+    ATRACE_CALL();
+    Mutex::Autolock il(mInterfaceLock);
+    Mutex::Autolock l(mLock);
+
+    ALOGV("%s: Initializing HIDL device for camera %s", __FUNCTION__, mId.string());
+    if (mStatus != STATUS_UNINITIALIZED) {
+        CLOGE("Already initialized!");
+        return INVALID_OPERATION;
+    }
+    if (manager == nullptr) return INVALID_OPERATION;
+
+    sp<ICameraDeviceSession> session;
+    ATRACE_BEGIN("CameraHal::openSession");
+    status_t res = manager->openSession(mId.string(), this,
+            /*out*/ &session);
+    ATRACE_END();
+    if (res != OK) {
+        SET_ERR_L("Could not open camera session: %s (%d)", strerror(-res), res);
+        return res;
+    }
+
+    res = manager->getCameraCharacteristics(mId.string(), mOverrideForPerfClass, &mDeviceInfo);
+    if (res != OK) {
+        SET_ERR_L("Could not retrieve camera characteristics: %s (%d)", strerror(-res), res);
+        session->close();
+        return res;
+    }
+    mSupportNativeZoomRatio = manager->supportNativeZoomRatio(mId.string());
+
+    std::vector<std::string> physicalCameraIds;
+    bool isLogical = manager->isLogicalCamera(mId.string(), &physicalCameraIds);
+    if (isLogical) {
+        for (auto& physicalId : physicalCameraIds) {
+            // Do not override characteristics for physical cameras
+            res = manager->getCameraCharacteristics(
+                    physicalId, /*overrideForPerfClass*/false, &mPhysicalDeviceInfoMap[physicalId]);
+            if (res != OK) {
+                SET_ERR_L("Could not retrieve camera %s characteristics: %s (%d)",
+                        physicalId.c_str(), strerror(-res), res);
+                session->close();
+                return res;
+            }
+
+            bool usePrecorrectArray =
+                    DistortionMapper::isDistortionSupported(mPhysicalDeviceInfoMap[physicalId]);
+            if (usePrecorrectArray) {
+                res = mDistortionMappers[physicalId].setupStaticInfo(
+                        mPhysicalDeviceInfoMap[physicalId]);
+                if (res != OK) {
+                    SET_ERR_L("Unable to read camera %s's calibration fields for distortion "
+                            "correction", physicalId.c_str());
+                    session->close();
+                    return res;
+                }
+            }
+
+            mZoomRatioMappers[physicalId] = ZoomRatioMapper(
+                    &mPhysicalDeviceInfoMap[physicalId],
+                    mSupportNativeZoomRatio, usePrecorrectArray);
+
+            if (SessionConfigurationUtils::isUltraHighResolutionSensor(
+                    mPhysicalDeviceInfoMap[physicalId])) {
+                mUHRCropAndMeteringRegionMappers[physicalId] =
+                        UHRCropAndMeteringRegionMapper(mPhysicalDeviceInfoMap[physicalId],
+                                usePrecorrectArray);
+            }
+        }
+    }
+
+    std::shared_ptr<RequestMetadataQueue> queue;
+    auto requestQueueRet = session->getCaptureRequestMetadataQueue(
+        [&queue](const auto& descriptor) {
+            queue = std::make_shared<RequestMetadataQueue>(descriptor);
+            if (!queue->isValid() || queue->availableToWrite() <= 0) {
+                ALOGE("HAL returns empty request metadata fmq, not use it");
+                queue = nullptr;
+                // don't use the queue onwards.
+            }
+        });
+    if (!requestQueueRet.isOk()) {
+        ALOGE("Transaction error when getting request metadata fmq: %s, not use it",
+                requestQueueRet.description().c_str());
+        return DEAD_OBJECT;
+    }
 
-    /** Start watchdog thread */
-    mCameraServiceWatchdog = new CameraServiceWatchdog();
-    mCameraServiceWatchdog->run("CameraServiceWatchdog");
+    std::unique_ptr<ResultMetadataQueue>& resQueue = mResultMetadataQueue;
+    auto resultQueueRet = session->getCaptureResultMetadataQueue(
+        [&resQueue](const auto& descriptor) {
+            resQueue = std::make_unique<ResultMetadataQueue>(descriptor);
+            if (!resQueue->isValid() || resQueue->availableToWrite() <= 0) {
+                ALOGE("HAL returns empty result metadata fmq, not use it");
+                resQueue = nullptr;
+                // Don't use the resQueue onwards.
+            }
+        });
+    if (!resultQueueRet.isOk()) {
+        ALOGE("Transaction error when getting result metadata queue from camera session: %s",
+                resultQueueRet.description().c_str());
+        return DEAD_OBJECT;
+    }
+    IF_ALOGV() {
+        session->interfaceChain([](
+            ::android::hardware::hidl_vec<::android::hardware::hidl_string> interfaceChain) {
+                ALOGV("Session interface chain:");
+                for (const auto& iface : interfaceChain) {
+                    ALOGV("  %s", iface.c_str());
+                }
+            });
+    }
+
+    camera_metadata_entry bufMgrMode =
+            mDeviceInfo.find(ANDROID_INFO_SUPPORTED_BUFFER_MANAGEMENT_VERSION);
+    if (bufMgrMode.count > 0) {
+         mUseHalBufManager = (bufMgrMode.data.u8[0] ==
+            ANDROID_INFO_SUPPORTED_BUFFER_MANAGEMENT_VERSION_HIDL_DEVICE_3_5);
+    }
+
+    camera_metadata_entry_t capabilities = mDeviceInfo.find(ANDROID_REQUEST_AVAILABLE_CAPABILITIES);
+    for (size_t i = 0; i < capabilities.count; i++) {
+        uint8_t capability = capabilities.data.u8[i];
+        if (capability == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_OFFLINE_PROCESSING) {
+            mSupportOfflineProcessing = true;
+        }
+    }
+
+    mInterface = new HalInterface(session, queue, mUseHalBufManager, mSupportOfflineProcessing);
+    std::string providerType;
+    mVendorTagId = manager->getProviderTagIdLocked(mId.string());
+    mTagMonitor.initialize(mVendorTagId);
+    if (!monitorTags.isEmpty()) {
+        mTagMonitor.parseTagsToMonitor(String8(monitorTags));
+    }
+
+    // Metadata tags needs fixup for monochrome camera device version less
+    // than 3.5.
+    hardware::hidl_version maxVersion{0,0};
+    res = manager->getHighestSupportedVersion(mId.string(), &maxVersion);
+    if (res != OK) {
+        ALOGE("%s: Error in getting camera device version id: %s (%d)",
+                __FUNCTION__, strerror(-res), res);
+        return res;
+    }
+    int deviceVersion = HARDWARE_DEVICE_API_VERSION(
+            maxVersion.get_major(), maxVersion.get_minor());
+
+    bool isMonochrome = false;
+    for (size_t i = 0; i < capabilities.count; i++) {
+        uint8_t capability = capabilities.data.u8[i];
+        if (capability == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME) {
+            isMonochrome = true;
+        }
+    }
+    mNeedFixupMonochromeTags = (isMonochrome && deviceVersion < CAMERA_DEVICE_API_VERSION_3_5);
+
+    return initializeCommonLocked();
+}
+
+status_t Camera3Device::initializeCommonLocked() {
 
     /** Start up status tracker thread */
     mStatusTracker = new StatusTracker(this);
@@ -168,7 +323,7 @@ status_t Camera3Device::initializeCommonLocked() {
     }
 
     /** Start up request queue thread */
-    mRequestThread = createNewRequestThread(
+    mRequestThread = new RequestThread(
             this, mStatusTracker, mInterface, sessionParamKeys,
             mUseHalBufManager, mSupportCameraMute);
     res = mRequestThread->run(String8::format("C3Dev-%s-ReqQueue", mId.string()).string());
@@ -190,12 +345,11 @@ status_t Camera3Device::initializeCommonLocked() {
     mIsInputStreamMultiResolution = false;
 
     // Measure the clock domain offset between camera and video/hw_composer
-    mTimestampOffset = getMonoToBoottimeOffset();
     camera_metadata_entry timestampSource =
             mDeviceInfo.find(ANDROID_SENSOR_INFO_TIMESTAMP_SOURCE);
     if (timestampSource.count > 0 && timestampSource.data.u8[0] ==
             ANDROID_SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME) {
-        mDeviceTimeBaseIsRealtime = true;
+        mTimestampOffset = getMonoToBoottimeOffset();
     }
 
     // Will the HAL be sending in early partial result metadata?
@@ -227,8 +381,7 @@ status_t Camera3Device::initializeCommonLocked() {
         mRotateAndCropMappers.emplace(mId.c_str(), &mDeviceInfo);
     }
 
-    // Hidl/AidlCamera3DeviceInjectionMethods
-    mInjectionMethods = createCamera3DeviceInjectionMethods(this);
+    mInjectionMethods = new Camera3DeviceInjectionMethods(this);
 
     return OK;
 }
@@ -318,7 +471,7 @@ status_t Camera3Device::disconnectImpl() {
 
         // Call close without internal mutex held, as the HAL close may need to
         // wait on assorted callbacks,etc, to complete before it can return.
-        mCameraServiceWatchdog->WATCH(interface->close());
+        interface->close();
 
         flushInflightRequests();
 
@@ -341,12 +494,6 @@ status_t Camera3Device::disconnectImpl() {
         }
     }
     ALOGI("%s: X", __FUNCTION__);
-
-    if (mCameraServiceWatchdog != NULL) {
-        mCameraServiceWatchdog->requestExit();
-        mCameraServiceWatchdog.clear();
-    }
-
     return res;
 }
 
@@ -384,16 +531,86 @@ nsecs_t Camera3Device::getMonoToBoottimeOffset() {
     return measured;
 }
 
-ssize_t Camera3Device::getJpegBufferSize(const CameraMetadata &info, uint32_t width,
-        uint32_t height) const {
+hardware::graphics::common::V1_0::PixelFormat Camera3Device::mapToPixelFormat(
+        int frameworkFormat) {
+    return (hardware::graphics::common::V1_0::PixelFormat) frameworkFormat;
+}
+
+DataspaceFlags Camera3Device::mapToHidlDataspace(
+        android_dataspace dataSpace) {
+    return dataSpace;
+}
+
+BufferUsageFlags Camera3Device::mapToConsumerUsage(
+        uint64_t usage) {
+    return usage;
+}
+
+StreamRotation Camera3Device::mapToStreamRotation(camera_stream_rotation_t rotation) {
+    switch (rotation) {
+        case CAMERA_STREAM_ROTATION_0:
+            return StreamRotation::ROTATION_0;
+        case CAMERA_STREAM_ROTATION_90:
+            return StreamRotation::ROTATION_90;
+        case CAMERA_STREAM_ROTATION_180:
+            return StreamRotation::ROTATION_180;
+        case CAMERA_STREAM_ROTATION_270:
+            return StreamRotation::ROTATION_270;
+    }
+    ALOGE("%s: Unknown stream rotation %d", __FUNCTION__, rotation);
+    return StreamRotation::ROTATION_0;
+}
+
+status_t Camera3Device::mapToStreamConfigurationMode(
+        camera_stream_configuration_mode_t operationMode, StreamConfigurationMode *mode) {
+    if (mode == nullptr) return BAD_VALUE;
+    if (operationMode < CAMERA_VENDOR_STREAM_CONFIGURATION_MODE_START) {
+        switch(operationMode) {
+            case CAMERA_STREAM_CONFIGURATION_NORMAL_MODE:
+                *mode = StreamConfigurationMode::NORMAL_MODE;
+                break;
+            case CAMERA_STREAM_CONFIGURATION_CONSTRAINED_HIGH_SPEED_MODE:
+                *mode = StreamConfigurationMode::CONSTRAINED_HIGH_SPEED_MODE;
+                break;
+            default:
+                ALOGE("%s: Unknown stream configuration mode %d", __FUNCTION__, operationMode);
+                return BAD_VALUE;
+        }
+    } else {
+        *mode = static_cast<StreamConfigurationMode>(operationMode);
+    }
+    return OK;
+}
+
+int Camera3Device::mapToFrameworkFormat(
+        hardware::graphics::common::V1_0::PixelFormat pixelFormat) {
+    return static_cast<uint32_t>(pixelFormat);
+}
+
+android_dataspace Camera3Device::mapToFrameworkDataspace(
+        DataspaceFlags dataSpace) {
+    return static_cast<android_dataspace>(dataSpace);
+}
+
+uint64_t Camera3Device::mapConsumerToFrameworkUsage(
+        BufferUsageFlags usage) {
+    return usage;
+}
+
+uint64_t Camera3Device::mapProducerToFrameworkUsage(
+        BufferUsageFlags usage) {
+    return usage;
+}
+
+ssize_t Camera3Device::getJpegBufferSize(uint32_t width, uint32_t height) const {
     // Get max jpeg size (area-wise) for default sensor pixel mode
     camera3::Size maxDefaultJpegResolution =
-            SessionConfigurationUtils::getMaxJpegResolution(info,
+            SessionConfigurationUtils::getMaxJpegResolution(mDeviceInfo,
                     /*isUltraHighResolutionSensor*/false);
     // Get max jpeg size (area-wise) for max resolution sensor pixel mode / 0 if
     // not ultra high res sensor
     camera3::Size uhrMaxJpegResolution =
-            SessionConfigurationUtils::getMaxJpegResolution(info,
+            SessionConfigurationUtils::getMaxJpegResolution(mDeviceInfo,
                     /*isUltraHighResolution*/true);
     if (maxDefaultJpegResolution.width == 0) {
         ALOGE("%s: Camera %s: Can't find valid available jpeg sizes in static metadata!",
@@ -409,7 +626,7 @@ ssize_t Camera3Device::getJpegBufferSize(const CameraMetadata &info, uint32_t wi
 
     // Get max jpeg buffer size
     ssize_t maxJpegBufferSize = 0;
-    camera_metadata_ro_entry jpegBufMaxSize = info.find(ANDROID_JPEG_MAX_SIZE);
+    camera_metadata_ro_entry jpegBufMaxSize = mDeviceInfo.find(ANDROID_JPEG_MAX_SIZE);
     if (jpegBufMaxSize.count == 0) {
         ALOGE("%s: Camera %s: Can't find maximum JPEG size in static metadata!", __FUNCTION__,
                 mId.string());
@@ -439,9 +656,9 @@ ssize_t Camera3Device::getJpegBufferSize(const CameraMetadata &info, uint32_t wi
     return jpegBufferSize;
 }
 
-ssize_t Camera3Device::getPointCloudBufferSize(const CameraMetadata &info) const {
+ssize_t Camera3Device::getPointCloudBufferSize() const {
     const int FLOATS_PER_POINT=4;
-    camera_metadata_ro_entry maxPointCount = info.find(ANDROID_DEPTH_MAX_DEPTH_SAMPLES);
+    camera_metadata_ro_entry maxPointCount = mDeviceInfo.find(ANDROID_DEPTH_MAX_DEPTH_SAMPLES);
     if (maxPointCount.count == 0) {
         ALOGE("%s: Camera %s: Can't find maximum depth point cloud size in static metadata!",
                 __FUNCTION__, mId.string());
@@ -452,14 +669,14 @@ ssize_t Camera3Device::getPointCloudBufferSize(const CameraMetadata &info) const
     return maxBytesForPointCloud;
 }
 
-ssize_t Camera3Device::getRawOpaqueBufferSize(const CameraMetadata &info, int32_t width,
-        int32_t height, bool maxResolution) const {
+ssize_t Camera3Device::getRawOpaqueBufferSize(int32_t width, int32_t height,
+        bool maxResolution) const {
     const int PER_CONFIGURATION_SIZE = 3;
     const int WIDTH_OFFSET = 0;
     const int HEIGHT_OFFSET = 1;
     const int SIZE_OFFSET = 2;
     camera_metadata_ro_entry rawOpaqueSizes =
-        info.find(
+        mDeviceInfo.find(
             camera3::SessionConfigurationUtils::getAppropriateModeTag(
                     ANDROID_SENSOR_OPAQUE_RAW_SIZE,
                     maxResolution));
@@ -536,9 +753,10 @@ status_t Camera3Device::dump(int fd, const Vector<String16> &args) {
     }
     lines.appendFormat("    Stream configuration:\n");
     const char *mode =
-            mOperatingMode == CAMERA_STREAM_CONFIGURATION_NORMAL_MODE ? "NORMAL" :
-            mOperatingMode == CAMERA_STREAM_CONFIGURATION_CONSTRAINED_HIGH_SPEED_MODE ?
-                    "CONSTRAINED_HIGH_SPEED" : "CUSTOM";
+            mOperatingMode == static_cast<int>(StreamConfigurationMode::NORMAL_MODE) ? "NORMAL" :
+            mOperatingMode == static_cast<int>(
+                StreamConfigurationMode::CONSTRAINED_HIGH_SPEED_MODE) ? "CONSTRAINED_HIGH_SPEED" :
+            "CUSTOM";
     lines.appendFormat("    Operation mode: %s (%d) \n", mode, mOperatingMode);
 
     if (mInputStream != NULL) {
@@ -825,6 +1043,176 @@ status_t Camera3Device::submitRequestsHelper(
     return res;
 }
 
+hardware::Return<void> Camera3Device::requestStreamBuffers(
+        const hardware::hidl_vec<hardware::camera::device::V3_5::BufferRequest>& bufReqs,
+        requestStreamBuffers_cb _hidl_cb) {
+    RequestBufferStates states {
+        mId, mRequestBufferInterfaceLock, mUseHalBufManager, mOutputStreams, mSessionStatsBuilder,
+        *this, *mInterface, *this};
+    camera3::requestStreamBuffers(states, bufReqs, _hidl_cb);
+    return hardware::Void();
+}
+
+hardware::Return<void> Camera3Device::returnStreamBuffers(
+        const hardware::hidl_vec<hardware::camera::device::V3_2::StreamBuffer>& buffers) {
+    ReturnBufferStates states {
+        mId, mUseHalBufManager, mOutputStreams, mSessionStatsBuilder, *mInterface};
+    camera3::returnStreamBuffers(states, buffers);
+    return hardware::Void();
+}
+
+hardware::Return<void> Camera3Device::processCaptureResult_3_4(
+        const hardware::hidl_vec<
+                hardware::camera::device::V3_4::CaptureResult>& results) {
+    // Ideally we should grab mLock, but that can lead to deadlock, and
+    // it's not super important to get up to date value of mStatus for this
+    // warning print, hence skipping the lock here
+    if (mStatus == STATUS_ERROR) {
+        // Per API contract, HAL should act as closed after device error
+        // But mStatus can be set to error by framework as well, so just log
+        // a warning here.
+        ALOGW("%s: received capture result in error state.", __FUNCTION__);
+    }
+
+    sp<NotificationListener> listener;
+    {
+        std::lock_guard<std::mutex> l(mOutputLock);
+        listener = mListener.promote();
+    }
+
+    if (mProcessCaptureResultLock.tryLock() != OK) {
+        // This should never happen; it indicates a wrong client implementation
+        // that doesn't follow the contract. But, we can be tolerant here.
+        ALOGE("%s: callback overlapped! waiting 1s...",
+                __FUNCTION__);
+        if (mProcessCaptureResultLock.timedLock(1000000000 /* 1s */) != OK) {
+            ALOGE("%s: cannot acquire lock in 1s, dropping results",
+                    __FUNCTION__);
+            // really don't know what to do, so bail out.
+            return hardware::Void();
+        }
+    }
+    CaptureOutputStates states {
+        mId,
+        mInFlightLock, mLastCompletedRegularFrameNumber,
+        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
+        mInFlightMap, mOutputLock,  mResultQueue, mResultSignal,
+        mNextShutterFrameNumber,
+        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
+        mNextResultFrameNumber,
+        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
+        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
+        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
+        mResultMetadataQueue, mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
+        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this, *this,
+        *mInterface, mLegacyClient
+    };
+
+    for (const auto& result : results) {
+        processOneCaptureResultLocked(states, result.v3_2, result.physicalCameraMetadata);
+    }
+    mProcessCaptureResultLock.unlock();
+    return hardware::Void();
+}
+
+// Only one processCaptureResult should be called at a time, so
+// the locks won't block. The locks are present here simply to enforce this.
+hardware::Return<void> Camera3Device::processCaptureResult(
+        const hardware::hidl_vec<
+                hardware::camera::device::V3_2::CaptureResult>& results) {
+    hardware::hidl_vec<hardware::camera::device::V3_4::PhysicalCameraMetadata> noPhysMetadata;
+
+    // Ideally we should grab mLock, but that can lead to deadlock, and
+    // it's not super important to get up to date value of mStatus for this
+    // warning print, hence skipping the lock here
+    if (mStatus == STATUS_ERROR) {
+        // Per API contract, HAL should act as closed after device error
+        // But mStatus can be set to error by framework as well, so just log
+        // a warning here.
+        ALOGW("%s: received capture result in error state.", __FUNCTION__);
+    }
+
+    sp<NotificationListener> listener;
+    {
+        std::lock_guard<std::mutex> l(mOutputLock);
+        listener = mListener.promote();
+    }
+
+    if (mProcessCaptureResultLock.tryLock() != OK) {
+        // This should never happen; it indicates a wrong client implementation
+        // that doesn't follow the contract. But, we can be tolerant here.
+        ALOGE("%s: callback overlapped! waiting 1s...",
+                __FUNCTION__);
+        if (mProcessCaptureResultLock.timedLock(1000000000 /* 1s */) != OK) {
+            ALOGE("%s: cannot acquire lock in 1s, dropping results",
+                    __FUNCTION__);
+            // really don't know what to do, so bail out.
+            return hardware::Void();
+        }
+    }
+
+    CaptureOutputStates states {
+        mId,
+        mInFlightLock, mLastCompletedRegularFrameNumber,
+        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
+        mInFlightMap, mOutputLock,  mResultQueue, mResultSignal,
+        mNextShutterFrameNumber,
+        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
+        mNextResultFrameNumber,
+        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
+        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
+        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
+        mResultMetadataQueue, mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
+        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this, *this,
+        *mInterface, mLegacyClient
+    };
+
+    for (const auto& result : results) {
+        processOneCaptureResultLocked(states, result, noPhysMetadata);
+    }
+    mProcessCaptureResultLock.unlock();
+    return hardware::Void();
+}
+
+hardware::Return<void> Camera3Device::notify(
+        const hardware::hidl_vec<hardware::camera::device::V3_2::NotifyMsg>& msgs) {
+    // Ideally we should grab mLock, but that can lead to deadlock, and
+    // it's not super important to get up to date value of mStatus for this
+    // warning print, hence skipping the lock here
+    if (mStatus == STATUS_ERROR) {
+        // Per API contract, HAL should act as closed after device error
+        // But mStatus can be set to error by framework as well, so just log
+        // a warning here.
+        ALOGW("%s: received notify message in error state.", __FUNCTION__);
+    }
+
+    sp<NotificationListener> listener;
+    {
+        std::lock_guard<std::mutex> l(mOutputLock);
+        listener = mListener.promote();
+    }
+
+    CaptureOutputStates states {
+        mId,
+        mInFlightLock, mLastCompletedRegularFrameNumber,
+        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
+        mInFlightMap, mOutputLock,  mResultQueue, mResultSignal,
+        mNextShutterFrameNumber,
+        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
+        mNextResultFrameNumber,
+        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
+        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
+        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
+        mResultMetadataQueue, mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
+        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this, *this,
+        *mInterface, mLegacyClient
+    };
+    for (const auto& msg : msgs) {
+        camera3::notify(states, msg);
+    }
+    return hardware::Void();
+}
+
 status_t Camera3Device::captureList(const List<const PhysicalCameraSettingsList> &requestsList,
                                     const std::list<const SurfaceMap> &surfaceMaps,
                                     int64_t *lastFrameNumber) {
@@ -985,8 +1373,7 @@ status_t Camera3Device::createStream(sp<Surface> consumer,
             const String8& physicalCameraId,
             const std::unordered_set<int32_t> &sensorPixelModesUsed,
             std::vector<int> *surfaceIds, int streamSetId, bool isShared, bool isMultiResolution,
-            uint64_t consumerUsage, int64_t dynamicRangeProfile, int64_t streamUseCase,
-            int timestampBase, int mirrorMode) {
+            uint64_t consumerUsage) {
     ATRACE_CALL();
 
     if (consumer == nullptr) {
@@ -999,8 +1386,7 @@ status_t Camera3Device::createStream(sp<Surface> consumer,
 
     return createStream(consumers, /*hasDeferredConsumer*/ false, width, height,
             format, dataSpace, rotation, id, physicalCameraId, sensorPixelModesUsed, surfaceIds,
-            streamSetId, isShared, isMultiResolution, consumerUsage, dynamicRangeProfile,
-            streamUseCase, timestampBase, mirrorMode);
+            streamSetId, isShared, isMultiResolution, consumerUsage);
 }
 
 static bool isRawFormat(int format) {
@@ -1020,20 +1406,16 @@ status_t Camera3Device::createStream(const std::vector<sp<Surface>>& consumers,
         android_dataspace dataSpace, camera_stream_rotation_t rotation, int *id,
         const String8& physicalCameraId, const std::unordered_set<int32_t> &sensorPixelModesUsed,
         std::vector<int> *surfaceIds, int streamSetId, bool isShared, bool isMultiResolution,
-        uint64_t consumerUsage, int64_t dynamicRangeProfile, int64_t streamUseCase,
-        int timestampBase, int mirrorMode) {
+        uint64_t consumerUsage) {
     ATRACE_CALL();
 
     Mutex::Autolock il(mInterfaceLock);
     nsecs_t maxExpectedDuration = getExpectedInFlightDuration();
     Mutex::Autolock l(mLock);
     ALOGV("Camera %s: Creating new stream %d: %d x %d, format %d, dataspace %d rotation %d"
-            " consumer usage %" PRIu64 ", isShared %d, physicalCameraId %s, isMultiResolution %d"
-            " dynamicRangeProfile 0x%" PRIx64 ", streamUseCase %" PRId64 ", timestampBase %d,"
-            " mirrorMode %d",
+            " consumer usage %" PRIu64 ", isShared %d, physicalCameraId %s, isMultiResolution %d",
             mId.string(), mNextStreamId, width, height, format, dataSpace, rotation,
-            consumerUsage, isShared, physicalCameraId.string(), isMultiResolution,
-            dynamicRangeProfile, streamUseCase, timestampBase, mirrorMode);
+            consumerUsage, isShared, physicalCameraId.string(), isMultiResolution);
 
     status_t res;
     bool wasActive = false;
@@ -1082,11 +1464,10 @@ status_t Camera3Device::createStream(const std::vector<sp<Surface>>& consumers,
         ALOGE("%s: RAW opaque stream cannot be used with > 1 sensor pixel modes", __FUNCTION__);
         return BAD_VALUE;
     }
-    IPCTransport transport = getTransportType();
     if (format == HAL_PIXEL_FORMAT_BLOB) {
         ssize_t blobBufferSize;
         if (dataSpace == HAL_DATASPACE_DEPTH) {
-            blobBufferSize = getPointCloudBufferSize(infoPhysical(physicalCameraId));
+            blobBufferSize = getPointCloudBufferSize();
             if (blobBufferSize <= 0) {
                 SET_ERR_L("Invalid point cloud buffer size %zd", blobBufferSize);
                 return BAD_VALUE;
@@ -1094,7 +1475,7 @@ status_t Camera3Device::createStream(const std::vector<sp<Surface>>& consumers,
         } else if (dataSpace == static_cast<android_dataspace>(HAL_DATASPACE_JPEG_APP_SEGMENTS)) {
             blobBufferSize = width * height;
         } else {
-            blobBufferSize = getJpegBufferSize(infoPhysical(physicalCameraId), width, height);
+            blobBufferSize = getJpegBufferSize(width, height);
             if (blobBufferSize <= 0) {
                 SET_ERR_L("Invalid jpeg buffer size %zd", blobBufferSize);
                 return BAD_VALUE;
@@ -1102,42 +1483,36 @@ status_t Camera3Device::createStream(const std::vector<sp<Surface>>& consumers,
         }
         newStream = new Camera3OutputStream(mNextStreamId, consumers[0],
                 width, height, blobBufferSize, format, dataSpace, rotation,
-                mTimestampOffset, physicalCameraId, sensorPixelModesUsed, transport, streamSetId,
-                isMultiResolution, dynamicRangeProfile, streamUseCase, mDeviceTimeBaseIsRealtime,
-                timestampBase, mirrorMode);
+                mTimestampOffset, physicalCameraId, sensorPixelModesUsed, streamSetId,
+                isMultiResolution);
     } else if (format == HAL_PIXEL_FORMAT_RAW_OPAQUE) {
         bool maxResolution =
                 sensorPixelModesUsed.find(ANDROID_SENSOR_PIXEL_MODE_MAXIMUM_RESOLUTION) !=
                         sensorPixelModesUsed.end();
-        ssize_t rawOpaqueBufferSize = getRawOpaqueBufferSize(infoPhysical(physicalCameraId), width,
-                height, maxResolution);
+        ssize_t rawOpaqueBufferSize = getRawOpaqueBufferSize(width, height, maxResolution);
         if (rawOpaqueBufferSize <= 0) {
             SET_ERR_L("Invalid RAW opaque buffer size %zd", rawOpaqueBufferSize);
             return BAD_VALUE;
         }
         newStream = new Camera3OutputStream(mNextStreamId, consumers[0],
                 width, height, rawOpaqueBufferSize, format, dataSpace, rotation,
-                mTimestampOffset, physicalCameraId, sensorPixelModesUsed, transport, streamSetId,
-                isMultiResolution, dynamicRangeProfile, streamUseCase, mDeviceTimeBaseIsRealtime,
-                timestampBase, mirrorMode);
+                mTimestampOffset, physicalCameraId, sensorPixelModesUsed, streamSetId,
+                isMultiResolution);
     } else if (isShared) {
         newStream = new Camera3SharedOutputStream(mNextStreamId, consumers,
                 width, height, format, consumerUsage, dataSpace, rotation,
-                mTimestampOffset, physicalCameraId, sensorPixelModesUsed, transport, streamSetId,
-                mUseHalBufManager, dynamicRangeProfile, streamUseCase, mDeviceTimeBaseIsRealtime,
-                timestampBase, mirrorMode);
+                mTimestampOffset, physicalCameraId, sensorPixelModesUsed, streamSetId,
+                mUseHalBufManager);
     } else if (consumers.size() == 0 && hasDeferredConsumer) {
         newStream = new Camera3OutputStream(mNextStreamId,
                 width, height, format, consumerUsage, dataSpace, rotation,
-                mTimestampOffset, physicalCameraId, sensorPixelModesUsed, transport, streamSetId,
-                isMultiResolution, dynamicRangeProfile, streamUseCase, mDeviceTimeBaseIsRealtime,
-                timestampBase, mirrorMode);
+                mTimestampOffset, physicalCameraId, sensorPixelModesUsed, streamSetId,
+                isMultiResolution);
     } else {
         newStream = new Camera3OutputStream(mNextStreamId, consumers[0],
                 width, height, format, dataSpace, rotation,
-                mTimestampOffset, physicalCameraId, sensorPixelModesUsed, transport, streamSetId,
-                isMultiResolution, dynamicRangeProfile, streamUseCase, mDeviceTimeBaseIsRealtime,
-                timestampBase, mirrorMode);
+                mTimestampOffset, physicalCameraId, sensorPixelModesUsed, streamSetId,
+                isMultiResolution);
     }
 
     size_t consumerCount = consumers.size();
@@ -1224,7 +1599,6 @@ status_t Camera3Device::getStreamInfo(int id, StreamInfo *streamInfo) {
     streamInfo->originalFormat = stream->getOriginalFormat();
     streamInfo->dataSpaceOverridden = stream->isDataSpaceOverridden();
     streamInfo->originalDataSpace = stream->getOriginalDataSpace();
-    streamInfo->dynamicRangeProfile = stream->getDynamicRangeProfile();
     return OK;
 }
 
@@ -1256,7 +1630,7 @@ status_t Camera3Device::setStreamTransform(int id,
         CLOGE("Stream %d does not exist", id);
         return BAD_VALUE;
     }
-    return stream->setTransform(transform, false /*mayChangeMirror*/);
+    return stream->setTransform(transform);
 }
 
 status_t Camera3Device::deleteStream(int id) {
@@ -1557,22 +1931,13 @@ status_t Camera3Device::waitUntilStateThenRelock(bool active, nsecs_t timeout) {
     }
 
     bool stateSeen = false;
-    nsecs_t startTime = systemTime();
     do {
         if (active == (mStatus == STATUS_ACTIVE)) {
             // Desired state is current
             break;
         }
 
-        nsecs_t timeElapsed = systemTime() - startTime;
-        nsecs_t timeToWait = timeout - timeElapsed;
-        if (timeToWait <= 0) {
-            // Thread woke up spuriously but has timed out since.
-            // Force out of loop with TIMED_OUT result.
-            res = TIMED_OUT;
-            break;
-        }
-        res = mStatusChanged.waitRelative(mLock, timeToWait);
+        res = mStatusChanged.waitRelative(mLock, timeout);
         if (res != OK) break;
 
         // This is impossible, but if not, could result in subtle deadlocks and invalid state
@@ -1736,12 +2101,7 @@ status_t Camera3Device::flush(int64_t *frameNumber) {
         mSessionStatsBuilder.stopCounter();
     }
 
-    // Calculate expected duration for flush with additional buffer time in ms for watchdog
-    uint64_t maxExpectedDuration = (getExpectedInFlightDuration() + kBaseGetBufferWait) / 1e6;
-    status_t res = mCameraServiceWatchdog->WATCH_CUSTOM_TIMER(mRequestThread->flush(),
-            maxExpectedDuration / kCycleLengthMs, kCycleLengthMs);
-
-    return res;
+    return mRequestThread->flush();
 }
 
 status_t Camera3Device::prepare(int streamId) {
@@ -1810,20 +2170,6 @@ status_t Camera3Device::addBufferListenerForStream(int streamId,
     return OK;
 }
 
-float Camera3Device::getMaxPreviewFps(sp<camera3::Camera3OutputStreamInterface> stream) {
-    camera_metadata_entry minDurations =
-            mDeviceInfo.find(ANDROID_SCALER_AVAILABLE_MIN_FRAME_DURATIONS);
-    for (size_t i = 0; i < minDurations.count; i += 4) {
-        if (minDurations.data.i64[i] == stream->getFormat()
-                && minDurations.data.i64[i+1] == stream->getWidth()
-                && minDurations.data.i64[i+2] == stream->getHeight()) {
-            int64_t minFrameDuration = minDurations.data.i64[i+3];
-            return 1e9f / minFrameDuration;
-        }
-    }
-    return 0.0f;
-}
-
 /**
  * Methods called by subclasses
  */
@@ -1832,7 +2178,6 @@ void Camera3Device::notifyStatus(bool idle) {
     ATRACE_CALL();
     std::vector<int> streamIds;
     std::vector<hardware::CameraStreamStats> streamStats;
-    float sessionMaxPreviewFps = 0.0f;
 
     {
         // Need mLock to safely update state and synchronize to current
@@ -1852,28 +2197,21 @@ void Camera3Device::notifyStatus(bool idle) {
         // state changes
         if (mPauseStateNotify) return;
 
-        for (size_t i = 0; i < mOutputStreams.size(); i++) {
-            auto stream = mOutputStreams[i];
-            if (stream.get() == nullptr) continue;
-
-            float streamMaxPreviewFps = getMaxPreviewFps(stream);
-            sessionMaxPreviewFps = std::max(sessionMaxPreviewFps, streamMaxPreviewFps);
-
-            // Populate stream statistics in case of Idle
-            if (idle) {
+        // Populate stream statistics in case of Idle
+        if (idle) {
+            for (size_t i = 0; i < mOutputStreams.size(); i++) {
+                auto stream = mOutputStreams[i];
+                if (stream.get() == nullptr) continue;
                 streamIds.push_back(stream->getId());
                 Camera3Stream* camera3Stream = Camera3Stream::cast(stream->asHalStream());
                 int64_t usage = 0LL;
-                int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT;
                 if (camera3Stream != nullptr) {
                     usage = camera3Stream->getUsage();
-                    streamUseCase = camera3Stream->getStreamUseCase();
                 }
                 streamStats.emplace_back(stream->getWidth(), stream->getHeight(),
-                    stream->getFormat(), streamMaxPreviewFps, stream->getDataSpace(), usage,
+                    stream->getFormat(), stream->getDataSpace(), usage,
                     stream->getMaxHalBuffers(),
-                    stream->getMaxTotalBuffers() - stream->getMaxHalBuffers(),
-                    stream->getDynamicRangeProfile(), streamUseCase);
+                    stream->getMaxTotalBuffers() - stream->getMaxHalBuffers());
             }
         }
     }
@@ -1911,7 +2249,7 @@ void Camera3Device::notifyStatus(bool idle) {
             }
             listener->notifyIdle(requestCount, resultErrorCount, deviceError, streamStats);
         } else {
-            res = listener->notifyActive(sessionMaxPreviewFps);
+            res = listener->notifyActive();
         }
     }
     if (res != OK) {
@@ -2133,24 +2471,22 @@ sp<Camera3Device::CaptureRequest> Camera3Device::createCaptureRequest(
     }
 
     if (mSupportCameraMute) {
-        for (auto& settings : newRequest->mSettingsList) {
-            auto testPatternModeEntry =
-                    settings.metadata.find(ANDROID_SENSOR_TEST_PATTERN_MODE);
-            settings.mOriginalTestPatternMode = testPatternModeEntry.count > 0 ?
-                    testPatternModeEntry.data.i32[0] :
-                    ANDROID_SENSOR_TEST_PATTERN_MODE_OFF;
-
-            auto testPatternDataEntry =
-                    settings.metadata.find(ANDROID_SENSOR_TEST_PATTERN_DATA);
-            if (testPatternDataEntry.count >= 4) {
-                memcpy(settings.mOriginalTestPatternData, testPatternDataEntry.data.i32,
-                        sizeof(PhysicalCameraSettings::mOriginalTestPatternData));
-            } else {
-                settings.mOriginalTestPatternData[0] = 0;
-                settings.mOriginalTestPatternData[1] = 0;
-                settings.mOriginalTestPatternData[2] = 0;
-                settings.mOriginalTestPatternData[3] = 0;
-            }
+        auto testPatternModeEntry =
+                newRequest->mSettingsList.begin()->metadata.find(ANDROID_SENSOR_TEST_PATTERN_MODE);
+        newRequest->mOriginalTestPatternMode = testPatternModeEntry.count > 0 ?
+                testPatternModeEntry.data.i32[0] :
+                ANDROID_SENSOR_TEST_PATTERN_MODE_OFF;
+
+        auto testPatternDataEntry =
+                newRequest->mSettingsList.begin()->metadata.find(ANDROID_SENSOR_TEST_PATTERN_DATA);
+        if (testPatternDataEntry.count >= 4) {
+            memcpy(newRequest->mOriginalTestPatternData, testPatternDataEntry.data.i32,
+                    sizeof(CaptureRequest::mOriginalTestPatternData));
+        } else {
+            newRequest->mOriginalTestPatternData[0] = 0;
+            newRequest->mOriginalTestPatternData[1] = 0;
+            newRequest->mOriginalTestPatternData[2] = 0;
+            newRequest->mOriginalTestPatternData[3] = 0;
         }
     }
 
@@ -2283,7 +2619,8 @@ status_t Camera3Device::configureStreamsLocked(int operatingMode,
     }
 
     bool isConstrainedHighSpeed =
-            CAMERA_STREAM_CONFIGURATION_CONSTRAINED_HIGH_SPEED_MODE == operatingMode;
+            static_cast<int>(StreamConfigurationMode::CONSTRAINED_HIGH_SPEED_MODE) ==
+            operatingMode;
 
     if (mOperatingMode != operatingMode) {
         mNeedConfig = true;
@@ -2291,9 +2628,6 @@ status_t Camera3Device::configureStreamsLocked(int operatingMode,
         mOperatingMode = operatingMode;
     }
 
-    // Reset min expected duration when session is reconfigured.
-    mMinExpectedDuration = 0;
-
     // In case called from configureStreams, abort queued input buffers not belonging to
     // any pending requests.
     if (mInputStream != NULL && notifyRequestThread) {
@@ -2384,8 +2718,7 @@ status_t Camera3Device::configureStreamsLocked(int operatingMode,
                                                                 // always occupy the initial entry.
             if (outputStream->data_space == HAL_DATASPACE_V0_JFIF) {
                 bufferSizes[k] = static_cast<uint32_t>(
-                        getJpegBufferSize(infoPhysical(String8(outputStream->physical_camera_id)),
-                                outputStream->width, outputStream->height));
+                        getJpegBufferSize(outputStream->width, outputStream->height));
             } else if (outputStream->data_space ==
                     static_cast<android_dataspace>(HAL_DATASPACE_JPEG_APP_SEGMENTS)) {
                 bufferSizes[k] = outputStream->width * outputStream->height;
@@ -2673,7 +3006,7 @@ void Camera3Device::setErrorStateLockedV(const char *fmt, va_list args) {
 
 status_t Camera3Device::registerInFlight(uint32_t frameNumber,
         int32_t numBuffers, CaptureResultExtras resultExtras, bool hasInput,
-        bool hasAppCallback, nsecs_t minExpectedDuration, nsecs_t maxExpectedDuration,
+        bool hasAppCallback, nsecs_t maxExpectedDuration,
         const std::set<std::set<String8>>& physicalCameraIds,
         bool isStillCapture, bool isZslCapture, bool rotateAndCropAuto,
         const std::set<std::string>& cameraIdsWithZoom,
@@ -2683,9 +3016,8 @@ status_t Camera3Device::registerInFlight(uint32_t frameNumber,
 
     ssize_t res;
     res = mInFlightMap.add(frameNumber, InFlightRequest(numBuffers, resultExtras, hasInput,
-            hasAppCallback, minExpectedDuration, maxExpectedDuration, physicalCameraIds,
-            isStillCapture, isZslCapture, rotateAndCropAuto, cameraIdsWithZoom, requestTimeNs,
-            outputSurfaces));
+            hasAppCallback, maxExpectedDuration, physicalCameraIds, isStillCapture, isZslCapture,
+            rotateAndCropAuto, cameraIdsWithZoom, requestTimeNs, outputSurfaces));
     if (res < 0) return res;
 
     if (mInFlightMap.size() == 1) {
@@ -2782,98 +3114,1090 @@ void Camera3Device::monitorMetadata(TagMonitor::eventSource source,
             physicalMetadata, outputBuffers, numOutputBuffers, inputStreamId);
 }
 
-void Camera3Device::cleanupNativeHandles(
-        std::vector<native_handle_t*> *handles, bool closeFd) {
-    if (handles == nullptr) {
-        return;
-    }
-    if (closeFd) {
-        for (auto& handle : *handles) {
-            native_handle_close(handle);
-        }
-    }
-    for (auto& handle : *handles) {
-        native_handle_delete(handle);
-    }
-    handles->clear();
-    return;
-}
-
 /**
  * HalInterface inner class methods
  */
 
-void Camera3Device::HalInterface::getInflightBufferKeys(
-        std::vector<std::pair<int32_t, int32_t>>* out) {
-    mBufferRecords.getInflightBufferKeys(out);
-    return;
-}
-
-void Camera3Device::HalInterface::getInflightRequestBufferKeys(
-        std::vector<uint64_t>* out) {
-    mBufferRecords.getInflightRequestBufferKeys(out);
-    return;
+Camera3Device::HalInterface::HalInterface(
+            sp<ICameraDeviceSession> &session,
+            std::shared_ptr<RequestMetadataQueue> queue,
+            bool useHalBufManager, bool supportOfflineProcessing) :
+        mHidlSession(session),
+        mRequestMetadataQueue(queue),
+        mUseHalBufManager(useHalBufManager),
+        mIsReconfigurationQuerySupported(true),
+        mSupportOfflineProcessing(supportOfflineProcessing) {
+    // Check with hardware service manager if we can downcast these interfaces
+    // Somewhat expensive, so cache the results at startup
+    auto castResult_3_7 = device::V3_7::ICameraDeviceSession::castFrom(mHidlSession);
+    if (castResult_3_7.isOk()) {
+        mHidlSession_3_7 = castResult_3_7;
+    }
+    auto castResult_3_6 = device::V3_6::ICameraDeviceSession::castFrom(mHidlSession);
+    if (castResult_3_6.isOk()) {
+        mHidlSession_3_6 = castResult_3_6;
+    }
+    auto castResult_3_5 = device::V3_5::ICameraDeviceSession::castFrom(mHidlSession);
+    if (castResult_3_5.isOk()) {
+        mHidlSession_3_5 = castResult_3_5;
+    }
+    auto castResult_3_4 = device::V3_4::ICameraDeviceSession::castFrom(mHidlSession);
+    if (castResult_3_4.isOk()) {
+        mHidlSession_3_4 = castResult_3_4;
+    }
+    auto castResult_3_3 = device::V3_3::ICameraDeviceSession::castFrom(mHidlSession);
+    if (castResult_3_3.isOk()) {
+        mHidlSession_3_3 = castResult_3_3;
+    }
 }
 
-bool Camera3Device::HalInterface::verifyBufferIds(
-        int32_t streamId, std::vector<uint64_t>& bufIds) {
-    return mBufferRecords.verifyBufferIds(streamId, bufIds);
-}
+Camera3Device::HalInterface::HalInterface() :
+        mUseHalBufManager(false),
+        mSupportOfflineProcessing(false) {}
 
-status_t Camera3Device::HalInterface::popInflightBuffer(
-        int32_t frameNumber, int32_t streamId,
-        /*out*/ buffer_handle_t **buffer) {
-    return mBufferRecords.popInflightBuffer(frameNumber, streamId, buffer);
-}
+Camera3Device::HalInterface::HalInterface(const HalInterface& other) :
+        mHidlSession(other.mHidlSession),
+        mRequestMetadataQueue(other.mRequestMetadataQueue),
+        mUseHalBufManager(other.mUseHalBufManager),
+        mSupportOfflineProcessing(other.mSupportOfflineProcessing) {}
 
-status_t Camera3Device::HalInterface::pushInflightRequestBuffer(
-        uint64_t bufferId, buffer_handle_t* buf, int32_t streamId) {
-    return mBufferRecords.pushInflightRequestBuffer(bufferId, buf, streamId);
+bool Camera3Device::HalInterface::valid() {
+    return (mHidlSession != nullptr);
 }
 
-// Find and pop a buffer_handle_t based on bufferId
-status_t Camera3Device::HalInterface::popInflightRequestBuffer(
-        uint64_t bufferId,
-        /*out*/ buffer_handle_t** buffer,
-        /*optional out*/ int32_t* streamId) {
-    return mBufferRecords.popInflightRequestBuffer(bufferId, buffer, streamId);
+void Camera3Device::HalInterface::clear() {
+    mHidlSession_3_7.clear();
+    mHidlSession_3_6.clear();
+    mHidlSession_3_5.clear();
+    mHidlSession_3_4.clear();
+    mHidlSession_3_3.clear();
+    mHidlSession.clear();
 }
 
-std::pair<bool, uint64_t> Camera3Device::HalInterface::getBufferId(
-        const buffer_handle_t& buf, int streamId) {
-    return mBufferRecords.getBufferId(buf, streamId);
-}
+status_t Camera3Device::HalInterface::constructDefaultRequestSettings(
+        camera_request_template_t templateId,
+        /*out*/ camera_metadata_t **requestTemplate) {
+    ATRACE_NAME("CameraHal::constructDefaultRequestSettings");
+    if (!valid()) return INVALID_OPERATION;
+    status_t res = OK;
 
-uint64_t Camera3Device::HalInterface::removeOneBufferCache(int streamId,
-        const native_handle_t* handle) {
-    return mBufferRecords.removeOneBufferCache(streamId, handle);
-}
+    common::V1_0::Status status;
+
+    auto requestCallback = [&status, &requestTemplate]
+            (common::V1_0::Status s, const device::V3_2::CameraMetadata& request) {
+            status = s;
+            if (status == common::V1_0::Status::OK) {
+                const camera_metadata *r =
+                        reinterpret_cast<const camera_metadata_t*>(request.data());
+                size_t expectedSize = request.size();
+                int ret = validate_camera_metadata_structure(r, &expectedSize);
+                if (ret == OK || ret == CAMERA_METADATA_VALIDATION_SHIFTED) {
+                    *requestTemplate = clone_camera_metadata(r);
+                    if (*requestTemplate == nullptr) {
+                        ALOGE("%s: Unable to clone camera metadata received from HAL",
+                                __FUNCTION__);
+                        status = common::V1_0::Status::INTERNAL_ERROR;
+                    }
+                } else {
+                    ALOGE("%s: Malformed camera metadata received from HAL", __FUNCTION__);
+                    status = common::V1_0::Status::INTERNAL_ERROR;
+                }
+            }
+        };
+    hardware::Return<void> err;
+    RequestTemplate id;
+    switch (templateId) {
+        case CAMERA_TEMPLATE_PREVIEW:
+            id = RequestTemplate::PREVIEW;
+            break;
+        case CAMERA_TEMPLATE_STILL_CAPTURE:
+            id = RequestTemplate::STILL_CAPTURE;
+            break;
+        case CAMERA_TEMPLATE_VIDEO_RECORD:
+            id = RequestTemplate::VIDEO_RECORD;
+            break;
+        case CAMERA_TEMPLATE_VIDEO_SNAPSHOT:
+            id = RequestTemplate::VIDEO_SNAPSHOT;
+            break;
+        case CAMERA_TEMPLATE_ZERO_SHUTTER_LAG:
+            id = RequestTemplate::ZERO_SHUTTER_LAG;
+            break;
+        case CAMERA_TEMPLATE_MANUAL:
+            id = RequestTemplate::MANUAL;
+            break;
+        default:
+            // Unknown template ID, or this HAL is too old to support it
+            return BAD_VALUE;
+    }
+    err = mHidlSession->constructDefaultRequestSettings(id, requestCallback);
 
-void Camera3Device::HalInterface::onBufferFreed(
-        int streamId, const native_handle_t* handle) {
-    uint32_t bufferId = mBufferRecords.removeOneBufferCache(streamId, handle);
-    std::lock_guard<std::mutex> lock(mFreedBuffersLock);
-    if (bufferId != BUFFER_ID_NO_BUFFER) {
-        mFreedBuffers.push_back(std::make_pair(streamId, bufferId));
+    if (!err.isOk()) {
+        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
+        res = DEAD_OBJECT;
+    } else {
+        res = CameraProviderManager::mapToStatusT(status);
     }
+
+    return res;
 }
 
-void Camera3Device::HalInterface::onStreamReConfigured(int streamId) {
-    std::vector<uint64_t> bufIds = mBufferRecords.clearBufferCaches(streamId);
-    std::lock_guard<std::mutex> lock(mFreedBuffersLock);
-    for (auto bufferId : bufIds) {
-        mFreedBuffers.push_back(std::make_pair(streamId, bufferId));
+bool Camera3Device::HalInterface::isReconfigurationRequired(CameraMetadata& oldSessionParams,
+        CameraMetadata& newSessionParams) {
+    // We do reconfiguration by default;
+    bool ret = true;
+    if ((mHidlSession_3_5 != nullptr) && mIsReconfigurationQuerySupported) {
+        android::hardware::hidl_vec<uint8_t> oldParams, newParams;
+        camera_metadata_t* oldSessioMeta = const_cast<camera_metadata_t*>(
+                oldSessionParams.getAndLock());
+        camera_metadata_t* newSessioMeta = const_cast<camera_metadata_t*>(
+                newSessionParams.getAndLock());
+        oldParams.setToExternal(reinterpret_cast<uint8_t*>(oldSessioMeta),
+                get_camera_metadata_size(oldSessioMeta));
+        newParams.setToExternal(reinterpret_cast<uint8_t*>(newSessioMeta),
+                get_camera_metadata_size(newSessioMeta));
+        hardware::camera::common::V1_0::Status callStatus;
+        bool required;
+        auto hidlCb = [&callStatus, &required] (hardware::camera::common::V1_0::Status s,
+                bool requiredFlag) {
+            callStatus = s;
+            required = requiredFlag;
+        };
+        auto err = mHidlSession_3_5->isReconfigurationRequired(oldParams, newParams, hidlCb);
+        oldSessionParams.unlock(oldSessioMeta);
+        newSessionParams.unlock(newSessioMeta);
+        if (err.isOk()) {
+            switch (callStatus) {
+                case hardware::camera::common::V1_0::Status::OK:
+                    ret = required;
+                    break;
+                case hardware::camera::common::V1_0::Status::METHOD_NOT_SUPPORTED:
+                    mIsReconfigurationQuerySupported = false;
+                    ret = true;
+                    break;
+                default:
+                    ALOGV("%s: Reconfiguration query failed: %d", __FUNCTION__, callStatus);
+                    ret = true;
+            }
+        } else {
+            ALOGE("%s: Unexpected binder error: %s", __FUNCTION__, err.description().c_str());
+            ret = true;
+        }
     }
+
+    return ret;
 }
 
-/**
- * RequestThread inner class methods
- */
+status_t Camera3Device::HalInterface::configureStreams(const camera_metadata_t *sessionParams,
+        camera_stream_configuration *config, const std::vector<uint32_t>& bufferSizes) {
+    ATRACE_NAME("CameraHal::configureStreams");
+    if (!valid()) return INVALID_OPERATION;
+    status_t res = OK;
 
-Camera3Device::RequestThread::RequestThread(wp<Camera3Device> parent,
-        sp<StatusTracker> statusTracker,
-        sp<HalInterface> interface, const Vector<int32_t>& sessionParamKeys,
-        bool useHalBufManager,
+    if (config->input_is_multi_resolution && mHidlSession_3_7 == nullptr) {
+        ALOGE("%s: Camera device doesn't support multi-resolution input stream", __FUNCTION__);
+        return BAD_VALUE;
+    }
+
+    // Convert stream config to HIDL
+    std::set<int> activeStreams;
+    device::V3_2::StreamConfiguration requestedConfiguration3_2;
+    device::V3_4::StreamConfiguration requestedConfiguration3_4;
+    device::V3_7::StreamConfiguration requestedConfiguration3_7;
+    requestedConfiguration3_2.streams.resize(config->num_streams);
+    requestedConfiguration3_4.streams.resize(config->num_streams);
+    requestedConfiguration3_7.streams.resize(config->num_streams);
+    for (size_t i = 0; i < config->num_streams; i++) {
+        device::V3_2::Stream &dst3_2 = requestedConfiguration3_2.streams[i];
+        device::V3_4::Stream &dst3_4 = requestedConfiguration3_4.streams[i];
+        device::V3_7::Stream &dst3_7 = requestedConfiguration3_7.streams[i];
+        camera3::camera_stream_t *src = config->streams[i];
+
+        Camera3Stream* cam3stream = Camera3Stream::cast(src);
+        cam3stream->setBufferFreedListener(this);
+        int streamId = cam3stream->getId();
+        StreamType streamType;
+        switch (src->stream_type) {
+            case CAMERA_STREAM_OUTPUT:
+                streamType = StreamType::OUTPUT;
+                break;
+            case CAMERA_STREAM_INPUT:
+                streamType = StreamType::INPUT;
+                break;
+            default:
+                ALOGE("%s: Stream %d: Unsupported stream type %d",
+                        __FUNCTION__, streamId, config->streams[i]->stream_type);
+                return BAD_VALUE;
+        }
+        dst3_2.id = streamId;
+        dst3_2.streamType = streamType;
+        dst3_2.width = src->width;
+        dst3_2.height = src->height;
+        dst3_2.usage = mapToConsumerUsage(cam3stream->getUsage());
+        dst3_2.rotation = mapToStreamRotation((camera_stream_rotation_t) src->rotation);
+        // For HidlSession version 3.5 or newer, the format and dataSpace sent
+        // to HAL are original, not the overridden ones.
+        if (mHidlSession_3_5 != nullptr) {
+            dst3_2.format = mapToPixelFormat(cam3stream->isFormatOverridden() ?
+                    cam3stream->getOriginalFormat() : src->format);
+            dst3_2.dataSpace = mapToHidlDataspace(cam3stream->isDataSpaceOverridden() ?
+                    cam3stream->getOriginalDataSpace() : src->data_space);
+        } else {
+            dst3_2.format = mapToPixelFormat(src->format);
+            dst3_2.dataSpace = mapToHidlDataspace(src->data_space);
+        }
+        dst3_4.v3_2 = dst3_2;
+        dst3_4.bufferSize = bufferSizes[i];
+        if (src->physical_camera_id != nullptr) {
+            dst3_4.physicalCameraId = src->physical_camera_id;
+        }
+        dst3_7.v3_4 = dst3_4;
+        dst3_7.groupId = cam3stream->getHalStreamGroupId();
+        dst3_7.sensorPixelModesUsed.resize(src->sensor_pixel_modes_used.size());
+        size_t j = 0;
+        for (int mode : src->sensor_pixel_modes_used) {
+            dst3_7.sensorPixelModesUsed[j++] =
+                    static_cast<CameraMetadataEnumAndroidSensorPixelMode>(mode);
+        }
+        activeStreams.insert(streamId);
+        // Create Buffer ID map if necessary
+        mBufferRecords.tryCreateBufferCache(streamId);
+    }
+    // remove BufferIdMap for deleted streams
+    mBufferRecords.removeInactiveBufferCaches(activeStreams);
+
+    StreamConfigurationMode operationMode;
+    res = mapToStreamConfigurationMode(
+            (camera_stream_configuration_mode_t) config->operation_mode,
+            /*out*/ &operationMode);
+    if (res != OK) {
+        return res;
+    }
+    requestedConfiguration3_2.operationMode = operationMode;
+    requestedConfiguration3_4.operationMode = operationMode;
+    requestedConfiguration3_7.operationMode = operationMode;
+    size_t sessionParamSize = get_camera_metadata_size(sessionParams);
+    requestedConfiguration3_4.sessionParams.setToExternal(
+            reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(sessionParams)),
+            sessionParamSize);
+    requestedConfiguration3_7.operationMode = operationMode;
+    requestedConfiguration3_7.sessionParams.setToExternal(
+            reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(sessionParams)),
+            sessionParamSize);
+
+    // Invoke configureStreams
+    device::V3_3::HalStreamConfiguration finalConfiguration;
+    device::V3_4::HalStreamConfiguration finalConfiguration3_4;
+    device::V3_6::HalStreamConfiguration finalConfiguration3_6;
+    common::V1_0::Status status;
+
+    auto configStream34Cb = [&status, &finalConfiguration3_4]
+            (common::V1_0::Status s, const device::V3_4::HalStreamConfiguration& halConfiguration) {
+                finalConfiguration3_4 = halConfiguration;
+                status = s;
+            };
+
+    auto configStream36Cb = [&status, &finalConfiguration3_6]
+            (common::V1_0::Status s, const device::V3_6::HalStreamConfiguration& halConfiguration) {
+                finalConfiguration3_6 = halConfiguration;
+                status = s;
+            };
+
+    auto postprocConfigStream34 = [&finalConfiguration, &finalConfiguration3_4]
+            (hardware::Return<void>& err) -> status_t {
+                if (!err.isOk()) {
+                    ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
+                    return DEAD_OBJECT;
+                }
+                finalConfiguration.streams.resize(finalConfiguration3_4.streams.size());
+                for (size_t i = 0; i < finalConfiguration3_4.streams.size(); i++) {
+                    finalConfiguration.streams[i] = finalConfiguration3_4.streams[i].v3_3;
+                }
+                return OK;
+            };
+
+    auto postprocConfigStream36 = [&finalConfiguration, &finalConfiguration3_6]
+            (hardware::Return<void>& err) -> status_t {
+                if (!err.isOk()) {
+                    ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
+                    return DEAD_OBJECT;
+                }
+                finalConfiguration.streams.resize(finalConfiguration3_6.streams.size());
+                for (size_t i = 0; i < finalConfiguration3_6.streams.size(); i++) {
+                    finalConfiguration.streams[i] = finalConfiguration3_6.streams[i].v3_4.v3_3;
+                }
+                return OK;
+            };
+
+    // See which version of HAL we have
+    if (mHidlSession_3_7 != nullptr) {
+        ALOGV("%s: v3.7 device found", __FUNCTION__);
+        requestedConfiguration3_7.streamConfigCounter = mNextStreamConfigCounter++;
+        requestedConfiguration3_7.multiResolutionInputImage = config->input_is_multi_resolution;
+        auto err = mHidlSession_3_7->configureStreams_3_7(
+                requestedConfiguration3_7, configStream36Cb);
+        res = postprocConfigStream36(err);
+        if (res != OK) {
+            return res;
+        }
+    } else if (mHidlSession_3_6 != nullptr) {
+        ALOGV("%s: v3.6 device found", __FUNCTION__);
+        device::V3_5::StreamConfiguration requestedConfiguration3_5;
+        requestedConfiguration3_5.v3_4 = requestedConfiguration3_4;
+        requestedConfiguration3_5.streamConfigCounter = mNextStreamConfigCounter++;
+        auto err = mHidlSession_3_6->configureStreams_3_6(
+                requestedConfiguration3_5, configStream36Cb);
+        res = postprocConfigStream36(err);
+        if (res != OK) {
+            return res;
+        }
+    } else if (mHidlSession_3_5 != nullptr) {
+        ALOGV("%s: v3.5 device found", __FUNCTION__);
+        device::V3_5::StreamConfiguration requestedConfiguration3_5;
+        requestedConfiguration3_5.v3_4 = requestedConfiguration3_4;
+        requestedConfiguration3_5.streamConfigCounter = mNextStreamConfigCounter++;
+        auto err = mHidlSession_3_5->configureStreams_3_5(
+                requestedConfiguration3_5, configStream34Cb);
+        res = postprocConfigStream34(err);
+        if (res != OK) {
+            return res;
+        }
+    } else if (mHidlSession_3_4 != nullptr) {
+        // We do; use v3.4 for the call
+        ALOGV("%s: v3.4 device found", __FUNCTION__);
+        auto err = mHidlSession_3_4->configureStreams_3_4(
+                requestedConfiguration3_4, configStream34Cb);
+        res = postprocConfigStream34(err);
+        if (res != OK) {
+            return res;
+        }
+    } else if (mHidlSession_3_3 != nullptr) {
+        // We do; use v3.3 for the call
+        ALOGV("%s: v3.3 device found", __FUNCTION__);
+        auto err = mHidlSession_3_3->configureStreams_3_3(requestedConfiguration3_2,
+            [&status, &finalConfiguration]
+            (common::V1_0::Status s, const device::V3_3::HalStreamConfiguration& halConfiguration) {
+                finalConfiguration = halConfiguration;
+                status = s;
+            });
+        if (!err.isOk()) {
+            ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
+            return DEAD_OBJECT;
+        }
+    } else {
+        // We don't; use v3.2 call and construct a v3.3 HalStreamConfiguration
+        ALOGV("%s: v3.2 device found", __FUNCTION__);
+        HalStreamConfiguration finalConfiguration_3_2;
+        auto err = mHidlSession->configureStreams(requestedConfiguration3_2,
+                [&status, &finalConfiguration_3_2]
+                (common::V1_0::Status s, const HalStreamConfiguration& halConfiguration) {
+                    finalConfiguration_3_2 = halConfiguration;
+                    status = s;
+                });
+        if (!err.isOk()) {
+            ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
+            return DEAD_OBJECT;
+        }
+        finalConfiguration.streams.resize(finalConfiguration_3_2.streams.size());
+        for (size_t i = 0; i < finalConfiguration_3_2.streams.size(); i++) {
+            finalConfiguration.streams[i].v3_2 = finalConfiguration_3_2.streams[i];
+            finalConfiguration.streams[i].overrideDataSpace =
+                    requestedConfiguration3_2.streams[i].dataSpace;
+        }
+    }
+
+    if (status != common::V1_0::Status::OK ) {
+        return CameraProviderManager::mapToStatusT(status);
+    }
+
+    // And convert output stream configuration from HIDL
+
+    for (size_t i = 0; i < config->num_streams; i++) {
+        camera3::camera_stream_t *dst = config->streams[i];
+        int streamId = Camera3Stream::cast(dst)->getId();
+
+        // Start scan at i, with the assumption that the stream order matches
+        size_t realIdx = i;
+        bool found = false;
+        size_t halStreamCount = finalConfiguration.streams.size();
+        for (size_t idx = 0; idx < halStreamCount; idx++) {
+            if (finalConfiguration.streams[realIdx].v3_2.id == streamId) {
+                found = true;
+                break;
+            }
+            realIdx = (realIdx >= halStreamCount - 1) ? 0 : realIdx + 1;
+        }
+        if (!found) {
+            ALOGE("%s: Stream %d not found in stream configuration response from HAL",
+                    __FUNCTION__, streamId);
+            return INVALID_OPERATION;
+        }
+        device::V3_3::HalStream &src = finalConfiguration.streams[realIdx];
+        device::V3_6::HalStream &src_36 = finalConfiguration3_6.streams[realIdx];
+
+        Camera3Stream* dstStream = Camera3Stream::cast(dst);
+        int overrideFormat = mapToFrameworkFormat(src.v3_2.overrideFormat);
+        android_dataspace overrideDataSpace = mapToFrameworkDataspace(src.overrideDataSpace);
+
+        if (mHidlSession_3_6 != nullptr) {
+            dstStream->setOfflineProcessingSupport(src_36.supportOffline);
+        }
+
+        if (dstStream->getOriginalFormat() != HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED) {
+            dstStream->setFormatOverride(false);
+            dstStream->setDataSpaceOverride(false);
+            if (dst->format != overrideFormat) {
+                ALOGE("%s: Stream %d: Format override not allowed for format 0x%x", __FUNCTION__,
+                        streamId, dst->format);
+            }
+            if (dst->data_space != overrideDataSpace) {
+                ALOGE("%s: Stream %d: DataSpace override not allowed for format 0x%x", __FUNCTION__,
+                        streamId, dst->format);
+            }
+        } else {
+            bool needFormatOverride =
+                    requestedConfiguration3_2.streams[i].format != src.v3_2.overrideFormat;
+            bool needDataspaceOverride =
+                    requestedConfiguration3_2.streams[i].dataSpace != src.overrideDataSpace;
+            // Override allowed with IMPLEMENTATION_DEFINED
+            dstStream->setFormatOverride(needFormatOverride);
+            dstStream->setDataSpaceOverride(needDataspaceOverride);
+            dst->format = overrideFormat;
+            dst->data_space = overrideDataSpace;
+        }
+
+        if (dst->stream_type == CAMERA_STREAM_INPUT) {
+            if (src.v3_2.producerUsage != 0) {
+                ALOGE("%s: Stream %d: INPUT streams must have 0 for producer usage",
+                        __FUNCTION__, streamId);
+                return INVALID_OPERATION;
+            }
+            dstStream->setUsage(
+                    mapConsumerToFrameworkUsage(src.v3_2.consumerUsage));
+        } else {
+            // OUTPUT
+            if (src.v3_2.consumerUsage != 0) {
+                ALOGE("%s: Stream %d: OUTPUT streams must have 0 for consumer usage",
+                        __FUNCTION__, streamId);
+                return INVALID_OPERATION;
+            }
+            dstStream->setUsage(
+                    mapProducerToFrameworkUsage(src.v3_2.producerUsage));
+        }
+        dst->max_buffers = src.v3_2.maxBuffers;
+    }
+
+    return res;
+}
+
+status_t Camera3Device::HalInterface::configureInjectedStreams(
+        const camera_metadata_t* sessionParams, camera_stream_configuration* config,
+        const std::vector<uint32_t>& bufferSizes,
+        const CameraMetadata& cameraCharacteristics) {
+    ATRACE_NAME("InjectionCameraHal::configureStreams");
+    if (!valid()) return INVALID_OPERATION;
+    status_t res = OK;
+
+    if (config->input_is_multi_resolution) {
+        ALOGE("%s: Injection camera device doesn't support multi-resolution input "
+                "stream", __FUNCTION__);
+        return BAD_VALUE;
+    }
+
+    // Convert stream config to HIDL
+    std::set<int> activeStreams;
+    device::V3_2::StreamConfiguration requestedConfiguration3_2;
+    device::V3_4::StreamConfiguration requestedConfiguration3_4;
+    device::V3_7::StreamConfiguration requestedConfiguration3_7;
+    requestedConfiguration3_2.streams.resize(config->num_streams);
+    requestedConfiguration3_4.streams.resize(config->num_streams);
+    requestedConfiguration3_7.streams.resize(config->num_streams);
+    for (size_t i = 0; i < config->num_streams; i++) {
+        device::V3_2::Stream& dst3_2 = requestedConfiguration3_2.streams[i];
+        device::V3_4::Stream& dst3_4 = requestedConfiguration3_4.streams[i];
+        device::V3_7::Stream& dst3_7 = requestedConfiguration3_7.streams[i];
+        camera3::camera_stream_t* src = config->streams[i];
+
+        Camera3Stream* cam3stream = Camera3Stream::cast(src);
+        cam3stream->setBufferFreedListener(this);
+        int streamId = cam3stream->getId();
+        StreamType streamType;
+        switch (src->stream_type) {
+            case CAMERA_STREAM_OUTPUT:
+                streamType = StreamType::OUTPUT;
+                break;
+            case CAMERA_STREAM_INPUT:
+                streamType = StreamType::INPUT;
+                break;
+            default:
+                ALOGE("%s: Stream %d: Unsupported stream type %d", __FUNCTION__,
+                        streamId, config->streams[i]->stream_type);
+            return BAD_VALUE;
+        }
+        dst3_2.id = streamId;
+        dst3_2.streamType = streamType;
+        dst3_2.width = src->width;
+        dst3_2.height = src->height;
+        dst3_2.usage = mapToConsumerUsage(cam3stream->getUsage());
+        dst3_2.rotation =
+                mapToStreamRotation((camera_stream_rotation_t)src->rotation);
+        // For HidlSession version 3.5 or newer, the format and dataSpace sent
+        // to HAL are original, not the overridden ones.
+        if (mHidlSession_3_5 != nullptr) {
+            dst3_2.format = mapToPixelFormat(cam3stream->isFormatOverridden()
+                                            ? cam3stream->getOriginalFormat()
+                                            : src->format);
+            dst3_2.dataSpace =
+                    mapToHidlDataspace(cam3stream->isDataSpaceOverridden()
+                                    ? cam3stream->getOriginalDataSpace()
+                                    : src->data_space);
+        } else {
+            dst3_2.format = mapToPixelFormat(src->format);
+            dst3_2.dataSpace = mapToHidlDataspace(src->data_space);
+        }
+        dst3_4.v3_2 = dst3_2;
+        dst3_4.bufferSize = bufferSizes[i];
+        if (src->physical_camera_id != nullptr) {
+            dst3_4.physicalCameraId = src->physical_camera_id;
+        }
+        dst3_7.v3_4 = dst3_4;
+        dst3_7.groupId = cam3stream->getHalStreamGroupId();
+        dst3_7.sensorPixelModesUsed.resize(src->sensor_pixel_modes_used.size());
+        size_t j = 0;
+        for (int mode : src->sensor_pixel_modes_used) {
+            dst3_7.sensorPixelModesUsed[j++] =
+                    static_cast<CameraMetadataEnumAndroidSensorPixelMode>(mode);
+        }
+        activeStreams.insert(streamId);
+        // Create Buffer ID map if necessary
+        mBufferRecords.tryCreateBufferCache(streamId);
+    }
+    // remove BufferIdMap for deleted streams
+    mBufferRecords.removeInactiveBufferCaches(activeStreams);
+
+    StreamConfigurationMode operationMode;
+    res = mapToStreamConfigurationMode(
+            (camera_stream_configuration_mode_t)config->operation_mode,
+            /*out*/ &operationMode);
+    if (res != OK) {
+        return res;
+    }
+    requestedConfiguration3_7.operationMode = operationMode;
+    size_t sessionParamSize = get_camera_metadata_size(sessionParams);
+    requestedConfiguration3_7.operationMode = operationMode;
+    requestedConfiguration3_7.sessionParams.setToExternal(
+            reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(sessionParams)),
+            sessionParamSize);
+
+    // See which version of HAL we have
+    if (mHidlSession_3_7 != nullptr) {
+        requestedConfiguration3_7.streamConfigCounter = mNextStreamConfigCounter++;
+        requestedConfiguration3_7.multiResolutionInputImage =
+                config->input_is_multi_resolution;
+
+        const camera_metadata_t* rawMetadata = cameraCharacteristics.getAndLock();
+        ::android::hardware::camera::device::V3_2::CameraMetadata hidlChars = {};
+        hidlChars.setToExternal(
+                reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(rawMetadata)),
+                get_camera_metadata_size(rawMetadata));
+        cameraCharacteristics.unlock(rawMetadata);
+
+        sp<hardware::camera::device::V3_7::ICameraInjectionSession>
+                hidlInjectionSession_3_7;
+        auto castInjectionResult_3_7 =
+                device::V3_7::ICameraInjectionSession::castFrom(mHidlSession_3_7);
+        if (castInjectionResult_3_7.isOk()) {
+            hidlInjectionSession_3_7 = castInjectionResult_3_7;
+        } else {
+            ALOGE("%s: Transaction error: %s", __FUNCTION__,
+                    castInjectionResult_3_7.description().c_str());
+            return DEAD_OBJECT;
+        }
+
+        auto err = hidlInjectionSession_3_7->configureInjectionStreams(
+                requestedConfiguration3_7, hidlChars);
+        if (!err.isOk()) {
+            ALOGE("%s: Transaction error: %s", __FUNCTION__,
+                    err.description().c_str());
+            return DEAD_OBJECT;
+        }
+    } else {
+        ALOGE("%s: mHidlSession_3_7 does not exist, the lowest version of injection "
+                "session is 3.7", __FUNCTION__);
+        return DEAD_OBJECT;
+    }
+
+    return res;
+}
+
+status_t Camera3Device::HalInterface::wrapAsHidlRequest(camera_capture_request_t* request,
+        /*out*/device::V3_2::CaptureRequest* captureRequest,
+        /*out*/std::vector<native_handle_t*>* handlesCreated,
+        /*out*/std::vector<std::pair<int32_t, int32_t>>* inflightBuffers) {
+    ATRACE_CALL();
+    if (captureRequest == nullptr || handlesCreated == nullptr || inflightBuffers == nullptr) {
+        ALOGE("%s: captureRequest (%p), handlesCreated (%p), and inflightBuffers(%p) "
+                "must not be null", __FUNCTION__, captureRequest, handlesCreated, inflightBuffers);
+        return BAD_VALUE;
+    }
+
+    captureRequest->frameNumber = request->frame_number;
+
+    captureRequest->fmqSettingsSize = 0;
+
+    {
+        if (request->input_buffer != nullptr) {
+            int32_t streamId = Camera3Stream::cast(request->input_buffer->stream)->getId();
+            buffer_handle_t buf = *(request->input_buffer->buffer);
+            auto pair = getBufferId(buf, streamId);
+            bool isNewBuffer = pair.first;
+            uint64_t bufferId = pair.second;
+            captureRequest->inputBuffer.streamId = streamId;
+            captureRequest->inputBuffer.bufferId = bufferId;
+            captureRequest->inputBuffer.buffer = (isNewBuffer) ? buf : nullptr;
+            captureRequest->inputBuffer.status = BufferStatus::OK;
+            native_handle_t *acquireFence = nullptr;
+            if (request->input_buffer->acquire_fence != -1) {
+                acquireFence = native_handle_create(1,0);
+                acquireFence->data[0] = request->input_buffer->acquire_fence;
+                handlesCreated->push_back(acquireFence);
+            }
+            captureRequest->inputBuffer.acquireFence = acquireFence;
+            captureRequest->inputBuffer.releaseFence = nullptr;
+
+            mBufferRecords.pushInflightBuffer(captureRequest->frameNumber, streamId,
+                    request->input_buffer->buffer);
+            inflightBuffers->push_back(std::make_pair(captureRequest->frameNumber, streamId));
+        } else {
+            captureRequest->inputBuffer.streamId = -1;
+            captureRequest->inputBuffer.bufferId = BUFFER_ID_NO_BUFFER;
+        }
+
+        captureRequest->outputBuffers.resize(request->num_output_buffers);
+        for (size_t i = 0; i < request->num_output_buffers; i++) {
+            const camera_stream_buffer_t *src = request->output_buffers + i;
+            StreamBuffer &dst = captureRequest->outputBuffers[i];
+            int32_t streamId = Camera3Stream::cast(src->stream)->getId();
+            if (src->buffer != nullptr) {
+                buffer_handle_t buf = *(src->buffer);
+                auto pair = getBufferId(buf, streamId);
+                bool isNewBuffer = pair.first;
+                dst.bufferId = pair.second;
+                dst.buffer = isNewBuffer ? buf : nullptr;
+                native_handle_t *acquireFence = nullptr;
+                if (src->acquire_fence != -1) {
+                    acquireFence = native_handle_create(1,0);
+                    acquireFence->data[0] = src->acquire_fence;
+                    handlesCreated->push_back(acquireFence);
+                }
+                dst.acquireFence = acquireFence;
+            } else if (mUseHalBufManager) {
+                // HAL buffer management path
+                dst.bufferId = BUFFER_ID_NO_BUFFER;
+                dst.buffer = nullptr;
+                dst.acquireFence = nullptr;
+            } else {
+                ALOGE("%s: cannot send a null buffer in capture request!", __FUNCTION__);
+                return BAD_VALUE;
+            }
+            dst.streamId = streamId;
+            dst.status = BufferStatus::OK;
+            dst.releaseFence = nullptr;
+
+            // Output buffers are empty when using HAL buffer manager
+            if (!mUseHalBufManager) {
+                mBufferRecords.pushInflightBuffer(
+                        captureRequest->frameNumber, streamId, src->buffer);
+                inflightBuffers->push_back(std::make_pair(captureRequest->frameNumber, streamId));
+            }
+        }
+    }
+    return OK;
+}
+
+void Camera3Device::HalInterface::cleanupNativeHandles(
+        std::vector<native_handle_t*> *handles, bool closeFd) {
+    if (handles == nullptr) {
+        return;
+    }
+    if (closeFd) {
+        for (auto& handle : *handles) {
+            native_handle_close(handle);
+        }
+    }
+    for (auto& handle : *handles) {
+        native_handle_delete(handle);
+    }
+    handles->clear();
+    return;
+}
+
+status_t Camera3Device::HalInterface::processBatchCaptureRequests(
+        std::vector<camera_capture_request_t*>& requests,/*out*/uint32_t* numRequestProcessed) {
+    ATRACE_NAME("CameraHal::processBatchCaptureRequests");
+    if (!valid()) return INVALID_OPERATION;
+
+    sp<device::V3_4::ICameraDeviceSession> hidlSession_3_4;
+    sp<device::V3_7::ICameraDeviceSession> hidlSession_3_7;
+    auto castResult_3_7 = device::V3_7::ICameraDeviceSession::castFrom(mHidlSession);
+    if (castResult_3_7.isOk()) {
+        hidlSession_3_7 = castResult_3_7;
+    }
+    auto castResult_3_4 = device::V3_4::ICameraDeviceSession::castFrom(mHidlSession);
+    if (castResult_3_4.isOk()) {
+        hidlSession_3_4 = castResult_3_4;
+    }
+
+    hardware::hidl_vec<device::V3_2::CaptureRequest> captureRequests;
+    hardware::hidl_vec<device::V3_4::CaptureRequest> captureRequests_3_4;
+    hardware::hidl_vec<device::V3_7::CaptureRequest> captureRequests_3_7;
+    size_t batchSize = requests.size();
+    if (hidlSession_3_7 != nullptr) {
+        captureRequests_3_7.resize(batchSize);
+    } else if (hidlSession_3_4 != nullptr) {
+        captureRequests_3_4.resize(batchSize);
+    } else {
+        captureRequests.resize(batchSize);
+    }
+    std::vector<native_handle_t*> handlesCreated;
+    std::vector<std::pair<int32_t, int32_t>> inflightBuffers;
+
+    status_t res = OK;
+    for (size_t i = 0; i < batchSize; i++) {
+        if (hidlSession_3_7 != nullptr) {
+            res = wrapAsHidlRequest(requests[i], /*out*/&captureRequests_3_7[i].v3_4.v3_2,
+                    /*out*/&handlesCreated, /*out*/&inflightBuffers);
+        } else if (hidlSession_3_4 != nullptr) {
+            res = wrapAsHidlRequest(requests[i], /*out*/&captureRequests_3_4[i].v3_2,
+                    /*out*/&handlesCreated, /*out*/&inflightBuffers);
+        } else {
+            res = wrapAsHidlRequest(requests[i], /*out*/&captureRequests[i],
+                    /*out*/&handlesCreated, /*out*/&inflightBuffers);
+        }
+        if (res != OK) {
+            mBufferRecords.popInflightBuffers(inflightBuffers);
+            cleanupNativeHandles(&handlesCreated);
+            return res;
+        }
+    }
+
+    std::vector<device::V3_2::BufferCache> cachesToRemove;
+    {
+        std::lock_guard<std::mutex> lock(mFreedBuffersLock);
+        for (auto& pair : mFreedBuffers) {
+            // The stream might have been removed since onBufferFreed
+            if (mBufferRecords.isStreamCached(pair.first)) {
+                cachesToRemove.push_back({pair.first, pair.second});
+            }
+        }
+        mFreedBuffers.clear();
+    }
+
+    common::V1_0::Status status = common::V1_0::Status::INTERNAL_ERROR;
+    *numRequestProcessed = 0;
+
+    // Write metadata to FMQ.
+    for (size_t i = 0; i < batchSize; i++) {
+        camera_capture_request_t* request = requests[i];
+        device::V3_2::CaptureRequest* captureRequest;
+        if (hidlSession_3_7 != nullptr) {
+            captureRequest = &captureRequests_3_7[i].v3_4.v3_2;
+        } else if (hidlSession_3_4 != nullptr) {
+            captureRequest = &captureRequests_3_4[i].v3_2;
+        } else {
+            captureRequest = &captureRequests[i];
+        }
+
+        if (request->settings != nullptr) {
+            size_t settingsSize = get_camera_metadata_size(request->settings);
+            if (mRequestMetadataQueue != nullptr && mRequestMetadataQueue->write(
+                    reinterpret_cast<const uint8_t*>(request->settings), settingsSize)) {
+                captureRequest->settings.resize(0);
+                captureRequest->fmqSettingsSize = settingsSize;
+            } else {
+                if (mRequestMetadataQueue != nullptr) {
+                    ALOGW("%s: couldn't utilize fmq, fallback to hwbinder", __FUNCTION__);
+                }
+                captureRequest->settings.setToExternal(
+                        reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(request->settings)),
+                        get_camera_metadata_size(request->settings));
+                captureRequest->fmqSettingsSize = 0u;
+            }
+        } else {
+            // A null request settings maps to a size-0 CameraMetadata
+            captureRequest->settings.resize(0);
+            captureRequest->fmqSettingsSize = 0u;
+        }
+
+        // hidl session 3.7 specific handling.
+        if (hidlSession_3_7 != nullptr) {
+            captureRequests_3_7[i].inputWidth = request->input_width;
+            captureRequests_3_7[i].inputHeight = request->input_height;
+        }
+
+        // hidl session 3.7 and 3.4 specific handling.
+        if (hidlSession_3_7 != nullptr || hidlSession_3_4 != nullptr) {
+            hardware::hidl_vec<device::V3_4::PhysicalCameraSetting>& physicalCameraSettings =
+                    (hidlSession_3_7 != nullptr) ?
+                    captureRequests_3_7[i].v3_4.physicalCameraSettings :
+                    captureRequests_3_4[i].physicalCameraSettings;
+            physicalCameraSettings.resize(request->num_physcam_settings);
+            for (size_t j = 0; j < request->num_physcam_settings; j++) {
+                if (request->physcam_settings != nullptr) {
+                    size_t settingsSize = get_camera_metadata_size(request->physcam_settings[j]);
+                    if (mRequestMetadataQueue != nullptr && mRequestMetadataQueue->write(
+                                reinterpret_cast<const uint8_t*>(request->physcam_settings[j]),
+                                settingsSize)) {
+                        physicalCameraSettings[j].settings.resize(0);
+                        physicalCameraSettings[j].fmqSettingsSize = settingsSize;
+                    } else {
+                        if (mRequestMetadataQueue != nullptr) {
+                            ALOGW("%s: couldn't utilize fmq, fallback to hwbinder", __FUNCTION__);
+                        }
+                        physicalCameraSettings[j].settings.setToExternal(
+                                reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(
+                                        request->physcam_settings[j])),
+                                get_camera_metadata_size(request->physcam_settings[j]));
+                        physicalCameraSettings[j].fmqSettingsSize = 0u;
+                    }
+                } else {
+                    physicalCameraSettings[j].fmqSettingsSize = 0u;
+                    physicalCameraSettings[j].settings.resize(0);
+                }
+                physicalCameraSettings[j].physicalCameraId = request->physcam_id[j];
+            }
+        }
+    }
+
+    hardware::details::return_status err;
+    auto resultCallback =
+        [&status, &numRequestProcessed] (auto s, uint32_t n) {
+                status = s;
+                *numRequestProcessed = n;
+        };
+    if (hidlSession_3_7 != nullptr) {
+        err = hidlSession_3_7->processCaptureRequest_3_7(captureRequests_3_7, cachesToRemove,
+                                                         resultCallback);
+    } else if (hidlSession_3_4 != nullptr) {
+        err = hidlSession_3_4->processCaptureRequest_3_4(captureRequests_3_4, cachesToRemove,
+                                                         resultCallback);
+    } else {
+        err = mHidlSession->processCaptureRequest(captureRequests, cachesToRemove,
+                                                  resultCallback);
+    }
+    if (!err.isOk()) {
+        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
+        status = common::V1_0::Status::CAMERA_DISCONNECTED;
+    }
+
+    if (status == common::V1_0::Status::OK && *numRequestProcessed != batchSize) {
+        ALOGE("%s: processCaptureRequest returns OK but processed %d/%zu requests",
+                __FUNCTION__, *numRequestProcessed, batchSize);
+        status = common::V1_0::Status::INTERNAL_ERROR;
+    }
+
+    res = CameraProviderManager::mapToStatusT(status);
+    if (res == OK) {
+        if (mHidlSession->isRemote()) {
+            // Only close acquire fence FDs when the HIDL transaction succeeds (so the FDs have been
+            // sent to camera HAL processes)
+            cleanupNativeHandles(&handlesCreated, /*closeFd*/true);
+        } else {
+            // In passthrough mode the FDs are now owned by HAL
+            cleanupNativeHandles(&handlesCreated);
+        }
+    } else {
+        mBufferRecords.popInflightBuffers(inflightBuffers);
+        cleanupNativeHandles(&handlesCreated);
+    }
+    return res;
+}
+
+status_t Camera3Device::HalInterface::flush() {
+    ATRACE_NAME("CameraHal::flush");
+    if (!valid()) return INVALID_OPERATION;
+    status_t res = OK;
+
+    auto err = mHidlSession->flush();
+    if (!err.isOk()) {
+        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
+        res = DEAD_OBJECT;
+    } else {
+        res = CameraProviderManager::mapToStatusT(err);
+    }
+
+    return res;
+}
+
+status_t Camera3Device::HalInterface::dump(int /*fd*/) {
+    ATRACE_NAME("CameraHal::dump");
+    if (!valid()) return INVALID_OPERATION;
+
+    // Handled by CameraProviderManager::dump
+
+    return OK;
+}
+
+status_t Camera3Device::HalInterface::close() {
+    ATRACE_NAME("CameraHal::close()");
+    if (!valid()) return INVALID_OPERATION;
+    status_t res = OK;
+
+    auto err = mHidlSession->close();
+    // Interface will be dead shortly anyway, so don't log errors
+    if (!err.isOk()) {
+        res = DEAD_OBJECT;
+    }
+
+    return res;
+}
+
+void Camera3Device::HalInterface::signalPipelineDrain(const std::vector<int>& streamIds) {
+    ATRACE_NAME("CameraHal::signalPipelineDrain");
+    if (!valid() || mHidlSession_3_5 == nullptr) {
+        ALOGE("%s called on invalid camera!", __FUNCTION__);
+        return;
+    }
+
+    auto err = mHidlSession_3_5->signalStreamFlush(streamIds, mNextStreamConfigCounter - 1);
+    if (!err.isOk()) {
+        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
+        return;
+    }
+}
+
+status_t Camera3Device::HalInterface::switchToOffline(
+        const std::vector<int32_t>& streamsToKeep,
+        /*out*/hardware::camera::device::V3_6::CameraOfflineSessionInfo* offlineSessionInfo,
+        /*out*/sp<hardware::camera::device::V3_6::ICameraOfflineSession>* offlineSession,
+        /*out*/camera3::BufferRecords* bufferRecords) {
+    ATRACE_NAME("CameraHal::switchToOffline");
+    if (!valid() || mHidlSession_3_6 == nullptr) {
+        ALOGE("%s called on invalid camera!", __FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    if (offlineSessionInfo == nullptr || offlineSession == nullptr || bufferRecords == nullptr) {
+        ALOGE("%s: output arguments must not be null!", __FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    common::V1_0::Status status = common::V1_0::Status::INTERNAL_ERROR;
+    auto resultCallback =
+        [&status, &offlineSessionInfo, &offlineSession] (auto s, auto info, auto session) {
+                status = s;
+                *offlineSessionInfo = info;
+                *offlineSession = session;
+        };
+    auto err = mHidlSession_3_6->switchToOffline(streamsToKeep, resultCallback);
+
+    if (!err.isOk()) {
+        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
+        return DEAD_OBJECT;
+    }
+
+    status_t ret = CameraProviderManager::mapToStatusT(status);
+    if (ret != OK) {
+        return ret;
+    }
+
+    // TODO: assert no ongoing requestBuffer/returnBuffer call here
+    // TODO: update RequestBufferStateMachine to block requestBuffer/returnBuffer once HAL
+    //       returns from switchToOffline.
+
+
+    // Validate buffer caches
+    std::vector<int32_t> streams;
+    streams.reserve(offlineSessionInfo->offlineStreams.size());
+    for (auto offlineStream : offlineSessionInfo->offlineStreams) {
+        int32_t id = offlineStream.id;
+        streams.push_back(id);
+        // Verify buffer caches
+        std::vector<uint64_t> bufIds(offlineStream.circulatingBufferIds.begin(),
+                offlineStream.circulatingBufferIds.end());
+        if (!verifyBufferIds(id, bufIds)) {
+            ALOGE("%s: stream ID %d buffer cache records mismatch!", __FUNCTION__, id);
+            return UNKNOWN_ERROR;
+        }
+    }
+
+    // Move buffer records
+    bufferRecords->takeBufferCaches(mBufferRecords, streams);
+    bufferRecords->takeInflightBufferMap(mBufferRecords);
+    bufferRecords->takeRequestedBufferMap(mBufferRecords);
+    return ret;
+}
+
+void Camera3Device::HalInterface::getInflightBufferKeys(
+        std::vector<std::pair<int32_t, int32_t>>* out) {
+    mBufferRecords.getInflightBufferKeys(out);
+    return;
+}
+
+void Camera3Device::HalInterface::getInflightRequestBufferKeys(
+        std::vector<uint64_t>* out) {
+    mBufferRecords.getInflightRequestBufferKeys(out);
+    return;
+}
+
+bool Camera3Device::HalInterface::verifyBufferIds(
+        int32_t streamId, std::vector<uint64_t>& bufIds) {
+    return mBufferRecords.verifyBufferIds(streamId, bufIds);
+}
+
+status_t Camera3Device::HalInterface::popInflightBuffer(
+        int32_t frameNumber, int32_t streamId,
+        /*out*/ buffer_handle_t **buffer) {
+    return mBufferRecords.popInflightBuffer(frameNumber, streamId, buffer);
+}
+
+status_t Camera3Device::HalInterface::pushInflightRequestBuffer(
+        uint64_t bufferId, buffer_handle_t* buf, int32_t streamId) {
+    return mBufferRecords.pushInflightRequestBuffer(bufferId, buf, streamId);
+}
+
+// Find and pop a buffer_handle_t based on bufferId
+status_t Camera3Device::HalInterface::popInflightRequestBuffer(
+        uint64_t bufferId,
+        /*out*/ buffer_handle_t** buffer,
+        /*optional out*/ int32_t* streamId) {
+    return mBufferRecords.popInflightRequestBuffer(bufferId, buffer, streamId);
+}
+
+std::pair<bool, uint64_t> Camera3Device::HalInterface::getBufferId(
+        const buffer_handle_t& buf, int streamId) {
+    return mBufferRecords.getBufferId(buf, streamId);
+}
+
+uint64_t Camera3Device::HalInterface::removeOneBufferCache(int streamId,
+        const native_handle_t* handle) {
+    return mBufferRecords.removeOneBufferCache(streamId, handle);
+}
+
+void Camera3Device::HalInterface::onBufferFreed(
+        int streamId, const native_handle_t* handle) {
+    uint32_t bufferId = mBufferRecords.removeOneBufferCache(streamId, handle);
+    std::lock_guard<std::mutex> lock(mFreedBuffersLock);
+    if (bufferId != BUFFER_ID_NO_BUFFER) {
+        mFreedBuffers.push_back(std::make_pair(streamId, bufferId));
+    }
+}
+
+void Camera3Device::HalInterface::onStreamReConfigured(int streamId) {
+    std::vector<uint64_t> bufIds = mBufferRecords.clearBufferCaches(streamId);
+    std::lock_guard<std::mutex> lock(mFreedBuffersLock);
+    for (auto bufferId : bufIds) {
+        mFreedBuffers.push_back(std::make_pair(streamId, bufferId));
+    }
+}
+
+/**
+ * RequestThread inner class methods
+ */
+
+Camera3Device::RequestThread::RequestThread(wp<Camera3Device> parent,
+        sp<StatusTracker> statusTracker,
+        sp<HalInterface> interface, const Vector<int32_t>& sessionParamKeys,
+        bool useHalBufManager,
         bool supportCameraMute) :
         Thread(/*canCallJava*/false),
         mParent(parent),
@@ -2881,7 +4205,6 @@ Camera3Device::RequestThread::RequestThread(wp<Camera3Device> parent,
         mInterface(interface),
         mListener(nullptr),
         mId(getId(parent)),
-        mRequestClearing(false),
         mFirstRepeating(false),
         mReconfigured(false),
         mDoPause(false),
@@ -3048,20 +4371,10 @@ status_t Camera3Device::RequestThread::clearRepeatingRequests(/*out*/int64_t *la
 }
 
 status_t Camera3Device::RequestThread::clearRepeatingRequestsLocked(/*out*/int64_t *lastFrameNumber) {
-    std::vector<int32_t> streamIds;
-    for (const auto& request : mRepeatingRequests) {
-        for (const auto& stream : request->mOutputStreams) {
-            streamIds.push_back(stream->getId());
-        }
-    }
-
     mRepeatingRequests.clear();
     if (lastFrameNumber != NULL) {
         *lastFrameNumber = mRepeatingLastFrameNumber;
     }
-
-    mInterface->repeatingRequestEnd(mRepeatingLastFrameNumber, streamIds);
-
     mRepeatingLastFrameNumber = hardware::camera2::ICameraDeviceUser::NO_IN_FLIGHT_REPEATING_FRAMES;
     return OK;
 }
@@ -3115,7 +4428,6 @@ status_t Camera3Device::RequestThread::clear(
         *lastFrameNumber = mRepeatingLastFrameNumber;
     }
     mRepeatingLastFrameNumber = hardware::camera2::ICameraDeviceUser::NO_IN_FLIGHT_REPEATING_FRAMES;
-    mRequestClearing = true;
     mRequestSignal.signal();
     return OK;
 }
@@ -3243,16 +4555,13 @@ bool Camera3Device::RequestThread::sendRequestsBatch() {
     return true;
 }
 
-std::pair<nsecs_t, nsecs_t> Camera3Device::RequestThread::calculateExpectedDurationRange(
-        const camera_metadata_t *request) {
-    std::pair<nsecs_t, nsecs_t> expectedRange(
-            InFlightRequest::kDefaultMinExpectedDuration,
-            InFlightRequest::kDefaultMaxExpectedDuration);
+nsecs_t Camera3Device::RequestThread::calculateMaxExpectedDuration(const camera_metadata_t *request) {
+    nsecs_t maxExpectedDuration = kDefaultExpectedDuration;
     camera_metadata_ro_entry_t e = camera_metadata_ro_entry_t();
     find_camera_metadata_ro_entry(request,
             ANDROID_CONTROL_AE_MODE,
             &e);
-    if (e.count == 0) return expectedRange;
+    if (e.count == 0) return maxExpectedDuration;
 
     switch (e.data.u8[0]) {
         case ANDROID_CONTROL_AE_MODE_OFF:
@@ -3260,15 +4569,13 @@ std::pair<nsecs_t, nsecs_t> Camera3Device::RequestThread::calculateExpectedDurat
                     ANDROID_SENSOR_EXPOSURE_TIME,
                     &e);
             if (e.count > 0) {
-                expectedRange.first = e.data.i64[0];
-                expectedRange.second = expectedRange.first;
+                maxExpectedDuration = e.data.i64[0];
             }
             find_camera_metadata_ro_entry(request,
                     ANDROID_SENSOR_FRAME_DURATION,
                     &e);
             if (e.count > 0) {
-                expectedRange.first = std::max(e.data.i64[0], expectedRange.first);
-                expectedRange.second = expectedRange.first;
+                maxExpectedDuration = std::max(e.data.i64[0], maxExpectedDuration);
             }
             break;
         default:
@@ -3276,13 +4583,12 @@ std::pair<nsecs_t, nsecs_t> Camera3Device::RequestThread::calculateExpectedDurat
                     ANDROID_CONTROL_AE_TARGET_FPS_RANGE,
                     &e);
             if (e.count > 1) {
-                expectedRange.first = 1e9 / e.data.i32[1];
-                expectedRange.second = 1e9 / e.data.i32[0];
+                maxExpectedDuration = 1e9 / e.data.u8[0];
             }
             break;
     }
 
-    return expectedRange;
+    return maxExpectedDuration;
 }
 
 bool Camera3Device::RequestThread::skipHFRTargetFPSUpdate(int32_t tag,
@@ -3520,26 +4826,6 @@ bool Camera3Device::RequestThread::threadLoop() {
     return submitRequestSuccess;
 }
 
-status_t Camera3Device::removeFwkOnlyRegionKeys(CameraMetadata *request) {
-    static const std::array<uint32_t, 4> kFwkOnlyRegionKeys = {ANDROID_CONTROL_AF_REGIONS_SET,
-        ANDROID_CONTROL_AE_REGIONS_SET, ANDROID_CONTROL_AWB_REGIONS_SET,
-        ANDROID_SCALER_CROP_REGION_SET};
-    if (request == nullptr) {
-        ALOGE("%s request metadata nullptr", __FUNCTION__);
-        return BAD_VALUE;
-    }
-    status_t res = OK;
-    for (const auto &key : kFwkOnlyRegionKeys) {
-        if (request->exists(key)) {
-            res = request->erase(key);
-            if (res != OK) {
-                return res;
-            }
-        }
-    }
-    return OK;
-}
-
 status_t Camera3Device::RequestThread::prepareHalRequests() {
     ATRACE_CALL();
 
@@ -3603,12 +4889,6 @@ status_t Camera3Device::RequestThread::prepareHalRequests() {
                             it != captureRequest->mSettingsList.end(); it++) {
                         if (parent->mUHRCropAndMeteringRegionMappers.find(it->cameraId) ==
                                 parent->mUHRCropAndMeteringRegionMappers.end()) {
-                            if (removeFwkOnlyRegionKeys(&(it->metadata)) != OK) {
-                                SET_ERR("RequestThread: Unable to remove fwk-only keys from request"
-                                        "%d: %s (%d)", halRequest->frame_number, strerror(-res),
-                                        res);
-                                return INVALID_OPERATION;
-                            }
                             continue;
                         }
 
@@ -3623,12 +4903,6 @@ status_t Camera3Device::RequestThread::prepareHalRequests() {
                                 return INVALID_OPERATION;
                             }
                             captureRequest->mUHRCropAndMeteringRegionsUpdated = true;
-                            if (removeFwkOnlyRegionKeys(&(it->metadata)) != OK) {
-                                SET_ERR("RequestThread: Unable to remove fwk-only keys from request"
-                                        "%d: %s (%d)", halRequest->frame_number, strerror(-res),
-                                        res);
-                                return INVALID_OPERATION;
-                            }
                         }
                     }
 
@@ -3897,13 +5171,11 @@ status_t Camera3Device::RequestThread::prepareHalRequests() {
                 isZslCapture = true;
             }
         }
-        auto expectedDurationRange = calculateExpectedDurationRange(settings);
         res = parent->registerInFlight(halRequest->frame_number,
                 totalNumBuffers, captureRequest->mResultExtras,
                 /*hasInput*/halRequest->input_buffer != NULL,
                 hasCallback,
-                /*min*/expectedDurationRange.first,
-                /*max*/expectedDurationRange.second,
+                calculateMaxExpectedDuration(settings),
                 requestedPhysicalCameras, isStillCapture, isZslCapture,
                 captureRequest->mRotateAndCropAuto, mPrevCameraIdsWithZoom,
                 (mUseHalBufManager) ? uniqueSurfaceIdMap :
@@ -4035,6 +5307,38 @@ void Camera3Device::RequestThread::clearPreviousRequest() {
     mPrevRequest.clear();
 }
 
+status_t Camera3Device::RequestThread::switchToOffline(
+        const std::vector<int32_t>& streamsToKeep,
+        /*out*/hardware::camera::device::V3_6::CameraOfflineSessionInfo* offlineSessionInfo,
+        /*out*/sp<hardware::camera::device::V3_6::ICameraOfflineSession>* offlineSession,
+        /*out*/camera3::BufferRecords* bufferRecords) {
+    Mutex::Autolock l(mRequestLock);
+    clearRepeatingRequestsLocked(/*lastFrameNumber*/nullptr);
+
+    // Wait until request thread is fully stopped
+    // TBD: check if request thread is being paused by other APIs (shouldn't be)
+
+    // We could also check for mRepeatingRequests.empty(), but the API interface
+    // is serialized by Camera3Device::mInterfaceLock so no one should be able to submit any
+    // new requests during the call; hence skip that check.
+    bool queueEmpty = mNextRequests.empty() && mRequestQueue.empty();
+    while (!queueEmpty) {
+        status_t res = mRequestSubmittedSignal.waitRelative(mRequestLock, kRequestSubmitTimeout);
+        if (res == TIMED_OUT) {
+            ALOGE("%s: request thread failed to submit one request within timeout!", __FUNCTION__);
+            return res;
+        } else if (res != OK) {
+            ALOGE("%s: request thread failed to submit a request: %s (%d)!",
+                    __FUNCTION__, strerror(-res), res);
+            return res;
+        }
+        queueEmpty = mNextRequests.empty() && mRequestQueue.empty();
+    }
+
+    return mInterface->switchToOffline(
+            streamsToKeep, offlineSessionInfo, offlineSession, bufferRecords);
+}
+
 status_t Camera3Device::RequestThread::setRotateAndCropAutoBehavior(
         camera_metadata_enum_android_scaler_rotate_and_crop_t rotateAndCropValue) {
     ATRACE_CALL();
@@ -4131,8 +5435,7 @@ void Camera3Device::RequestThread::cleanUpFailedRequests(bool sendRequestError)
                     outputBuffers->editItemAt(i).acquire_fence = -1;
                 }
                 outputBuffers->editItemAt(i).status = CAMERA_BUFFER_STATUS_ERROR;
-                captureRequest->mOutputStreams.editItemAt(i)->returnBuffer((*outputBuffers)[i],
-                        /*timestamp*/0, /*readoutTimestamp*/0,
+                captureRequest->mOutputStreams.editItemAt(i)->returnBuffer((*outputBuffers)[i], 0,
                         /*timestampIncreasing*/true, std::vector<size_t> (),
                         captureRequest->mResultExtras.frameNumber);
             }
@@ -4244,9 +5547,7 @@ sp<Camera3Device::CaptureRequest>
             break;
         }
 
-        if (!mRequestClearing) {
-            res = mRequestSignal.waitRelative(mRequestLock, kRequestTimeout);
-        }
+        res = mRequestSignal.waitRelative(mRequestLock, kRequestTimeout);
 
         if ((mRequestQueue.empty() && mRepeatingRequests.empty()) ||
                 exitPending()) {
@@ -4269,7 +5570,6 @@ sp<Camera3Device::CaptureRequest>
                     parent->mRequestBufferSM.onRequestThreadPaused();
                 }
             }
-            mRequestClearing = false;
             // Stop waiting for now and let thread management happen
             return NULL;
         }
@@ -4630,53 +5930,48 @@ bool Camera3Device::RequestThread::overrideTestPattern(
 
     bool changed = false;
 
-    // For a multi-camera, the physical cameras support the same set of
-    // test pattern modes as the logical camera.
-    for (auto& settings : request->mSettingsList) {
-        CameraMetadata &metadata = settings.metadata;
-
-        int32_t testPatternMode = settings.mOriginalTestPatternMode;
-        int32_t testPatternData[4] = {
-            settings.mOriginalTestPatternData[0],
-            settings.mOriginalTestPatternData[1],
-            settings.mOriginalTestPatternData[2],
-            settings.mOriginalTestPatternData[3]
-        };
-        if (mCameraMute != ANDROID_SENSOR_TEST_PATTERN_MODE_OFF) {
-            testPatternMode = mCameraMute;
-            testPatternData[0] = 0;
-            testPatternData[1] = 0;
-            testPatternData[2] = 0;
-            testPatternData[3] = 0;
-        }
-
-        auto testPatternEntry = metadata.find(ANDROID_SENSOR_TEST_PATTERN_MODE);
-        bool supportTestPatternModeKey = settings.mHasTestPatternModeTag;
-        if (testPatternEntry.count > 0) {
-            if (testPatternEntry.data.i32[0] != testPatternMode) {
-                testPatternEntry.data.i32[0] = testPatternMode;
-                changed = true;
-            }
-        } else if (supportTestPatternModeKey) {
-            metadata.update(ANDROID_SENSOR_TEST_PATTERN_MODE,
-                    &testPatternMode, 1);
+    int32_t testPatternMode = request->mOriginalTestPatternMode;
+    int32_t testPatternData[4] = {
+        request->mOriginalTestPatternData[0],
+        request->mOriginalTestPatternData[1],
+        request->mOriginalTestPatternData[2],
+        request->mOriginalTestPatternData[3]
+    };
+
+    if (mCameraMute != ANDROID_SENSOR_TEST_PATTERN_MODE_OFF) {
+        testPatternMode = mCameraMute;
+        testPatternData[0] = 0;
+        testPatternData[1] = 0;
+        testPatternData[2] = 0;
+        testPatternData[3] = 0;
+    }
+
+    CameraMetadata &metadata = request->mSettingsList.begin()->metadata;
+
+    auto testPatternEntry = metadata.find(ANDROID_SENSOR_TEST_PATTERN_MODE);
+    if (testPatternEntry.count > 0) {
+        if (testPatternEntry.data.i32[0] != testPatternMode) {
+            testPatternEntry.data.i32[0] = testPatternMode;
             changed = true;
         }
+    } else {
+        metadata.update(ANDROID_SENSOR_TEST_PATTERN_MODE,
+                &testPatternMode, 1);
+        changed = true;
+    }
 
-        auto testPatternColor = metadata.find(ANDROID_SENSOR_TEST_PATTERN_DATA);
-        bool supportTestPatternDataKey = settings.mHasTestPatternDataTag;
-        if (testPatternColor.count >= 4) {
-            for (size_t i = 0; i < 4; i++) {
-                if (testPatternColor.data.i32[i] != testPatternData[i]) {
-                    testPatternColor.data.i32[i] = testPatternData[i];
-                    changed = true;
-                }
+    auto testPatternColor = metadata.find(ANDROID_SENSOR_TEST_PATTERN_DATA);
+    if (testPatternColor.count >= 4) {
+        for (size_t i = 0; i < 4; i++) {
+            if (testPatternColor.data.i32[i] != testPatternData[i]) {
+                testPatternColor.data.i32[i] = testPatternData[i];
+                changed = true;
             }
-        } else if (supportTestPatternDataKey) {
-            metadata.update(ANDROID_SENSOR_TEST_PATTERN_DATA,
-                    testPatternData, 4);
-            changed = true;
         }
+    } else {
+        metadata.update(ANDROID_SENSOR_TEST_PATTERN_DATA,
+                testPatternData, 4);
+        changed = true;
     }
 
     return changed;
@@ -5068,6 +6363,220 @@ std::vector<sp<Camera3StreamInterface>> Camera3Device::getAllStreams() {
     return ret;
 }
 
+status_t Camera3Device::switchToOffline(
+        const std::vector<int32_t>& streamsToKeep,
+        /*out*/ sp<CameraOfflineSessionBase>* session) {
+    ATRACE_CALL();
+    if (session == nullptr) {
+        ALOGE("%s: session must not be null", __FUNCTION__);
+        return BAD_VALUE;
+    }
+
+    Mutex::Autolock il(mInterfaceLock);
+
+    bool hasInputStream = mInputStream != nullptr;
+    int32_t inputStreamId = hasInputStream ? mInputStream->getId() : -1;
+    bool inputStreamSupportsOffline = hasInputStream ?
+            mInputStream->getOfflineProcessingSupport() : false;
+    auto outputStreamIds = mOutputStreams.getStreamIds();
+    auto streamIds = outputStreamIds;
+    if (hasInputStream) {
+        streamIds.push_back(mInputStream->getId());
+    }
+
+    // Check all streams in streamsToKeep supports offline mode
+    for (auto id : streamsToKeep) {
+        if (std::find(streamIds.begin(), streamIds.end(), id) == streamIds.end()) {
+            ALOGE("%s: Unknown stream ID %d", __FUNCTION__, id);
+            return BAD_VALUE;
+        } else if (id == inputStreamId) {
+            if (!inputStreamSupportsOffline) {
+                ALOGE("%s: input stream %d cannot be switched to offline",
+                        __FUNCTION__, id);
+                return BAD_VALUE;
+            }
+        } else {
+            sp<camera3::Camera3OutputStreamInterface> stream = mOutputStreams.get(id);
+            if (!stream->getOfflineProcessingSupport()) {
+                ALOGE("%s: output stream %d cannot be switched to offline",
+                        __FUNCTION__, id);
+                return BAD_VALUE;
+            }
+        }
+    }
+
+    // TODO: block surface sharing and surface group streams until we can support them
+
+    // Stop repeating request, wait until all remaining requests are submitted, then call into
+    // HAL switchToOffline
+    hardware::camera::device::V3_6::CameraOfflineSessionInfo offlineSessionInfo;
+    sp<hardware::camera::device::V3_6::ICameraOfflineSession> offlineSession;
+    camera3::BufferRecords bufferRecords;
+    status_t ret = mRequestThread->switchToOffline(
+            streamsToKeep, &offlineSessionInfo, &offlineSession, &bufferRecords);
+
+    if (ret != OK) {
+        SET_ERR("Switch to offline failed: %s (%d)", strerror(-ret), ret);
+        return ret;
+    }
+
+    bool succ = mRequestBufferSM.onSwitchToOfflineSuccess();
+    if (!succ) {
+        SET_ERR("HAL must not be calling requestStreamBuffers call");
+        // TODO: block ALL callbacks from HAL till app configured new streams?
+        return UNKNOWN_ERROR;
+    }
+
+    // Verify offlineSessionInfo
+    std::vector<int32_t> offlineStreamIds;
+    offlineStreamIds.reserve(offlineSessionInfo.offlineStreams.size());
+    for (auto offlineStream : offlineSessionInfo.offlineStreams) {
+        // verify stream IDs
+        int32_t id = offlineStream.id;
+        if (std::find(streamIds.begin(), streamIds.end(), id) == streamIds.end()) {
+            SET_ERR("stream ID %d not found!", id);
+            return UNKNOWN_ERROR;
+        }
+
+        // When not using HAL buf manager, only allow streams requested by app to be preserved
+        if (!mUseHalBufManager) {
+            if (std::find(streamsToKeep.begin(), streamsToKeep.end(), id) == streamsToKeep.end()) {
+                SET_ERR("stream ID %d must not be switched to offline!", id);
+                return UNKNOWN_ERROR;
+            }
+        }
+
+        offlineStreamIds.push_back(id);
+        sp<Camera3StreamInterface> stream = (id == inputStreamId) ?
+                static_cast<sp<Camera3StreamInterface>>(mInputStream) :
+                static_cast<sp<Camera3StreamInterface>>(mOutputStreams.get(id));
+        // Verify number of outstanding buffers
+        if (stream->getOutstandingBuffersCount() != offlineStream.numOutstandingBuffers) {
+            SET_ERR("Offline stream %d # of remaining buffer mismatch: (%zu,%d) (service/HAL)",
+                    id, stream->getOutstandingBuffersCount(), offlineStream.numOutstandingBuffers);
+            return UNKNOWN_ERROR;
+        }
+    }
+
+    // Verify all streams to be deleted don't have any outstanding buffers
+    if (hasInputStream && std::find(offlineStreamIds.begin(), offlineStreamIds.end(),
+                inputStreamId) == offlineStreamIds.end()) {
+        if (mInputStream->hasOutstandingBuffers()) {
+            SET_ERR("Input stream %d still has %zu outstanding buffer!",
+                    inputStreamId, mInputStream->getOutstandingBuffersCount());
+            return UNKNOWN_ERROR;
+        }
+    }
+
+    for (const auto& outStreamId : outputStreamIds) {
+        if (std::find(offlineStreamIds.begin(), offlineStreamIds.end(),
+                outStreamId) == offlineStreamIds.end()) {
+            auto outStream = mOutputStreams.get(outStreamId);
+            if (outStream->hasOutstandingBuffers()) {
+                SET_ERR("Output stream %d still has %zu outstanding buffer!",
+                        outStreamId, outStream->getOutstandingBuffersCount());
+                return UNKNOWN_ERROR;
+            }
+        }
+    }
+
+    InFlightRequestMap offlineReqs;
+    // Verify inflight requests and their pending buffers
+    {
+        std::lock_guard<std::mutex> l(mInFlightLock);
+        for (auto offlineReq : offlineSessionInfo.offlineRequests) {
+            int idx = mInFlightMap.indexOfKey(offlineReq.frameNumber);
+            if (idx == NAME_NOT_FOUND) {
+                SET_ERR("Offline request frame number %d not found!", offlineReq.frameNumber);
+                return UNKNOWN_ERROR;
+            }
+
+            const auto& inflightReq = mInFlightMap.valueAt(idx);
+            // TODO: check specific stream IDs
+            size_t numBuffersLeft = static_cast<size_t>(inflightReq.numBuffersLeft);
+            if (numBuffersLeft != offlineReq.pendingStreams.size()) {
+                SET_ERR("Offline request # of remaining buffer mismatch: (%d,%d) (service/HAL)",
+                        inflightReq.numBuffersLeft, offlineReq.pendingStreams.size());
+                return UNKNOWN_ERROR;
+            }
+            offlineReqs.add(offlineReq.frameNumber, inflightReq);
+        }
+    }
+
+    // Create Camera3OfflineSession and transfer object ownership
+    //   (streams, inflight requests, buffer caches)
+    camera3::StreamSet offlineStreamSet;
+    sp<camera3::Camera3Stream> inputStream;
+    for (auto offlineStream : offlineSessionInfo.offlineStreams) {
+        int32_t id = offlineStream.id;
+        if (mInputStream != nullptr && id == mInputStream->getId()) {
+            inputStream = mInputStream;
+        } else {
+            offlineStreamSet.add(id, mOutputStreams.get(id));
+        }
+    }
+
+    // TODO: check if we need to lock before copying states
+    //       though technically no other thread should be talking to Camera3Device at this point
+    Camera3OfflineStates offlineStates(
+            mTagMonitor, mVendorTagId, mUseHalBufManager, mNeedFixupMonochromeTags,
+            mUsePartialResult, mNumPartialResults, mLastCompletedRegularFrameNumber,
+            mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
+            mNextResultFrameNumber, mNextReprocessResultFrameNumber,
+            mNextZslStillResultFrameNumber, mNextShutterFrameNumber,
+            mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
+            mDeviceInfo, mPhysicalDeviceInfoMap, mDistortionMappers,
+            mZoomRatioMappers, mRotateAndCropMappers);
+
+    *session = new Camera3OfflineSession(mId, inputStream, offlineStreamSet,
+            std::move(bufferRecords), offlineReqs, offlineStates, offlineSession);
+
+    // Delete all streams that has been transferred to offline session
+    Mutex::Autolock l(mLock);
+    for (auto offlineStream : offlineSessionInfo.offlineStreams) {
+        int32_t id = offlineStream.id;
+        if (mInputStream != nullptr && id == mInputStream->getId()) {
+            mInputStream.clear();
+        } else {
+            mOutputStreams.remove(id);
+        }
+    }
+
+    // disconnect all other streams and switch to UNCONFIGURED state
+    if (mInputStream != nullptr) {
+        ret = mInputStream->disconnect();
+        if (ret != OK) {
+            SET_ERR_L("disconnect input stream failed!");
+            return UNKNOWN_ERROR;
+        }
+    }
+
+    for (auto streamId : mOutputStreams.getStreamIds()) {
+        sp<Camera3StreamInterface> stream = mOutputStreams.get(streamId);
+        ret = stream->disconnect();
+        if (ret != OK) {
+            SET_ERR_L("disconnect output stream %d failed!", streamId);
+            return UNKNOWN_ERROR;
+        }
+    }
+
+    mInputStream.clear();
+    mOutputStreams.clear();
+    mNeedConfig = true;
+    internalUpdateStatusLocked(STATUS_UNCONFIGURED);
+    mOperatingMode = NO_MODE;
+    mIsConstrainedHighSpeedConfiguration = false;
+    mRequestThread->clearPreviousRequest();
+
+    return OK;
+    // TO be done by CameraDeviceClient/Camera3OfflineSession
+    // register the offline client to camera service
+    // Setup result passthing threads etc
+    // Initialize offline session so HAL can start sending callback to it (result Fmq)
+    // TODO: check how many onIdle callback will be sent
+    // Java side to make sure the CameraCaptureSession is properly closed
+}
+
 void Camera3Device::getOfflineStreamIds(std::vector<int> *offlineStreamIds) {
     ATRACE_CALL();
 
@@ -5154,7 +6663,7 @@ status_t Camera3Device::injectCamera(const String8& injectedCamId,
         }
     }
 
-    res = injectionCameraInitialize(injectedCamId, manager);
+    res = mInjectionMethods->injectionInitialize(injectedCamId, manager, this);
     if (res != OK) {
         ALOGE("%s: Failed to initialize the injection camera! ret != NO_ERROR: %d",
                 __FUNCTION__, res);
diff --git a/services/camera/libcameraservice/device3/Camera3Device.h b/services/camera/libcameraservice/device3/Camera3Device.h
index f927b4da0a..997afa0126 100644
--- a/services/camera/libcameraservice/device3/Camera3Device.h
+++ b/services/camera/libcameraservice/device3/Camera3Device.h
@@ -29,10 +29,19 @@
 #include <utils/KeyedVector.h>
 #include <utils/Timers.h>
 
-#include <camera/CaptureResult.h>
+#include <android/hardware/camera/device/3.2/ICameraDevice.h>
+#include <android/hardware/camera/device/3.2/ICameraDeviceSession.h>
+#include <android/hardware/camera/device/3.3/ICameraDeviceSession.h>
+#include <android/hardware/camera/device/3.4/ICameraDeviceSession.h>
+#include <android/hardware/camera/device/3.5/ICameraDeviceSession.h>
+#include <android/hardware/camera/device/3.6/ICameraDeviceSession.h>
+#include <android/hardware/camera/device/3.7/ICameraDeviceSession.h>
+#include <android/hardware/camera/device/3.2/ICameraDeviceCallback.h>
+#include <android/hardware/camera/device/3.4/ICameraDeviceCallback.h>
+#include <android/hardware/camera/device/3.5/ICameraDeviceCallback.h>
+#include <fmq/MessageQueue.h>
 
-#include "CameraServiceWatchdog.h"
-#include <aidl/android/hardware/camera/device/CameraBlob.h>
+#include <camera/CaptureResult.h>
 
 #include "common/CameraDeviceBase.h"
 #include "device3/BufferUtils.h"
@@ -47,11 +56,11 @@
 #include "device3/Camera3OfflineSession.h"
 #include "device3/Camera3StreamInterface.h"
 #include "utils/TagMonitor.h"
-#include "utils/IPCTransport.h"
 #include "utils/LatencyHistogram.h"
 #include <camera_metadata_hidden.h>
 
 using android::camera3::camera_capture_request_t;
+using android::camera3::camera_jpeg_blob_t;
 using android::camera3::camera_request_template;
 using android::camera3::camera_stream_buffer_t;
 using android::camera3::camera_stream_configuration_t;
@@ -74,24 +83,16 @@ class Camera3StreamInterface;
  */
 class Camera3Device :
             public CameraDeviceBase,
+            virtual public hardware::camera::device::V3_5::ICameraDeviceCallback,
             public camera3::SetErrorInterface,
             public camera3::InflightRequestUpdateInterface,
             public camera3::RequestBufferInterface,
             public camera3::FlushBufferInterface {
-  friend class HidlCamera3Device;
-  friend class AidlCamera3Device;
   public:
 
     explicit Camera3Device(const String8& id, bool overrideForPerfClass, bool legacyClient = false);
 
     virtual ~Camera3Device();
-    // Delete and optionally close native handles and clear the input vector afterward
-    static void cleanupNativeHandles(
-            std::vector<native_handle_t*> *handles, bool closeFd = false);
-
-    virtual IPCTransport getTransportType() const override {
-        return mInterface->getTransportType();
-    }
 
     /**
      * CameraDeviceBase interface
@@ -101,13 +102,8 @@ class Camera3Device :
 
     metadata_vendor_id_t getVendorTagId() const override { return mVendorTagId; }
 
-    // Watchdog thread
-    sp<CameraServiceWatchdog> mCameraServiceWatchdog;
-
     // Transitions to idle state on success.
-    virtual status_t initialize(sp<CameraProviderManager> /*manager*/,
-            const String8& /*monitorTags*/) = 0;
-
+    status_t initialize(sp<CameraProviderManager> manager, const String8& monitorTags) override;
     status_t disconnect() override;
     status_t dump(int fd, const Vector<String16> &args) override;
     status_t startWatchingTags(const String8 &tags) override;
@@ -144,12 +140,7 @@ class Camera3Device :
             std::vector<int> *surfaceIds = nullptr,
             int streamSetId = camera3::CAMERA3_STREAM_SET_ID_INVALID,
             bool isShared = false, bool isMultiResolution = false,
-            uint64_t consumerUsage = 0,
-            int64_t dynamicRangeProfile =
-            ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD,
-            int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT,
-            int timestampBase = OutputConfiguration::TIMESTAMP_BASE_DEFAULT,
-            int mirrorMode = OutputConfiguration::MIRROR_MODE_AUTO) override;
+            uint64_t consumerUsage = 0) override;
 
     status_t createStream(const std::vector<sp<Surface>>& consumers,
             bool hasDeferredConsumer, uint32_t width, uint32_t height, int format,
@@ -159,12 +150,7 @@ class Camera3Device :
             std::vector<int> *surfaceIds = nullptr,
             int streamSetId = camera3::CAMERA3_STREAM_SET_ID_INVALID,
             bool isShared = false, bool isMultiResolution = false,
-            uint64_t consumerUsage = 0,
-            int64_t dynamicRangeProfile =
-            ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD,
-            int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT,
-            int timestampBase = OutputConfiguration::TIMESTAMP_BASE_DEFAULT,
-            int mirrorMode = OutputConfiguration::MIRROR_MODE_AUTO) override;
+            uint64_t consumerUsage = 0) override;
 
     status_t createInputStream(
             uint32_t width, uint32_t height, int format, bool isMultiResolution,
@@ -209,11 +195,9 @@ class Camera3Device :
 
     status_t prepare(int maxCount, int streamId) override;
 
-    ssize_t getJpegBufferSize(const CameraMetadata &info, uint32_t width,
-            uint32_t height) const override;
-    ssize_t getPointCloudBufferSize(const CameraMetadata &info) const;
-    ssize_t getRawOpaqueBufferSize(const CameraMetadata &info, int32_t width, int32_t height,
-            bool maxResolution) const;
+    ssize_t getJpegBufferSize(uint32_t width, uint32_t height) const override;
+    ssize_t getPointCloudBufferSize() const;
+    ssize_t getRawOpaqueBufferSize(int32_t width, int32_t height, bool maxResolution) const;
 
     // Methods called by subclasses
     void             notifyStatus(bool idle); // updates from StatusTracker
@@ -242,10 +226,8 @@ class Camera3Device :
 
     nsecs_t getExpectedInFlightDuration() override;
 
-    virtual status_t switchToOffline(const std::vector<int32_t>& ,
-            /*out*/ sp<CameraOfflineSessionBase>* )  override {
-      return INVALID_OPERATION;
-    };
+    status_t switchToOffline(const std::vector<int32_t>& streamsToKeep,
+            /*out*/ sp<CameraOfflineSessionBase>* session) override;
 
     // RequestBufferInterface
     bool startRequestBuffer() override;
@@ -296,11 +278,31 @@ class Camera3Device :
      */
     status_t stopInjection();
 
-  protected:
+    /**
+     * Helper functions to map between framework and HIDL values
+     */
+    static hardware::graphics::common::V1_0::PixelFormat mapToPixelFormat(int frameworkFormat);
+    static hardware::camera::device::V3_2::DataspaceFlags mapToHidlDataspace(
+            android_dataspace dataSpace);
+    static hardware::camera::device::V3_2::BufferUsageFlags mapToConsumerUsage(uint64_t usage);
+    static hardware::camera::device::V3_2::StreamRotation mapToStreamRotation(
+            camera_stream_rotation_t rotation);
+    // Returns a negative error code if the passed-in operation mode is not valid.
+    static status_t mapToStreamConfigurationMode(camera_stream_configuration_mode_t operationMode,
+            /*out*/ hardware::camera::device::V3_2::StreamConfigurationMode *mode);
+    static int mapToFrameworkFormat(hardware::graphics::common::V1_0::PixelFormat pixelFormat);
+    static android_dataspace mapToFrameworkDataspace(
+            hardware::camera::device::V3_2::DataspaceFlags);
+    static uint64_t mapConsumerToFrameworkUsage(
+            hardware::camera::device::V3_2::BufferUsageFlags usage);
+    static uint64_t mapProducerToFrameworkUsage(
+            hardware::camera::device::V3_2::BufferUsageFlags usage);
+
+  private:
     status_t disconnectImpl();
-    static status_t removeFwkOnlyRegionKeys(CameraMetadata *request);
 
-    float getMaxPreviewFps(sp<camera3::Camera3OutputStreamInterface> stream);
+    // internal typedefs
+    using RequestMetadataQueue = hardware::MessageQueue<uint8_t, hardware::kSynchronizedReadWrite>;
 
     static const size_t        kDumpLockAttempts  = 10;
     static const size_t        kDumpSleepDuration = 100000; // 0.10 sec
@@ -308,6 +310,7 @@ class Camera3Device :
     static const nsecs_t       kMinWarnInflightDuration = 5000000000; // 5 s
     static const size_t        kInFlightWarnLimit = 30;
     static const size_t        kInFlightWarnLimitHighSpeed = 256; // batch size 32 * pipe depth 8
+    static const nsecs_t       kDefaultExpectedDuration = 100000000; // 100 ms
     static const nsecs_t       kMinInflightDuration = 5000000000; // 5 s
     static const nsecs_t       kBaseGetBufferWait = 3000000000; // 3 sec.
     // SCHED_FIFO priority for request submission thread in HFR mode
@@ -315,8 +318,7 @@ class Camera3Device :
 
     struct                     RequestTrigger;
     // minimal jpeg buffer size: 256KB + blob header
-    static const ssize_t       kMinJpegBufferSize =
-            256 * 1024 + sizeof(aidl::android::hardware::camera::device::CameraBlob);
+    static const ssize_t       kMinJpegBufferSize = 256 * 1024 + sizeof(camera_jpeg_blob_t);
     // Constant to use for stream ID when one doesn't exist
     static const int           NO_STREAM = -1;
 
@@ -347,65 +349,68 @@ class Camera3Device :
     // Flag indicating is the current active stream configuration is constrained high speed.
     bool                       mIsConstrainedHighSpeedConfiguration;
 
+    // FMQ to write result on. Must be guarded by mProcessCaptureResultLock.
+    std::unique_ptr<ResultMetadataQueue> mResultMetadataQueue;
+
     /**** Scope for mLock ****/
 
+    /**
+     * Adapter for legacy HAL / HIDL HAL interface calls; calls either into legacy HALv3 or the
+     * HIDL HALv3 interfaces.
+     */
     class HalInterface : public camera3::Camera3StreamBufferFreedListener,
             public camera3::BufferRecordsInterface {
       public:
-        HalInterface(bool useHalBufManager, bool supportOfflineProcessing) :
-              mUseHalBufManager(useHalBufManager),
-              mIsReconfigurationQuerySupported(true),
-              mSupportOfflineProcessing(supportOfflineProcessing)
-               {};
+        HalInterface(sp<hardware::camera::device::V3_2::ICameraDeviceSession> &session,
+                     std::shared_ptr<RequestMetadataQueue> queue,
+                     bool useHalBufManager, bool supportOfflineProcessing);
         HalInterface(const HalInterface &other);
         HalInterface();
 
-        virtual IPCTransport getTransportType() const = 0;
-
         // Returns true if constructed with a valid device or session, and not yet cleared
-        virtual bool valid() = 0;
+        bool valid();
 
         // Reset this HalInterface object (does not call close())
-        virtual void clear() = 0;
+        void clear();
 
         // Calls into the HAL interface
 
         // Caller takes ownership of requestTemplate
-        virtual status_t constructDefaultRequestSettings(camera_request_template templateId,
-                /*out*/ camera_metadata_t **requestTemplate) = 0;
-
-        virtual status_t configureStreams(const camera_metadata_t * sessionParams,
-                /*inout*/ camera_stream_configuration_t * config,
-                const std::vector<uint32_t>& bufferSizes) = 0;
+        status_t constructDefaultRequestSettings(camera_request_template templateId,
+                /*out*/ camera_metadata_t **requestTemplate);
+        status_t configureStreams(const camera_metadata_t *sessionParams,
+                /*inout*/ camera_stream_configuration_t *config,
+                const std::vector<uint32_t>& bufferSizes);
 
         // The injection camera configures the streams to hal.
-        virtual status_t configureInjectedStreams(
+        status_t configureInjectedStreams(
                 const camera_metadata_t* sessionParams,
                 /*inout*/ camera_stream_configuration_t* config,
                 const std::vector<uint32_t>& bufferSizes,
-                const CameraMetadata& cameraCharacteristics) = 0;
+                const CameraMetadata& cameraCharacteristics);
 
         // When the call succeeds, the ownership of acquire fences in requests is transferred to
         // HalInterface. More specifically, the current implementation will send the fence to
         // HAL process and close the FD in cameraserver process. When the call fails, the ownership
         // of the acquire fence still belongs to the caller.
-        virtual status_t processBatchCaptureRequests(
+        status_t processBatchCaptureRequests(
                 std::vector<camera_capture_request_t*>& requests,
-                /*out*/uint32_t* numRequestProcessed) = 0;
-
-        virtual status_t flush() = 0;
-
-        virtual status_t dump(int fd) = 0;
-
-        virtual status_t close() = 0;
-
-        virtual void signalPipelineDrain(const std::vector<int>& streamIds) = 0;
+                /*out*/uint32_t* numRequestProcessed);
+        status_t flush();
+        status_t dump(int fd);
+        status_t close();
 
-        virtual bool isReconfigurationRequired(CameraMetadata& oldSessionParams,
-                CameraMetadata& newSessionParams) = 0;
+        void signalPipelineDrain(const std::vector<int>& streamIds);
+        bool isReconfigurationRequired(CameraMetadata& oldSessionParams,
+                CameraMetadata& newSessionParams);
 
-        virtual status_t repeatingRequestEnd(uint32_t frameNumber,
-                const std::vector<int32_t> &streamIds) = 0;
+        // Upon successful return, HalInterface will return buffer maps needed for offline
+        // processing, and clear all its internal buffer maps.
+        status_t switchToOffline(
+                const std::vector<int32_t>& streamsToKeep,
+                /*out*/hardware::camera::device::V3_6::CameraOfflineSessionInfo* offlineSessionInfo,
+                /*out*/sp<hardware::camera::device::V3_6::ICameraOfflineSession>* offlineSession,
+                /*out*/camera3::BufferRecords* bufferRecords);
 
         /////////////////////////////////////////////////////////////////////
         // Implements BufferRecordsInterface
@@ -436,35 +441,41 @@ class Camera3Device :
 
         void onStreamReConfigured(int streamId);
 
-      protected:
+      private:
+        // Always valid
+        sp<hardware::camera::device::V3_2::ICameraDeviceSession> mHidlSession;
+        // Valid if ICameraDeviceSession is @3.3 or newer
+        sp<hardware::camera::device::V3_3::ICameraDeviceSession> mHidlSession_3_3;
+        // Valid if ICameraDeviceSession is @3.4 or newer
+        sp<hardware::camera::device::V3_4::ICameraDeviceSession> mHidlSession_3_4;
+        // Valid if ICameraDeviceSession is @3.5 or newer
+        sp<hardware::camera::device::V3_5::ICameraDeviceSession> mHidlSession_3_5;
+        // Valid if ICameraDeviceSession is @3.6 or newer
+        sp<hardware::camera::device::V3_6::ICameraDeviceSession> mHidlSession_3_6;
+        // Valid if ICameraDeviceSession is @3.7 or newer
+        sp<hardware::camera::device::V3_7::ICameraDeviceSession> mHidlSession_3_7;
+
+        std::shared_ptr<RequestMetadataQueue> mRequestMetadataQueue;
+
+        // The output HIDL request still depends on input camera_capture_request_t
+        // Do not free input camera_capture_request_t before output HIDL request
+        status_t wrapAsHidlRequest(camera_capture_request_t* in,
+                /*out*/hardware::camera::device::V3_2::CaptureRequest* out,
+                /*out*/std::vector<native_handle_t*>* handlesCreated,
+                /*out*/std::vector<std::pair<int32_t, int32_t>>* inflightBuffers);
+
+        status_t pushInflightBufferLocked(int32_t frameNumber, int32_t streamId,
+                buffer_handle_t *buffer);
+
+        // Pop inflight buffers based on pairs of (frameNumber,streamId)
+        void popInflightBuffers(const std::vector<std::pair<int32_t, int32_t>>& buffers);
 
         // Return true if the input caches match what we have; otherwise false
         bool verifyBufferIds(int32_t streamId, std::vector<uint64_t>& inBufIds);
 
-        template <typename OfflineSessionInfoT>
-        status_t verifyBufferCaches(
-            const OfflineSessionInfoT *offlineSessionInfo, camera3::BufferRecords *bufferRecords) {
-            // Validate buffer caches
-            std::vector<int32_t> streams;
-            streams.reserve(offlineSessionInfo->offlineStreams.size());
-            for (auto offlineStream : offlineSessionInfo->offlineStreams) {
-                int32_t id = offlineStream.id;
-                streams.push_back(id);
-                // Verify buffer caches
-                std::vector<uint64_t> bufIds(offlineStream.circulatingBufferIds.begin(),
-                        offlineStream.circulatingBufferIds.end());
-                if (!verifyBufferIds(id, bufIds)) {
-                    ALOGE("%s: stream ID %d buffer cache records mismatch!", __FUNCTION__, id);
-                    return UNKNOWN_ERROR;
-                }
-            }
-
-            // Move buffer records
-            bufferRecords->takeBufferCaches(mBufferRecords, streams);
-            bufferRecords->takeInflightBufferMap(mBufferRecords);
-            bufferRecords->takeRequestedBufferMap(mBufferRecords);
-            return OK;
-        }
+        // Delete and optionally close native handles and clear the input vector afterward
+        static void cleanupNativeHandles(
+                std::vector<native_handle_t*> *handles, bool closeFd = false);
 
         virtual void onBufferFreed(int streamId, const native_handle_t* handle) override;
 
@@ -480,7 +491,7 @@ class Camera3Device :
         bool mIsReconfigurationQuerySupported;
 
         const bool mSupportOfflineProcessing;
-    }; // class HalInterface
+    };
 
     sp<HalInterface> mInterface;
 
@@ -540,7 +551,6 @@ class Camera3Device :
 
     /**** End scope for mLock ****/
 
-    bool                       mDeviceTimeBaseIsRealtime;
     // The offset converting from clock domain of other subsystem
     // (video/hardware composer) to that of camera. Assumption is that this
     // offset won't change during the life cycle of the camera device. In other
@@ -568,6 +578,10 @@ class Camera3Device :
         // overriding of ROTATE_AND_CROP value and adjustment of coordinates
         // in several other controls in both the request and the result
         bool                                mRotateAndCropAuto;
+        // Original value of TEST_PATTERN_MODE and DATA so that they can be
+        // restored when sensor muting is turned off
+        int32_t                             mOriginalTestPatternMode;
+        int32_t                             mOriginalTestPatternData[4];
 
         // Whether this capture request has its zoom ratio set to 1.0x before
         // the framework overrides it for camera HAL consumption.
@@ -575,6 +589,7 @@ class Camera3Device :
         // The systemTime timestamp when the request is created.
         nsecs_t                             mRequestTimeNs;
 
+
         // Whether this capture request's distortion correction update has
         // been done.
         bool                                mDistortionCorrectionUpdated = false;
@@ -607,6 +622,33 @@ class Camera3Device :
                                   bool repeating,
                                   int64_t *lastFrameNumber = NULL);
 
+
+    /**
+     * Implementation of android::hardware::camera::device::V3_5::ICameraDeviceCallback
+     */
+
+    hardware::Return<void> processCaptureResult_3_4(
+            const hardware::hidl_vec<
+                    hardware::camera::device::V3_4::CaptureResult>& results) override;
+    hardware::Return<void> processCaptureResult(
+            const hardware::hidl_vec<
+                    hardware::camera::device::V3_2::CaptureResult>& results) override;
+    hardware::Return<void> notify(
+            const hardware::hidl_vec<
+                    hardware::camera::device::V3_2::NotifyMsg>& msgs) override;
+
+    hardware::Return<void> requestStreamBuffers(
+            const hardware::hidl_vec<
+                    hardware::camera::device::V3_5::BufferRequest>& bufReqs,
+            requestStreamBuffers_cb _hidl_cb) override;
+
+    hardware::Return<void> returnStreamBuffers(
+            const hardware::hidl_vec<
+                    hardware::camera::device::V3_2::StreamBuffer>& buffers) override;
+
+    // Handle one notify message
+    void notify(const hardware::camera::device::V3_2::NotifyMsg& msg);
+
     // lock to ensure only one processCaptureResult is called at a time.
     Mutex mProcessCaptureResultLock;
 
@@ -624,9 +666,6 @@ class Camera3Device :
      */
     virtual CameraMetadata getLatestRequestLocked();
 
-    virtual status_t injectionCameraInitialize(const String8 &injectCamId,
-            sp<CameraProviderManager> manager) = 0;
-
     /**
      * Update the current device status and wake all waiting threads.
      *
@@ -875,6 +914,12 @@ class Camera3Device :
         void signalPipelineDrain(const std::vector<int>& streamIds);
         void resetPipelineDrain();
 
+        status_t switchToOffline(
+                const std::vector<int32_t>& streamsToKeep,
+                /*out*/hardware::camera::device::V3_6::CameraOfflineSessionInfo* offlineSessionInfo,
+                /*out*/sp<hardware::camera::device::V3_6::ICameraOfflineSession>* offlineSession,
+                /*out*/camera3::BufferRecords* bufferRecords);
+
         void clearPreviousRequest();
 
         status_t setRotateAndCropAutoBehavior(
@@ -889,6 +934,7 @@ class Camera3Device :
 
         virtual bool threadLoop();
 
+      private:
         static const String8& getId(const wp<Camera3Device> &device);
 
         status_t           queueTriggerLocked(RequestTrigger trigger);
@@ -962,9 +1008,8 @@ class Camera3Device :
         // send request in mNextRequests to HAL in a batch. Return true = sucssess
         bool sendRequestsBatch();
 
-        // Calculate the expected (minimum, maximum) duration range for a request
-        std::pair<nsecs_t, nsecs_t> calculateExpectedDurationRange(
-                const camera_metadata_t *request);
+        // Calculate the expected maximum duration for a request
+        nsecs_t calculateMaxExpectedDuration(const camera_metadata_t *request);
 
         // Check and update latest session parameters based on the current request settings.
         bool updateSessionParameters(const CameraMetadata& settings);
@@ -989,8 +1034,6 @@ class Camera3Device :
 
         Mutex              mRequestLock;
         Condition          mRequestSignal;
-        bool               mRequestClearing;
-
         Condition          mRequestSubmittedSignal;
         RequestList        mRequestQueue;
         RequestList        mRepeatingRequests;
@@ -1056,14 +1099,6 @@ class Camera3Device :
         const bool         mUseHalBufManager;
         const bool         mSupportCameraMute;
     };
-
-    virtual sp<RequestThread> createNewRequestThread(wp<Camera3Device> /*parent*/,
-                sp<camera3::StatusTracker> /*statusTracker*/,
-                sp<HalInterface> /*interface*/,
-                const Vector<int32_t>& /*sessionParamKeys*/,
-                bool /*useHalBufManager*/,
-                bool /*supportCameraMute*/) = 0;
-
     sp<RequestThread> mRequestThread;
 
     /**
@@ -1081,7 +1116,7 @@ class Camera3Device :
 
     status_t registerInFlight(uint32_t frameNumber,
             int32_t numBuffers, CaptureResultExtras resultExtras, bool hasInput,
-            bool callback, nsecs_t minExpectedDuration, nsecs_t maxExpectedDuration,
+            bool callback, nsecs_t maxExpectedDuration,
             const std::set<std::set<String8>>& physicalCameraIds,
             bool isStillCapture, bool isZslCapture, bool rotateAndCropAuto,
             const std::set<std::string>& cameraIdsWithZoom, const SurfaceMap& outputSurfaces,
@@ -1332,9 +1367,6 @@ class Camera3Device :
     // performance class.
     bool mOverrideForPerfClass;
 
-    // The current minimum expected frame duration based on AE_TARGET_FPS_RANGE
-    nsecs_t mMinExpectedDuration = 0;
-
     // Injection camera related methods.
     class Camera3DeviceInjectionMethods : public virtual RefBase {
       public:
@@ -1342,6 +1374,13 @@ class Camera3Device :
 
         ~Camera3DeviceInjectionMethods();
 
+        // Initialize the injection camera and generate an hal interface.
+        status_t injectionInitialize(
+                const String8& injectedCamId, sp<CameraProviderManager> manager,
+                const sp<
+                    android::hardware::camera::device::V3_2 ::ICameraDeviceCallback>&
+                    callback);
+
         // Injection camera will replace the internal camera and configure streams
         // when device is IDLE and request thread is paused.
         status_t injectCamera(
@@ -1367,7 +1406,7 @@ class Camera3Device :
                 const camera3::camera_stream_configuration& injectionConfig,
                 const std::vector<uint32_t>& injectionBufferSizes);
 
-      protected:
+      private:
         // Configure the streams of injection camera, it need wait until the
         // output streams are created and configured to the original camera before
         // proceeding.
@@ -1380,8 +1419,8 @@ class Camera3Device :
 
         // Use injection camera hal interface to replace and backup original
         // camera hal interface.
-        virtual status_t replaceHalInterface(sp<HalInterface> /*newHalInterface*/,
-                bool /*keepBackup*/) = 0;
+        status_t replaceHalInterface(sp<HalInterface> newHalInterface,
+                bool keepBackup);
 
         wp<Camera3Device> mParent;
 
@@ -1391,6 +1430,13 @@ class Camera3Device :
         // Generated injection camera hal interface.
         sp<HalInterface> mInjectedCamHalInterface;
 
+        // Backup of the original camera hal result FMQ.
+        std::unique_ptr<ResultMetadataQueue> mBackupResultMetadataQueue;
+
+        // FMQ writes the result for the injection camera. Must be guarded by
+        // mProcessCaptureResultLock.
+        std::unique_ptr<ResultMetadataQueue> mInjectionResultMetadataQueue;
+
         // The flag indicates that the stream configuration is complete, the camera device is
         // active, but the injection camera has not yet been injected.
         bool mIsStreamConfigCompleteButNotInjected = false;
@@ -1411,10 +1457,6 @@ class Camera3Device :
         // The injection camera ID.
         String8 mInjectedCamId;
     };
-
-    virtual sp<Camera3DeviceInjectionMethods>
-            createCamera3DeviceInjectionMethods(wp<Camera3Device>) = 0;
-
     sp<Camera3DeviceInjectionMethods> mInjectionMethods;
 
 }; // class Camera3Device
diff --git a/services/camera/libcameraservice/device3/Camera3DeviceInjectionMethods.cpp b/services/camera/libcameraservice/device3/Camera3DeviceInjectionMethods.cpp
index 031c25583a..4744a6deb7 100644
--- a/services/camera/libcameraservice/device3/Camera3DeviceInjectionMethods.cpp
+++ b/services/camera/libcameraservice/device3/Camera3DeviceInjectionMethods.cpp
@@ -26,6 +26,8 @@
 
 namespace android {
 
+using hardware::camera::device::V3_2::ICameraDeviceSession;
+
 Camera3Device::Camera3DeviceInjectionMethods::Camera3DeviceInjectionMethods(
         wp<Camera3Device> parent)
         : mParent(parent) {
@@ -37,6 +39,92 @@ Camera3Device::Camera3DeviceInjectionMethods::~Camera3DeviceInjectionMethods() {
     injectionDisconnectImpl();
 }
 
+status_t Camera3Device::Camera3DeviceInjectionMethods::injectionInitialize(
+        const String8& injectedCamId, sp<CameraProviderManager> manager,
+        const sp<android::hardware::camera::device::V3_2::ICameraDeviceCallback>&
+                callback) {
+    ATRACE_CALL();
+    Mutex::Autolock lock(mInjectionLock);
+
+    if (manager == nullptr) {
+        ALOGE("%s: manager does not exist!", __FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    sp<Camera3Device> parent = mParent.promote();
+    if (parent == nullptr) {
+        ALOGE("%s: parent does not exist!", __FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    mInjectedCamId = injectedCamId;
+    sp<ICameraDeviceSession> session;
+    ATRACE_BEGIN("Injection CameraHal::openSession");
+    status_t res = manager->openSession(injectedCamId.string(), callback,
+                                          /*out*/ &session);
+    ATRACE_END();
+    if (res != OK) {
+        ALOGE("Injection camera could not open camera session: %s (%d)",
+                strerror(-res), res);
+        return res;
+    }
+
+    std::shared_ptr<RequestMetadataQueue> queue;
+    auto requestQueueRet =
+        session->getCaptureRequestMetadataQueue([&queue](const auto& descriptor) {
+            queue = std::make_shared<RequestMetadataQueue>(descriptor);
+            if (!queue->isValid() || queue->availableToWrite() <= 0) {
+                ALOGE("Injection camera HAL returns empty request metadata fmq, not "
+                        "use it");
+                queue = nullptr;
+                // don't use the queue onwards.
+            }
+        });
+    if (!requestQueueRet.isOk()) {
+        ALOGE("Injection camera transaction error when getting request metadata fmq: "
+                "%s, not use it", requestQueueRet.description().c_str());
+        return DEAD_OBJECT;
+    }
+
+    std::unique_ptr<ResultMetadataQueue>& resQueue = mInjectionResultMetadataQueue;
+    auto resultQueueRet = session->getCaptureResultMetadataQueue(
+        [&resQueue](const auto& descriptor) {
+            resQueue = std::make_unique<ResultMetadataQueue>(descriptor);
+            if (!resQueue->isValid() || resQueue->availableToWrite() <= 0) {
+                ALOGE("Injection camera HAL returns empty result metadata fmq, not use "
+                        "it");
+                resQueue = nullptr;
+                // Don't use the resQueue onwards.
+            }
+        });
+    if (!resultQueueRet.isOk()) {
+        ALOGE("Injection camera transaction error when getting result metadata queue "
+                "from camera session: %s", resultQueueRet.description().c_str());
+        return DEAD_OBJECT;
+    }
+    IF_ALOGV() {
+        session->interfaceChain(
+                [](::android::hardware::hidl_vec<::android::hardware::hidl_string>
+                        interfaceChain) {
+                        ALOGV("Injection camera session interface chain:");
+                        for (const auto& iface : interfaceChain) {
+                            ALOGV("  %s", iface.c_str());
+                        }
+                });
+    }
+
+    ALOGV("%s: Injection camera interface = new HalInterface()", __FUNCTION__);
+    mInjectedCamHalInterface =
+            new HalInterface(session, queue, parent->mUseHalBufManager,
+                       parent->mSupportOfflineProcessing);
+    if (mInjectedCamHalInterface == nullptr) {
+        ALOGE("%s: mInjectedCamHalInterface does not exist!", __FUNCTION__);
+        return DEAD_OBJECT;
+    }
+
+    return OK;
+}
+
 status_t Camera3Device::Camera3DeviceInjectionMethods::injectCamera(
         camera3::camera_stream_configuration& injectionConfig,
         const std::vector<uint32_t>& injectionBufferSizes) {
@@ -291,4 +379,37 @@ void Camera3Device::Camera3DeviceInjectionMethods::injectionDisconnectImpl() {
     }
 }
 
+status_t Camera3Device::Camera3DeviceInjectionMethods::replaceHalInterface(
+        sp<HalInterface> newHalInterface, bool keepBackup) {
+    Mutex::Autolock lock(mInjectionLock);
+    if (newHalInterface.get() == nullptr) {
+        ALOGE("%s: The newHalInterface does not exist, to stop replacing.",
+                __FUNCTION__);
+        return DEAD_OBJECT;
+    }
+
+    sp<Camera3Device> parent = mParent.promote();
+    if (parent == nullptr) {
+        ALOGE("%s: parent does not exist!", __FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    if (keepBackup) {
+        if (mBackupHalInterface == nullptr) {
+            mBackupHalInterface = parent->mInterface;
+        }
+        if (mBackupResultMetadataQueue == nullptr) {
+            mBackupResultMetadataQueue = std::move(parent->mResultMetadataQueue);
+            parent->mResultMetadataQueue = std::move(mInjectionResultMetadataQueue);
+        }
+    } else {
+        mBackupHalInterface = nullptr;
+        parent->mResultMetadataQueue = std::move(mBackupResultMetadataQueue);
+        mBackupResultMetadataQueue = nullptr;
+    }
+    parent->mInterface = newHalInterface;
+
+    return OK;
+}
+
 };  // namespace android
diff --git a/services/camera/libcameraservice/device3/Camera3FakeStream.cpp b/services/camera/libcameraservice/device3/Camera3FakeStream.cpp
index 19afd69d8f..b121e5dd25 100644
--- a/services/camera/libcameraservice/device3/Camera3FakeStream.cpp
+++ b/services/camera/libcameraservice/device3/Camera3FakeStream.cpp
@@ -48,7 +48,7 @@ status_t Camera3FakeStream::getBufferLocked(camera_stream_buffer *,
 
 status_t Camera3FakeStream::returnBufferLocked(
         const camera_stream_buffer &,
-        nsecs_t, nsecs_t, int32_t, const std::vector<size_t>&) {
+        nsecs_t, int32_t, const std::vector<size_t>&) {
     ATRACE_CALL();
     ALOGE("%s: Stream %d: Fake stream cannot return buffers!", __FUNCTION__, mId);
     return INVALID_OPERATION;
@@ -56,7 +56,7 @@ status_t Camera3FakeStream::returnBufferLocked(
 
 status_t Camera3FakeStream::returnBufferCheckedLocked(
             const camera_stream_buffer &,
-            nsecs_t, nsecs_t,
+            nsecs_t,
             bool,
             int32_t,
             const std::vector<size_t>&,
@@ -76,7 +76,7 @@ void Camera3FakeStream::dump(int fd, const Vector<String16> &args) const {
     Camera3IOStreamBase::dump(fd, args);
 }
 
-status_t Camera3FakeStream::setTransform(int, bool) {
+status_t Camera3FakeStream::setTransform(int) {
     ATRACE_CALL();
     // Do nothing
     return OK;
diff --git a/services/camera/libcameraservice/device3/Camera3FakeStream.h b/services/camera/libcameraservice/device3/Camera3FakeStream.h
index 8cecabd861..c11a3e42fe 100644
--- a/services/camera/libcameraservice/device3/Camera3FakeStream.h
+++ b/services/camera/libcameraservice/device3/Camera3FakeStream.h
@@ -52,7 +52,7 @@ class Camera3FakeStream :
 
     virtual void     dump(int fd, const Vector<String16> &args) const;
 
-    status_t         setTransform(int transform, bool mayChangeMirror);
+    status_t         setTransform(int transform);
 
     virtual status_t detachBuffer(sp<GraphicBuffer>* buffer, int* fenceFd);
 
@@ -100,7 +100,6 @@ class Camera3FakeStream :
 
     virtual status_t setBatchSize(size_t batchSize) override;
 
-    virtual void onMinDurationChanged(nsecs_t /*duration*/) {}
   protected:
 
     /**
@@ -109,7 +108,6 @@ class Camera3FakeStream :
     virtual status_t returnBufferCheckedLocked(
             const camera_stream_buffer &buffer,
             nsecs_t timestamp,
-            nsecs_t readoutTimestamp,
             bool output,
             int32_t transform,
             const std::vector<size_t>& surface_ids,
@@ -137,8 +135,7 @@ class Camera3FakeStream :
             const std::vector<size_t>& surface_ids = std::vector<size_t>());
     virtual status_t returnBufferLocked(
             const camera_stream_buffer &buffer,
-            nsecs_t timestamp, nsecs_t readoutTimestamp, int32_t transform,
-            const std::vector<size_t>& surface_ids);
+            nsecs_t timestamp, int32_t transform, const std::vector<size_t>& surface_ids);
 
     virtual status_t configureQueueLocked();
 
diff --git a/services/camera/libcameraservice/device3/Camera3IOStreamBase.cpp b/services/camera/libcameraservice/device3/Camera3IOStreamBase.cpp
index add1483bf8..7b128e01d4 100644
--- a/services/camera/libcameraservice/device3/Camera3IOStreamBase.cpp
+++ b/services/camera/libcameraservice/device3/Camera3IOStreamBase.cpp
@@ -34,12 +34,10 @@ Camera3IOStreamBase::Camera3IOStreamBase(int id, camera_stream_type_t type,
         android_dataspace dataSpace, camera_stream_rotation_t rotation,
         const String8& physicalCameraId,
         const std::unordered_set<int32_t> &sensorPixelModesUsed,
-        int setId, bool isMultiResolution, int64_t dynamicRangeProfile, int64_t streamUseCase,
-        bool deviceTimeBaseIsRealtime, int timestampBase) :
+        int setId, bool isMultiResolution) :
         Camera3Stream(id, type,
                 width, height, maxSize, format, dataSpace, rotation,
-                physicalCameraId, sensorPixelModesUsed, setId, isMultiResolution,
-                dynamicRangeProfile, streamUseCase, deviceTimeBaseIsRealtime, timestampBase),
+                physicalCameraId, sensorPixelModesUsed, setId, isMultiResolution),
         mTotalBufferCount(0),
         mHandoutTotalBufferCount(0),
         mHandoutOutputBufferCount(0),
@@ -89,10 +87,6 @@ void Camera3IOStreamBase::dump(int fd, const Vector<String16> &args) const {
     if (strlen(camera_stream::physical_camera_id) > 0) {
         lines.appendFormat("      Physical camera id: %s\n", camera_stream::physical_camera_id);
     }
-    lines.appendFormat("      Dynamic Range Profile: 0x%" PRIx64 "\n",
-            camera_stream::dynamic_range_profile);
-    lines.appendFormat("      Stream use case: %" PRId64 "\n", camera_stream::use_case);
-    lines.appendFormat("      Timestamp base: %d\n", getTimestampBase());
     lines.appendFormat("      Frames produced: %d, last timestamp: %" PRId64 " ns\n",
             mFrameCount, mLastTimestamp);
     lines.appendFormat("      Total buffers: %zu, currently dequeued: %zu\n",
@@ -230,7 +224,6 @@ status_t Camera3IOStreamBase::returnBufferPreconditionCheckLocked() const {
 status_t Camera3IOStreamBase::returnAnyBufferLocked(
         const camera_stream_buffer &buffer,
         nsecs_t timestamp,
-        nsecs_t readoutTimestamp,
         bool output,
         int32_t transform,
         const std::vector<size_t>& surface_ids) {
@@ -249,8 +242,7 @@ status_t Camera3IOStreamBase::returnAnyBufferLocked(
     }
 
     sp<Fence> releaseFence;
-    res = returnBufferCheckedLocked(buffer, timestamp, readoutTimestamp,
-                                    output, transform, surface_ids,
+    res = returnBufferCheckedLocked(buffer, timestamp, output, transform, surface_ids,
                                     &releaseFence);
     // Res may be an error, but we still want to decrement our owned count
     // to enable clean shutdown. So we'll just return the error but otherwise
diff --git a/services/camera/libcameraservice/device3/Camera3IOStreamBase.h b/services/camera/libcameraservice/device3/Camera3IOStreamBase.h
index f389d53b16..6135b7e253 100644
--- a/services/camera/libcameraservice/device3/Camera3IOStreamBase.h
+++ b/services/camera/libcameraservice/device3/Camera3IOStreamBase.h
@@ -37,11 +37,7 @@ class Camera3IOStreamBase :
             android_dataspace dataSpace, camera_stream_rotation_t rotation,
             const String8& physicalCameraId,
             const std::unordered_set<int32_t> &sensorPixelModesUsed,
-            int setId = CAMERA3_STREAM_SET_ID_INVALID, bool isMultiResolution = false,
-            int64_t dynamicProfile = ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD,
-            int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT,
-            bool deviceTimeBaseIsRealtime = false,
-            int timestampBase = OutputConfiguration::TIMESTAMP_BASE_DEFAULT);
+            int setId = CAMERA3_STREAM_SET_ID_INVALID, bool isMultiResolution = false);
 
   public:
 
@@ -71,7 +67,6 @@ class Camera3IOStreamBase :
     status_t         returnAnyBufferLocked(
             const camera_stream_buffer &buffer,
             nsecs_t timestamp,
-            nsecs_t readoutTimestamp,
             bool output,
             int32_t transform,
             const std::vector<size_t>& surface_ids = std::vector<size_t>());
@@ -79,7 +74,6 @@ class Camera3IOStreamBase :
     virtual status_t returnBufferCheckedLocked(
             const camera_stream_buffer &buffer,
             nsecs_t timestamp,
-            nsecs_t readoutTimestamp,
             bool output,
             int32_t transform,
             const std::vector<size_t>& surface_ids,
diff --git a/services/camera/libcameraservice/device3/Camera3InputStream.cpp b/services/camera/libcameraservice/device3/Camera3InputStream.cpp
index 9a3f7ed4a7..6eb798eedf 100644
--- a/services/camera/libcameraservice/device3/Camera3InputStream.cpp
+++ b/services/camera/libcameraservice/device3/Camera3InputStream.cpp
@@ -105,7 +105,6 @@ status_t Camera3InputStream::getInputBufferLocked(
 status_t Camera3InputStream::returnBufferCheckedLocked(
             const camera_stream_buffer &buffer,
             nsecs_t timestamp,
-            nsecs_t readoutTimestamp,
             bool output,
             int32_t /*transform*/,
             const std::vector<size_t>&,
@@ -113,7 +112,6 @@ status_t Camera3InputStream::returnBufferCheckedLocked(
             sp<Fence> *releaseFenceOut) {
 
     (void)timestamp;
-    (void)readoutTimestamp;
     (void)output;
     ALOG_ASSERT(!output, "Expected output to be false");
 
@@ -178,8 +176,7 @@ status_t Camera3InputStream::returnInputBufferLocked(
         const camera_stream_buffer &buffer) {
     ATRACE_CALL();
 
-    return returnAnyBufferLocked(buffer, /*timestamp*/0, /*readoutTimestamp*/0,
-                                 /*output*/false, /*transform*/ -1);
+    return returnAnyBufferLocked(buffer, /*timestamp*/0, /*output*/false, /*transform*/ -1);
 }
 
 status_t Camera3InputStream::getInputBufferProducerLocked(
diff --git a/services/camera/libcameraservice/device3/Camera3InputStream.h b/services/camera/libcameraservice/device3/Camera3InputStream.h
index 5e0587b9ec..6f66bca8ef 100644
--- a/services/camera/libcameraservice/device3/Camera3InputStream.h
+++ b/services/camera/libcameraservice/device3/Camera3InputStream.h
@@ -61,7 +61,6 @@ class Camera3InputStream : public Camera3IOStreamBase,
     virtual status_t returnBufferCheckedLocked(
             const camera_stream_buffer &buffer,
             nsecs_t timestamp,
-            nsecs_t readoutTimestamp,
             bool output,
             int32_t transform,
             const std::vector<size_t>& surface_ids,
diff --git a/services/camera/libcameraservice/device3/Camera3OfflineSession.cpp b/services/camera/libcameraservice/device3/Camera3OfflineSession.cpp
index 7cfa255e6d..b702e20347 100644
--- a/services/camera/libcameraservice/device3/Camera3OfflineSession.cpp
+++ b/services/camera/libcameraservice/device3/Camera3OfflineSession.cpp
@@ -47,12 +47,14 @@ Camera3OfflineSession::Camera3OfflineSession(const String8 &id,
         const camera3::StreamSet& offlineStreamSet,
         camera3::BufferRecords&& bufferRecords,
         const camera3::InFlightRequestMap& offlineReqs,
-        const Camera3OfflineStates& offlineStates) :
+        const Camera3OfflineStates& offlineStates,
+        sp<hardware::camera::device::V3_6::ICameraOfflineSession> offlineSession) :
         mId(id),
         mInputStream(inputStream),
         mOutputStreams(offlineStreamSet),
         mBufferRecords(std::move(bufferRecords)),
         mOfflineReqs(offlineReqs),
+        mSession(offlineSession),
         mTagMonitor(offlineStates.mTagMonitor),
         mVendorTagId(offlineStates.mVendorTagId),
         mUseHalBufManager(offlineStates.mUseHalBufManager),
@@ -88,6 +90,43 @@ const String8& Camera3OfflineSession::getId() const {
     return mId;
 }
 
+status_t Camera3OfflineSession::initialize(wp<NotificationListener> listener) {
+    ATRACE_CALL();
+
+    if (mSession == nullptr) {
+        ALOGE("%s: HIDL session is null!", __FUNCTION__);
+        return DEAD_OBJECT;
+    }
+
+    {
+        std::lock_guard<std::mutex> lock(mLock);
+
+        mListener = listener;
+
+        // setup result FMQ
+        std::unique_ptr<ResultMetadataQueue>& resQueue = mResultMetadataQueue;
+        auto resultQueueRet = mSession->getCaptureResultMetadataQueue(
+            [&resQueue](const auto& descriptor) {
+                resQueue = std::make_unique<ResultMetadataQueue>(descriptor);
+                if (!resQueue->isValid() || resQueue->availableToWrite() <= 0) {
+                    ALOGE("HAL returns empty result metadata fmq, not use it");
+                    resQueue = nullptr;
+                    // Don't use resQueue onwards.
+                }
+            });
+        if (!resultQueueRet.isOk()) {
+            ALOGE("Transaction error when getting result metadata queue from camera session: %s",
+                    resultQueueRet.description().c_str());
+            return DEAD_OBJECT;
+        }
+        mStatus = STATUS_ACTIVE;
+    }
+
+    mSession->setCallback(this);
+
+    return OK;
+}
+
 status_t Camera3OfflineSession::dump(int /*fd*/) {
     ATRACE_CALL();
     std::lock_guard<std::mutex> il(mInterfaceLock);
@@ -96,7 +135,6 @@ status_t Camera3OfflineSession::dump(int /*fd*/) {
 
 status_t Camera3OfflineSession::disconnect() {
     ATRACE_CALL();
-    disconnectSession();
     return disconnectImpl();
 }
 
@@ -132,6 +170,10 @@ status_t Camera3OfflineSession::disconnectImpl() {
         streams.push_back(mInputStream);
     }
 
+    if (mSession != nullptr) {
+        mSession->close();
+    }
+
     FlushInflightReqStates states {
         mId, mOfflineReqsLock, mOfflineReqs, mUseHalBufManager,
         listener, *this, mBufferRecords, *this, mSessionStatsBuilder};
@@ -140,6 +182,7 @@ status_t Camera3OfflineSession::disconnectImpl() {
 
     {
         std::lock_guard<std::mutex> lock(mLock);
+        mSession.clear();
         mOutputStreams.clear();
         mInputStream.clear();
         mStatus = STATUS_CLOSED;
@@ -192,6 +235,149 @@ status_t Camera3OfflineSession::getNextResult(CaptureResult* frame) {
     return OK;
 }
 
+hardware::Return<void> Camera3OfflineSession::processCaptureResult_3_4(
+        const hardware::hidl_vec<
+                hardware::camera::device::V3_4::CaptureResult>& results) {
+    sp<NotificationListener> listener;
+    {
+        std::lock_guard<std::mutex> lock(mLock);
+        if (mStatus != STATUS_ACTIVE) {
+            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
+            return hardware::Void();
+        }
+        listener = mListener.promote();
+    }
+
+    CaptureOutputStates states {
+        mId,
+        mOfflineReqsLock, mLastCompletedRegularFrameNumber,
+        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
+        mOfflineReqs, mOutputLock, mResultQueue, mResultSignal,
+        mNextShutterFrameNumber,
+        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
+        mNextResultFrameNumber,
+        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
+        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
+        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
+        mResultMetadataQueue, mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
+        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this, *this,
+        mBufferRecords, /*legacyClient*/ false
+    };
+
+    std::lock_guard<std::mutex> lock(mProcessCaptureResultLock);
+    for (const auto& result : results) {
+        processOneCaptureResultLocked(states, result.v3_2, result.physicalCameraMetadata);
+    }
+    return hardware::Void();
+}
+
+hardware::Return<void> Camera3OfflineSession::processCaptureResult(
+        const hardware::hidl_vec<
+                hardware::camera::device::V3_2::CaptureResult>& results) {
+    // TODO: changed impl to call into processCaptureResult_3_4 instead?
+    //       might need to figure how to reduce copy though.
+    sp<NotificationListener> listener;
+    {
+        std::lock_guard<std::mutex> lock(mLock);
+        if (mStatus != STATUS_ACTIVE) {
+            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
+            return hardware::Void();
+        }
+        listener = mListener.promote();
+    }
+
+    hardware::hidl_vec<hardware::camera::device::V3_4::PhysicalCameraMetadata> noPhysMetadata;
+
+    CaptureOutputStates states {
+        mId,
+        mOfflineReqsLock, mLastCompletedRegularFrameNumber,
+        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
+        mOfflineReqs, mOutputLock, mResultQueue, mResultSignal,
+        mNextShutterFrameNumber,
+        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
+        mNextResultFrameNumber,
+        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
+        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
+        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
+        mResultMetadataQueue, mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
+        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this, *this,
+        mBufferRecords, /*legacyClient*/ false
+    };
+
+    std::lock_guard<std::mutex> lock(mProcessCaptureResultLock);
+    for (const auto& result : results) {
+        processOneCaptureResultLocked(states, result, noPhysMetadata);
+    }
+    return hardware::Void();
+}
+
+hardware::Return<void> Camera3OfflineSession::notify(
+        const hardware::hidl_vec<hardware::camera::device::V3_2::NotifyMsg>& msgs) {
+    sp<NotificationListener> listener;
+    {
+        std::lock_guard<std::mutex> lock(mLock);
+        if (mStatus != STATUS_ACTIVE) {
+            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
+            return hardware::Void();
+        }
+        listener = mListener.promote();
+    }
+
+    CaptureOutputStates states {
+        mId,
+        mOfflineReqsLock, mLastCompletedRegularFrameNumber,
+        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
+        mOfflineReqs, mOutputLock, mResultQueue, mResultSignal,
+        mNextShutterFrameNumber,
+        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
+        mNextResultFrameNumber,
+        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
+        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
+        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
+        mResultMetadataQueue, mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
+        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this, *this,
+        mBufferRecords, /*legacyClient*/ false
+    };
+    for (const auto& msg : msgs) {
+        camera3::notify(states, msg);
+    }
+    return hardware::Void();
+}
+
+hardware::Return<void> Camera3OfflineSession::requestStreamBuffers(
+        const hardware::hidl_vec<hardware::camera::device::V3_5::BufferRequest>& bufReqs,
+        requestStreamBuffers_cb _hidl_cb) {
+    {
+        std::lock_guard<std::mutex> lock(mLock);
+        if (mStatus != STATUS_ACTIVE) {
+            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
+            return hardware::Void();
+        }
+    }
+
+    RequestBufferStates states {
+        mId, mRequestBufferInterfaceLock, mUseHalBufManager, mOutputStreams, mSessionStatsBuilder,
+        *this, mBufferRecords, *this};
+    camera3::requestStreamBuffers(states, bufReqs, _hidl_cb);
+    return hardware::Void();
+}
+
+hardware::Return<void> Camera3OfflineSession::returnStreamBuffers(
+        const hardware::hidl_vec<hardware::camera::device::V3_2::StreamBuffer>& buffers) {
+    {
+        std::lock_guard<std::mutex> lock(mLock);
+        if (mStatus != STATUS_ACTIVE) {
+            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
+            return hardware::Void();
+        }
+    }
+
+    ReturnBufferStates states {
+        mId, mUseHalBufManager, mOutputStreams, mSessionStatsBuilder, mBufferRecords};
+    camera3::returnStreamBuffers(states, buffers);
+    return hardware::Void();
+}
+
 void Camera3OfflineSession::setErrorState(const char *fmt, ...) {
     ATRACE_CALL();
     std::lock_guard<std::mutex> lock(mLock);
diff --git a/services/camera/libcameraservice/device3/Camera3OfflineSession.h b/services/camera/libcameraservice/device3/Camera3OfflineSession.h
index a7997198e1..55819645f5 100644
--- a/services/camera/libcameraservice/device3/Camera3OfflineSession.h
+++ b/services/camera/libcameraservice/device3/Camera3OfflineSession.h
@@ -131,6 +131,7 @@ struct Camera3OfflineStates {
  */
 class Camera3OfflineSession :
             public CameraOfflineSessionBase,
+            virtual public hardware::camera::device::V3_5::ICameraDeviceCallback,
             public camera3::SetErrorInterface,
             public camera3::InflightRequestUpdateInterface,
             public camera3::RequestBufferInterface,
@@ -143,11 +144,12 @@ class Camera3OfflineSession :
             const camera3::StreamSet& offlineStreamSet,
             camera3::BufferRecords&& bufferRecords,
             const camera3::InFlightRequestMap& offlineReqs,
-            const Camera3OfflineStates& offlineStates);
+            const Camera3OfflineStates& offlineStates,
+            sp<hardware::camera::device::V3_6::ICameraOfflineSession> offlineSession);
 
     virtual ~Camera3OfflineSession();
 
-    virtual status_t initialize(wp<NotificationListener> /*listener*/) = 0;
+    virtual status_t initialize(wp<NotificationListener> listener) override;
 
     /**
      * CameraOfflineSessionBase interface
@@ -169,7 +171,38 @@ class Camera3OfflineSession :
      * End of CameraOfflineSessionBase interface
      */
 
-  protected:
+    /**
+     * HIDL ICameraDeviceCallback interface
+     */
+
+    /**
+     * Implementation of android::hardware::camera::device::V3_5::ICameraDeviceCallback
+     */
+
+    hardware::Return<void> processCaptureResult_3_4(
+            const hardware::hidl_vec<
+                    hardware::camera::device::V3_4::CaptureResult>& results) override;
+    hardware::Return<void> processCaptureResult(
+            const hardware::hidl_vec<
+                    hardware::camera::device::V3_2::CaptureResult>& results) override;
+    hardware::Return<void> notify(
+            const hardware::hidl_vec<
+                    hardware::camera::device::V3_2::NotifyMsg>& msgs) override;
+
+    hardware::Return<void> requestStreamBuffers(
+            const hardware::hidl_vec<
+                    hardware::camera::device::V3_5::BufferRequest>& bufReqs,
+            requestStreamBuffers_cb _hidl_cb) override;
+
+    hardware::Return<void> returnStreamBuffers(
+            const hardware::hidl_vec<
+                    hardware::camera::device::V3_2::StreamBuffer>& buffers) override;
+
+    /**
+     * End of CameraOfflineSessionBase interface
+     */
+
+  private:
     // Camera device ID
     const String8 mId;
     sp<camera3::Camera3Stream> mInputStream;
@@ -180,6 +213,8 @@ class Camera3OfflineSession :
     std::mutex mOfflineReqsLock;
     camera3::InFlightRequestMap mOfflineReqs;
 
+    sp<hardware::camera::device::V3_6::ICameraOfflineSession> mSession;
+
     TagMonitor mTagMonitor;
     const metadata_vendor_id_t mVendorTagId;
 
@@ -234,6 +269,8 @@ class Camera3OfflineSession :
     // End of mLock protect scope
 
     std::mutex mProcessCaptureResultLock;
+    // FMQ to write result on. Must be guarded by mProcessCaptureResultLock.
+    std::unique_ptr<ResultMetadataQueue> mResultMetadataQueue;
 
     // Tracking cause of fatal errors when in STATUS_ERROR
     String8 mErrorCause;
@@ -246,9 +283,6 @@ class Camera3OfflineSession :
     // For client methods such as disconnect/dump
     std::mutex mInterfaceLock;
 
-    // The current minimum expected frame duration based on AE_TARGET_FPS_RANGE
-    nsecs_t mMinExpectedDuration = 0;
-
     // SetErrorInterface
     void setErrorState(const char *fmt, ...) override;
     void setErrorStateLocked(const char *fmt, ...) override;
@@ -271,8 +305,6 @@ class Camera3OfflineSession :
     void setErrorStateLockedV(const char *fmt, va_list args);
 
     status_t disconnectImpl();
-    virtual void disconnectSession() = 0;
-
 }; // class Camera3OfflineSession
 
 }; // namespace android
diff --git a/services/camera/libcameraservice/device3/Camera3OutputStream.cpp b/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
index 1e20ee0eb8..c6f5759780 100644
--- a/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
+++ b/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
@@ -18,20 +18,15 @@
 #define ATRACE_TAG ATRACE_TAG_CAMERA
 //#define LOG_NDEBUG 0
 
-#include <algorithm>
 #include <ctime>
 #include <fstream>
 
-#include <aidl/android/hardware/camera/device/CameraBlob.h>
-#include <aidl/android/hardware/camera/device/CameraBlobId.h>
-
 #include <android-base/unique_fd.h>
 #include <cutils/properties.h>
 #include <ui/GraphicBuffer.h>
 #include <utils/Log.h>
 #include <utils/Trace.h>
 
-#include <common/CameraDeviceBase.h>
 #include "api1/client2/JpegProcessor.h"
 #include "Camera3OutputStream.h"
 #include "utils/TraceHFR.h"
@@ -45,23 +40,16 @@ namespace android {
 
 namespace camera3 {
 
-using aidl::android::hardware::camera::device::CameraBlob;
-using aidl::android::hardware::camera::device::CameraBlobId;
-
 Camera3OutputStream::Camera3OutputStream(int id,
         sp<Surface> consumer,
         uint32_t width, uint32_t height, int format,
         android_dataspace dataSpace, camera_stream_rotation_t rotation,
         nsecs_t timestampOffset, const String8& physicalCameraId,
-        const std::unordered_set<int32_t> &sensorPixelModesUsed, IPCTransport transport,
-        int setId, bool isMultiResolution, int64_t dynamicRangeProfile,
-        int64_t streamUseCase, bool deviceTimeBaseIsRealtime, int timestampBase,
-        int mirrorMode) :
+        const std::unordered_set<int32_t> &sensorPixelModesUsed,
+        int setId, bool isMultiResolution) :
         Camera3IOStreamBase(id, CAMERA_STREAM_OUTPUT, width, height,
                             /*maxSize*/0, format, dataSpace, rotation,
-                            physicalCameraId, sensorPixelModesUsed, setId, isMultiResolution,
-                            dynamicRangeProfile, streamUseCase, deviceTimeBaseIsRealtime,
-                            timestampBase),
+                            physicalCameraId, sensorPixelModesUsed, setId, isMultiResolution),
         mConsumer(consumer),
         mTransform(0),
         mTraceFirstBuffer(true),
@@ -69,9 +57,7 @@ Camera3OutputStream::Camera3OutputStream(int id,
         mTimestampOffset(timestampOffset),
         mConsumerUsage(0),
         mDropBuffers(false),
-        mMirrorMode(mirrorMode),
-        mDequeueBufferLatency(kDequeueLatencyBinSize),
-        mIPCTransport(transport) {
+        mDequeueBufferLatency(kDequeueLatencyBinSize) {
 
     if (mConsumer == NULL) {
         ALOGE("%s: Consumer is NULL!", __FUNCTION__);
@@ -87,24 +73,20 @@ Camera3OutputStream::Camera3OutputStream(int id,
         uint32_t width, uint32_t height, size_t maxSize, int format,
         android_dataspace dataSpace, camera_stream_rotation_t rotation,
         nsecs_t timestampOffset, const String8& physicalCameraId,
-        const std::unordered_set<int32_t> &sensorPixelModesUsed, IPCTransport transport,
-        int setId, bool isMultiResolution, int64_t dynamicRangeProfile,
-        int64_t streamUseCase, bool deviceTimeBaseIsRealtime, int timestampBase,
-        int mirrorMode) :
+        const std::unordered_set<int32_t> &sensorPixelModesUsed,
+        int setId, bool isMultiResolution) :
         Camera3IOStreamBase(id, CAMERA_STREAM_OUTPUT, width, height, maxSize,
                             format, dataSpace, rotation, physicalCameraId, sensorPixelModesUsed,
-                            setId, isMultiResolution, dynamicRangeProfile, streamUseCase,
-                            deviceTimeBaseIsRealtime, timestampBase),
+                            setId, isMultiResolution),
         mConsumer(consumer),
         mTransform(0),
         mTraceFirstBuffer(true),
+        mUseMonoTimestamp(false),
         mUseBufferManager(false),
         mTimestampOffset(timestampOffset),
         mConsumerUsage(0),
         mDropBuffers(false),
-        mMirrorMode(mirrorMode),
-        mDequeueBufferLatency(kDequeueLatencyBinSize),
-        mIPCTransport(transport) {
+        mDequeueBufferLatency(kDequeueLatencyBinSize) {
 
     if (format != HAL_PIXEL_FORMAT_BLOB && format != HAL_PIXEL_FORMAT_RAW_OPAQUE) {
         ALOGE("%s: Bad format for size-only stream: %d", __FUNCTION__,
@@ -126,15 +108,11 @@ Camera3OutputStream::Camera3OutputStream(int id,
         uint64_t consumerUsage, android_dataspace dataSpace,
         camera_stream_rotation_t rotation, nsecs_t timestampOffset,
         const String8& physicalCameraId,
-        const std::unordered_set<int32_t> &sensorPixelModesUsed, IPCTransport transport,
-        int setId, bool isMultiResolution, int64_t dynamicRangeProfile,
-        int64_t streamUseCase, bool deviceTimeBaseIsRealtime, int timestampBase,
-        int mirrorMode) :
+        const std::unordered_set<int32_t> &sensorPixelModesUsed,
+        int setId, bool isMultiResolution) :
         Camera3IOStreamBase(id, CAMERA_STREAM_OUTPUT, width, height,
                             /*maxSize*/0, format, dataSpace, rotation,
-                            physicalCameraId, sensorPixelModesUsed, setId, isMultiResolution,
-                            dynamicRangeProfile, streamUseCase, deviceTimeBaseIsRealtime,
-                            timestampBase),
+                            physicalCameraId, sensorPixelModesUsed, setId, isMultiResolution),
         mConsumer(nullptr),
         mTransform(0),
         mTraceFirstBuffer(true),
@@ -142,9 +120,7 @@ Camera3OutputStream::Camera3OutputStream(int id,
         mTimestampOffset(timestampOffset),
         mConsumerUsage(consumerUsage),
         mDropBuffers(false),
-        mMirrorMode(mirrorMode),
-        mDequeueBufferLatency(kDequeueLatencyBinSize),
-        mIPCTransport(transport) {
+        mDequeueBufferLatency(kDequeueLatencyBinSize) {
     // Deferred consumer only support preview surface format now.
     if (format != HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED) {
         ALOGE("%s: Deferred consumer only supports IMPLEMENTATION_DEFINED format now!",
@@ -171,28 +147,21 @@ Camera3OutputStream::Camera3OutputStream(int id, camera_stream_type_t type,
                                          android_dataspace dataSpace,
                                          camera_stream_rotation_t rotation,
                                          const String8& physicalCameraId,
-                                         const std::unordered_set<int32_t> &sensorPixelModesUsed,
-                                         IPCTransport transport,
+                                        const std::unordered_set<int32_t> &sensorPixelModesUsed,
                                          uint64_t consumerUsage, nsecs_t timestampOffset,
-                                         int setId, bool isMultiResolution,
-                                         int64_t dynamicRangeProfile, int64_t streamUseCase,
-                                         bool deviceTimeBaseIsRealtime, int timestampBase,
-                                         int mirrorMode) :
+                                         int setId, bool isMultiResolution) :
         Camera3IOStreamBase(id, type, width, height,
                             /*maxSize*/0,
                             format, dataSpace, rotation,
-                            physicalCameraId, sensorPixelModesUsed, setId, isMultiResolution,
-                            dynamicRangeProfile, streamUseCase, deviceTimeBaseIsRealtime,
-                            timestampBase),
+                            physicalCameraId, sensorPixelModesUsed, setId, isMultiResolution),
         mTransform(0),
         mTraceFirstBuffer(true),
+        mUseMonoTimestamp(false),
         mUseBufferManager(false),
         mTimestampOffset(timestampOffset),
         mConsumerUsage(consumerUsage),
         mDropBuffers(false),
-        mMirrorMode(mirrorMode),
-        mDequeueBufferLatency(kDequeueLatencyBinSize),
-        mIPCTransport(transport) {
+        mDequeueBufferLatency(kDequeueLatencyBinSize) {
 
     bool needsReleaseNotify = setId > CAMERA3_STREAM_SET_ID_INVALID;
     mBufferProducerListener = new BufferProducerListener(this, needsReleaseNotify);
@@ -295,16 +264,14 @@ status_t Camera3OutputStream::queueBufferToConsumer(sp<ANativeWindow>& consumer,
 
 status_t Camera3OutputStream::returnBufferLocked(
         const camera_stream_buffer &buffer,
-        nsecs_t timestamp, nsecs_t readoutTimestamp,
-        int32_t transform, const std::vector<size_t>& surface_ids) {
+        nsecs_t timestamp, int32_t transform, const std::vector<size_t>& surface_ids) {
     ATRACE_HFR_CALL();
 
     if (mHandoutTotalBufferCount == 1) {
         returnPrefetchedBuffersLocked();
     }
 
-    status_t res = returnAnyBufferLocked(buffer, timestamp, readoutTimestamp,
-                                         /*output*/true, transform, surface_ids);
+    status_t res = returnAnyBufferLocked(buffer, timestamp, /*output*/true, transform, surface_ids);
 
     if (res != OK) {
         return res;
@@ -316,79 +283,9 @@ status_t Camera3OutputStream::returnBufferLocked(
     return OK;
 }
 
-status_t Camera3OutputStream::fixUpHidlJpegBlobHeader(ANativeWindowBuffer* anwBuffer, int fence) {
-    // Lock the JPEG buffer for CPU read
-    sp<GraphicBuffer> graphicBuffer = GraphicBuffer::from(anwBuffer);
-    void* mapped = nullptr;
-    base::unique_fd fenceFd(dup(fence));
-    // Use USAGE_SW_WRITE_RARELY since we're going to re-write the CameraBlob
-    // header.
-    GraphicBufferLocker gbLocker(graphicBuffer);
-    status_t res =
-            gbLocker.lockAsync(
-                    GraphicBuffer::USAGE_SW_READ_OFTEN | GraphicBuffer::USAGE_SW_WRITE_RARELY,
-                    &mapped, fenceFd.get());
-    if (res != OK) {
-        ALOGE("%s: Failed to lock the buffer: %s (%d)", __FUNCTION__, strerror(-res), res);
-        return res;
-    }
-
-    uint8_t *hidlHeaderStart =
-            static_cast<uint8_t*>(mapped) + graphicBuffer->getWidth() - sizeof(camera_jpeg_blob_t);
-    // Check that the jpeg buffer is big enough to contain HIDL camera blob
-    if (hidlHeaderStart < static_cast<uint8_t *>(mapped)) {
-        ALOGE("%s, jpeg buffer not large enough to fit HIDL camera blob %" PRIu32, __FUNCTION__,
-                graphicBuffer->getWidth());
-        return BAD_VALUE;
-    }
-    camera_jpeg_blob_t *hidlBlobHeader = reinterpret_cast<camera_jpeg_blob_t *>(hidlHeaderStart);
-
-    // Check that the blob is indeed the jpeg blob id.
-    if (hidlBlobHeader->jpeg_blob_id != CAMERA_JPEG_BLOB_ID) {
-        ALOGE("%s, jpeg blob id %d is not correct", __FUNCTION__, hidlBlobHeader->jpeg_blob_id);
-        return BAD_VALUE;
-    }
-
-    // Retrieve id and blob size
-    CameraBlobId blobId = static_cast<CameraBlobId>(hidlBlobHeader->jpeg_blob_id);
-    uint32_t blobSizeBytes = hidlBlobHeader->jpeg_size;
-
-    if (blobSizeBytes > (graphicBuffer->getWidth() - sizeof(camera_jpeg_blob_t))) {
-        ALOGE("%s, blobSize in HIDL jpeg blob : %d is corrupt, buffer size %" PRIu32, __FUNCTION__,
-                  blobSizeBytes, graphicBuffer->getWidth());
-    }
-
-    uint8_t *aidlHeaderStart =
-            static_cast<uint8_t*>(mapped) + graphicBuffer->getWidth() - sizeof(CameraBlob);
-
-    // Check that the jpeg buffer is big enough to contain AIDL camera blob
-    if (aidlHeaderStart < static_cast<uint8_t *>(mapped)) {
-        ALOGE("%s, jpeg buffer not large enough to fit AIDL camera blob %" PRIu32, __FUNCTION__,
-                graphicBuffer->getWidth());
-        return BAD_VALUE;
-    }
-
-    if (static_cast<uint8_t*>(mapped) + blobSizeBytes > aidlHeaderStart) {
-        ALOGE("%s, jpeg blob with size %d , buffer size %" PRIu32 " not large enough to fit"
-                " AIDL camera blob without corrupting jpeg", __FUNCTION__, blobSizeBytes,
-                graphicBuffer->getWidth());
-        return BAD_VALUE;
-    }
-
-    // Fill in JPEG header
-    CameraBlob aidlHeader = {
-            .blobId = blobId,
-            .blobSizeBytes = static_cast<int32_t>(blobSizeBytes)
-    };
-    memcpy(aidlHeaderStart, &aidlHeader, sizeof(CameraBlob));
-    graphicBuffer->unlock();
-    return OK;
-}
-
 status_t Camera3OutputStream::returnBufferCheckedLocked(
             const camera_stream_buffer &buffer,
             nsecs_t timestamp,
-            nsecs_t readoutTimestamp,
             bool output,
             int32_t transform,
             const std::vector<size_t>& surface_ids,
@@ -450,42 +347,34 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
             }
             mTraceFirstBuffer = false;
         }
-        // Fix CameraBlob id type discrepancy between HIDL and AIDL, details : http://b/229688810
-        if (getFormat() == HAL_PIXEL_FORMAT_BLOB && getDataSpace() == HAL_DATASPACE_V0_JFIF) {
-            if (mIPCTransport == IPCTransport::HIDL) {
-                fixUpHidlJpegBlobHeader(anwBuffer, anwReleaseFence);
-            }
-            // If this is a JPEG output, and image dump mask is set, save image to
-            // disk.
-            if (mImageDumpMask) {
-                dumpImageToDisk(timestamp, anwBuffer, anwReleaseFence);
-            }
+
+        // If this is a JPEG output, and image dump mask is set, save image to
+        // disk.
+        if (getFormat() == HAL_PIXEL_FORMAT_BLOB && getDataSpace() == HAL_DATASPACE_V0_JFIF &&
+                mImageDumpMask) {
+            dumpImageToDisk(timestamp, anwBuffer, anwReleaseFence);
         }
 
-        if (mPreviewFrameSpacer != nullptr) {
-            res = mPreviewFrameSpacer->queuePreviewBuffer(timestamp - mTimestampOffset,
-                    readoutTimestamp - mTimestampOffset, transform, anwBuffer, anwReleaseFence);
+        /* Certain consumers (such as AudioSource or HardwareComposer) use
+         * MONOTONIC time, causing time misalignment if camera timestamp is
+         * in BOOTTIME. Do the conversion if necessary. */
+        nsecs_t adjustedTs = mUseMonoTimestamp ? timestamp - mTimestampOffset : timestamp;
+        if (mPreviewFrameScheduler != nullptr) {
+            res = mPreviewFrameScheduler->queuePreviewBuffer(adjustedTs, transform,
+                    anwBuffer, anwReleaseFence);
             if (res != OK) {
-                ALOGE("%s: Stream %d: Error queuing buffer to preview buffer spacer: %s (%d)",
+                ALOGE("%s: Stream %d: Error queuing buffer to preview buffer scheduler: %s (%d)",
                         __FUNCTION__, mId, strerror(-res), res);
                 return res;
             }
         } else {
-            nsecs_t captureTime = (mSyncToDisplay ? readoutTimestamp : timestamp)
-                    - mTimestampOffset;
-            nsecs_t presentTime = mSyncToDisplay ?
-                    syncTimestampToDisplayLocked(captureTime) : captureTime;
-
-            setTransform(transform, true/*mayChangeMirror*/);
-            res = native_window_set_buffers_timestamp(mConsumer.get(), presentTime);
+            setTransform(transform);
+            res = native_window_set_buffers_timestamp(mConsumer.get(), adjustedTs);
             if (res != OK) {
                 ALOGE("%s: Stream %d: Error setting timestamp: %s (%d)",
                       __FUNCTION__, mId, strerror(-res), res);
                 return res;
             }
-
-            queueHDRMetadata(anwBuffer->handle, currentConsumer, dynamic_range_profile);
-
             res = queueBufferToConsumer(currentConsumer, anwBuffer, anwReleaseFence, surface_ids);
             if (shouldLogError(res, state)) {
                 ALOGE("%s: Stream %d: Error queueing buffer to native window:"
@@ -523,15 +412,9 @@ void Camera3OutputStream::dump(int fd, const Vector<String16> &args) const {
         "      DequeueBuffer latency histogram:");
 }
 
-status_t Camera3OutputStream::setTransform(int transform, bool mayChangeMirror) {
+status_t Camera3OutputStream::setTransform(int transform) {
     ATRACE_CALL();
     Mutex::Autolock l(mLock);
-    if (mMirrorMode != OutputConfiguration::MIRROR_MODE_AUTO && mayChangeMirror) {
-        // If the mirroring mode is not AUTO, do not allow transform update
-        // which may change mirror.
-        return OK;
-    }
-
     return setTransformLocked(transform);
 }
 
@@ -565,7 +448,7 @@ status_t Camera3OutputStream::configureQueueLocked() {
         return res;
     }
 
-    if ((res = configureConsumerQueueLocked(true /*allowPreviewRespace*/)) != OK) {
+    if ((res = configureConsumerQueueLocked(true /*allowPreviewScheduler*/)) != OK) {
         return res;
     }
 
@@ -589,7 +472,7 @@ status_t Camera3OutputStream::configureQueueLocked() {
     return OK;
 }
 
-status_t Camera3OutputStream::configureConsumerQueueLocked(bool allowPreviewRespace) {
+status_t Camera3OutputStream::configureConsumerQueueLocked(bool allowPreviewScheduler) {
     status_t res;
 
     mTraceFirstBuffer = true;
@@ -675,56 +558,19 @@ status_t Camera3OutputStream::configureConsumerQueueLocked(bool allowPreviewResp
     }
 
     mTotalBufferCount = maxConsumerBuffers + camera_stream::max_buffers;
-
-    int timestampBase = getTimestampBase();
-    bool isDefaultTimeBase = (timestampBase ==
-            OutputConfiguration::TIMESTAMP_BASE_DEFAULT);
-    if (allowPreviewRespace)  {
-        bool forceChoreographer = (timestampBase ==
-                OutputConfiguration::TIMESTAMP_BASE_CHOREOGRAPHER_SYNCED);
-        bool defaultToChoreographer = (isDefaultTimeBase &&
-                isConsumedByHWComposer());
-        bool defaultToSpacer = (isDefaultTimeBase &&
-                isConsumedByHWTexture() &&
-                !isConsumedByCPU() &&
-                !isVideoStream());
-        if (forceChoreographer || defaultToChoreographer) {
-            mSyncToDisplay = true;
-            mTotalBufferCount += kDisplaySyncExtraBuffer;
-        } else if (defaultToSpacer) {
-            mPreviewFrameSpacer = new PreviewFrameSpacer(this, mConsumer);
-            mTotalBufferCount ++;
-            res = mPreviewFrameSpacer->run(String8::format("PreviewSpacer-%d", mId).string());
-            if (res != OK) {
-                ALOGE("%s: Unable to start preview spacer", __FUNCTION__);
-                return res;
-            }
+    if (allowPreviewScheduler && isConsumedByHWComposer()) {
+        // We cannot distinguish between a SurfaceView and an ImageReader of
+        // preview buffer format. The PreviewFrameScheduler needs to handle both.
+        if (!property_get_bool("camera.disable_preview_scheduler", false)) {
+            mPreviewFrameScheduler = std::make_unique<PreviewFrameScheduler>(*this, mConsumer);
+            mTotalBufferCount += PreviewFrameScheduler::kQueueDepthWatermark;
         }
     }
+
     mHandoutTotalBufferCount = 0;
     mFrameCount = 0;
     mLastTimestamp = 0;
-
-    if (isDeviceTimeBaseRealtime()) {
-        if (isDefaultTimeBase && !isConsumedByHWComposer() && !isVideoStream()) {
-            // Default time base, but not hardware composer or video encoder
-            mTimestampOffset = 0;
-        } else if (timestampBase == OutputConfiguration::TIMESTAMP_BASE_REALTIME ||
-                timestampBase == OutputConfiguration::TIMESTAMP_BASE_SENSOR) {
-            mTimestampOffset = 0;
-        }
-        // If timestampBase is CHOREOGRAPHER SYNCED or MONOTONIC, leave
-        // timestamp offset as bootTime - monotonicTime.
-    } else {
-        if (timestampBase == OutputConfiguration::TIMESTAMP_BASE_REALTIME) {
-            // Reverse offset for monotonicTime -> bootTime
-            mTimestampOffset = -mTimestampOffset;
-        } else {
-            // If timestampBase is DEFAULT, MONOTONIC, SENSOR, or
-            // CHOREOGRAPHER_SYNCED, timestamp offset is 0.
-            mTimestampOffset = 0;
-        }
-    }
+    mUseMonoTimestamp = (isConsumedByHWComposer() || isVideoStream());
 
     res = native_window_set_buffer_count(mConsumer.get(),
             mTotalBufferCount);
@@ -973,10 +819,6 @@ status_t Camera3OutputStream::disconnectLocked() {
 
     returnPrefetchedBuffersLocked();
 
-    if (mPreviewFrameSpacer != nullptr) {
-        mPreviewFrameSpacer->requestExit();
-    }
-
     ALOGV("%s: disconnecting stream %d from native window", __FUNCTION__, getId());
 
     res = native_window_api_disconnect(mConsumer.get(),
@@ -1270,17 +1112,6 @@ bool Camera3OutputStream::isConsumedByHWTexture() const {
     return (usage & GRALLOC_USAGE_HW_TEXTURE) != 0;
 }
 
-bool Camera3OutputStream::isConsumedByCPU() const {
-    uint64_t usage = 0;
-    status_t res = getEndpointUsage(&usage);
-    if (res != OK) {
-        ALOGE("%s: getting end point usage failed: %s (%d).", __FUNCTION__, strerror(-res), res);
-        return false;
-    }
-
-    return (usage & GRALLOC_USAGE_SW_READ_MASK) != 0;
-}
-
 void Camera3OutputStream::dumpImageToDisk(nsecs_t timestamp,
         ANativeWindowBuffer* anwBuffer, int fence) {
     // Deriver output file name
@@ -1357,11 +1188,6 @@ status_t Camera3OutputStream::setBatchSize(size_t batchSize) {
     return OK;
 }
 
-void Camera3OutputStream::onMinDurationChanged(nsecs_t duration) {
-    Mutex::Autolock l(mLock);
-    mMinExpectedDuration = duration;
-}
-
 void Camera3OutputStream::returnPrefetchedBuffersLocked() {
     std::vector<Surface::BatchBuffer> batchedBuffers;
 
@@ -1379,94 +1205,6 @@ void Camera3OutputStream::returnPrefetchedBuffersLocked() {
     }
 }
 
-nsecs_t Camera3OutputStream::syncTimestampToDisplayLocked(nsecs_t t) {
-    ParcelableVsyncEventData parcelableVsyncEventData;
-    auto res = mDisplayEventReceiver.getLatestVsyncEventData(&parcelableVsyncEventData);
-    if (res != OK) {
-        ALOGE("%s: Stream %d: Error getting latest vsync event data: %s (%d)",
-                __FUNCTION__, mId, strerror(-res), res);
-        mLastCaptureTime = t;
-        mLastPresentTime = t;
-        return t;
-    }
-
-    const VsyncEventData& vsyncEventData = parcelableVsyncEventData.vsync;
-    nsecs_t currentTime = systemTime();
-
-    // Reset capture to present time offset if:
-    // - More than 1 second between frames.
-    // - The frame duration deviates from multiples of vsync frame intervals.
-    nsecs_t captureInterval = t - mLastCaptureTime;
-    float captureToVsyncIntervalRatio = 1.0f * captureInterval / vsyncEventData.frameInterval;
-    float ratioDeviation = std::fabs(
-            captureToVsyncIntervalRatio - std::roundf(captureToVsyncIntervalRatio));
-    if (captureInterval > kSpacingResetIntervalNs ||
-            ratioDeviation >= kMaxIntervalRatioDeviation) {
-        nsecs_t minPresentT = mLastPresentTime + vsyncEventData.frameInterval / 2;
-        for (size_t i = 0; i < VsyncEventData::kFrameTimelinesLength; i++) {
-            const auto& timeline = vsyncEventData.frameTimelines[i];
-            if (timeline.deadlineTimestamp >= currentTime &&
-                    timeline.expectedPresentationTime > minPresentT) {
-                nsecs_t presentT = vsyncEventData.frameTimelines[i].expectedPresentationTime;
-                mCaptureToPresentOffset = presentT - t;
-                mLastCaptureTime = t;
-                mLastPresentTime = presentT;
-
-                // Move the expected presentation time back by 1/3 of frame interval to
-                // mitigate the time drift. Due to time drift, if we directly use the
-                // expected presentation time, often times 2 expected presentation time
-                // falls into the same VSYNC interval.
-                return presentT - vsyncEventData.frameInterval/3;
-            }
-        }
-    }
-
-    nsecs_t idealPresentT = t + mCaptureToPresentOffset;
-    nsecs_t expectedPresentT = mLastPresentTime;
-    nsecs_t minDiff = INT64_MAX;
-    // Derive minimum intervals between presentation times based on minimal
-    // expected duration. The minimum number of Vsyncs is:
-    // - 0 if minFrameDuration in (0, 1.5] * vSyncInterval,
-    // - 1 if minFrameDuration in (1.5, 2.5] * vSyncInterval,
-    // - and so on.
-    int minVsyncs = (mMinExpectedDuration - vsyncEventData.frameInterval / 2) /
-            vsyncEventData.frameInterval;
-    if (minVsyncs < 0) minVsyncs = 0;
-    nsecs_t minInterval = minVsyncs * vsyncEventData.frameInterval;
-    // Find best timestamp in the vsync timelines:
-    // - Only use at most 3 timelines to avoid long latency
-    // - closest to the ideal present time,
-    // - deadline timestamp is greater than the current time, and
-    // - the candidate present time is at least minInterval in the future
-    //   compared to last present time.
-    int maxTimelines = std::min(kMaxTimelines, (int)VsyncEventData::kFrameTimelinesLength);
-    float biasForShortDelay = 1.0f;
-    for (int i = 0; i < maxTimelines; i ++) {
-        const auto& vsyncTime = vsyncEventData.frameTimelines[i];
-        if (minVsyncs > 0) {
-            // Bias towards using smaller timeline index:
-            //   i = 0:                bias = 1
-            //   i = maxTimelines-1:   bias = -1
-            biasForShortDelay = 1.0 - 2.0 * i / (maxTimelines - 1);
-        }
-        if (std::abs(vsyncTime.expectedPresentationTime - idealPresentT) < minDiff &&
-                vsyncTime.deadlineTimestamp >= currentTime &&
-                vsyncTime.expectedPresentationTime >
-                mLastPresentTime + minInterval + biasForShortDelay * kTimelineThresholdNs) {
-            expectedPresentT = vsyncTime.expectedPresentationTime;
-            minDiff = std::abs(vsyncTime.expectedPresentationTime - idealPresentT);
-        }
-    }
-    mLastCaptureTime = t;
-    mLastPresentTime = expectedPresentT;
-
-    // Move the expected presentation time back by 1/3 of frame interval to
-    // mitigate the time drift. Due to time drift, if we directly use the
-    // expected presentation time, often times 2 expected presentation time
-    // falls into the same VSYNC interval.
-    return expectedPresentT - vsyncEventData.frameInterval/3;
-}
-
 bool Camera3OutputStream::shouldLogError(status_t res) {
     Mutex::Autolock l(mLock);
     return shouldLogError(res, mState);
diff --git a/services/camera/libcameraservice/device3/Camera3OutputStream.h b/services/camera/libcameraservice/device3/Camera3OutputStream.h
index e8065cee42..b2b574a7ac 100644
--- a/services/camera/libcameraservice/device3/Camera3OutputStream.h
+++ b/services/camera/libcameraservice/device3/Camera3OutputStream.h
@@ -21,15 +21,13 @@
 #include <utils/RefBase.h>
 #include <gui/IProducerListener.h>
 #include <gui/Surface.h>
-#include <gui/DisplayEventReceiver.h>
 
-#include "utils/IPCTransport.h"
 #include "utils/LatencyHistogram.h"
 #include "Camera3Stream.h"
 #include "Camera3IOStreamBase.h"
 #include "Camera3OutputStreamInterface.h"
 #include "Camera3BufferManager.h"
-#include "PreviewFrameSpacer.h"
+#include "PreviewFrameScheduler.h"
 
 namespace android {
 
@@ -90,13 +88,8 @@ class Camera3OutputStream :
             uint32_t width, uint32_t height, int format,
             android_dataspace dataSpace, camera_stream_rotation_t rotation,
             nsecs_t timestampOffset, const String8& physicalCameraId,
-            const std::unordered_set<int32_t> &sensorPixelModesUsed, IPCTransport transport,
-            int setId = CAMERA3_STREAM_SET_ID_INVALID, bool isMultiResolution = false,
-            int64_t dynamicProfile = ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD,
-            int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT,
-            bool deviceTimeBaseIsRealtime = false,
-            int timestampBase = OutputConfiguration::TIMESTAMP_BASE_DEFAULT,
-            int mirrorMode = OutputConfiguration::MIRROR_MODE_AUTO);
+            const std::unordered_set<int32_t> &sensorPixelModesUsed,
+            int setId = CAMERA3_STREAM_SET_ID_INVALID, bool isMultiResolution = false);
     /**
      * Set up a stream for formats that have a variable buffer size for the same
      * dimensions, such as compressed JPEG.
@@ -107,13 +100,8 @@ class Camera3OutputStream :
             uint32_t width, uint32_t height, size_t maxSize, int format,
             android_dataspace dataSpace, camera_stream_rotation_t rotation,
             nsecs_t timestampOffset, const String8& physicalCameraId,
-            const std::unordered_set<int32_t> &sensorPixelModesUsed, IPCTransport transport,
-            int setId = CAMERA3_STREAM_SET_ID_INVALID, bool isMultiResolution = false,
-            int64_t dynamicProfile = ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD,
-            int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT,
-            bool deviceTimeBaseIsRealtime = false,
-            int timestampBase = OutputConfiguration::TIMESTAMP_BASE_DEFAULT,
-            int mirrorMode = OutputConfiguration::MIRROR_MODE_AUTO);
+            const std::unordered_set<int32_t> &sensorPixelModesUsed,
+            int setId = CAMERA3_STREAM_SET_ID_INVALID, bool isMultiResolution = false);
     /**
      * Set up a stream with deferred consumer for formats that have 2 dimensions, such as
      * RAW and YUV. The consumer must be set before using this stream for output. A valid
@@ -123,13 +111,8 @@ class Camera3OutputStream :
             uint64_t consumerUsage, android_dataspace dataSpace,
             camera_stream_rotation_t rotation, nsecs_t timestampOffset,
             const String8& physicalCameraId,
-            const std::unordered_set<int32_t> &sensorPixelModesUsed, IPCTransport transport,
-            int setId = CAMERA3_STREAM_SET_ID_INVALID, bool isMultiResolution = false,
-            int64_t dynamicProfile = ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD,
-            int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT,
-            bool deviceTimeBaseIsRealtime = false,
-            int timestampBase = OutputConfiguration::TIMESTAMP_BASE_DEFAULT,
-            int mirrorMode = OutputConfiguration::MIRROR_MODE_AUTO);
+            const std::unordered_set<int32_t> &sensorPixelModesUsed,
+            int setId = CAMERA3_STREAM_SET_ID_INVALID, bool isMultiResolution = false);
 
     virtual ~Camera3OutputStream();
 
@@ -143,7 +126,7 @@ class Camera3OutputStream :
      * Set the transform on the output stream; one of the
      * HAL_TRANSFORM_* / NATIVE_WINDOW_TRANSFORM_* constants.
      */
-    status_t         setTransform(int transform, bool mayChangeMirror);
+    status_t         setTransform(int transform);
 
     /**
      * Return if this output stream is for video encoding.
@@ -159,11 +142,6 @@ class Camera3OutputStream :
      */
     bool isConsumedByHWTexture() const;
 
-    /**
-     * Return if this output stream is consumed by CPU.
-     */
-    bool isConsumedByCPU() const;
-
     /**
      * Return if the consumer configuration of this stream is deferred.
      */
@@ -246,11 +224,6 @@ class Camera3OutputStream :
      */
     virtual status_t setBatchSize(size_t batchSize = 1) override;
 
-    /**
-     * Notify the stream on change of min frame durations.
-     */
-    virtual void onMinDurationChanged(nsecs_t duration) override;
-
     /**
      * Apply ZSL related consumer usage quirk.
      */
@@ -264,14 +237,9 @@ class Camera3OutputStream :
             uint32_t width, uint32_t height, int format,
             android_dataspace dataSpace, camera_stream_rotation_t rotation,
             const String8& physicalCameraId,
-            const std::unordered_set<int32_t> &sensorPixelModesUsed, IPCTransport transport,
+            const std::unordered_set<int32_t> &sensorPixelModesUsed,
             uint64_t consumerUsage = 0, nsecs_t timestampOffset = 0,
-            int setId = CAMERA3_STREAM_SET_ID_INVALID, bool isMultiResolution = false,
-            int64_t dynamicProfile = ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD,
-            int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT,
-            bool deviceTimeBaseIsRealtime = false,
-            int timestampBase = OutputConfiguration::TIMESTAMP_BASE_DEFAULT,
-            int mirrorMode = OutputConfiguration::MIRROR_MODE_AUTO);
+            int setId = CAMERA3_STREAM_SET_ID_INVALID, bool isMultiResolution = false);
 
     /**
      * Note that we release the lock briefly in this function
@@ -279,7 +247,6 @@ class Camera3OutputStream :
     virtual status_t returnBufferCheckedLocked(
             const camera_stream_buffer &buffer,
             nsecs_t timestamp,
-            nsecs_t readoutTimestamp,
             bool output,
             int32_t transform,
             const std::vector<size_t>& surface_ids,
@@ -287,11 +254,10 @@ class Camera3OutputStream :
             sp<Fence> *releaseFenceOut);
 
     virtual status_t disconnectLocked();
-    status_t fixUpHidlJpegBlobHeader(ANativeWindowBuffer* anwBuffer, int fence);
 
     status_t getEndpointUsageForSurface(uint64_t *usage,
             const sp<Surface>& surface) const;
-    status_t configureConsumerQueueLocked(bool allowPreviewRespace);
+    status_t configureConsumerQueueLocked(bool allowPreviewScheduler);
 
     // Consumer as the output of camera HAL
     sp<Surface> mConsumer;
@@ -314,6 +280,9 @@ class Camera3OutputStream :
     // Name of Surface consumer
     String8           mConsumerName;
 
+    // Whether consumer assumes MONOTONIC timestamp
+    bool mUseMonoTimestamp;
+
     /**
      * GraphicBuffer manager this stream is registered to. Used to replace the buffer
      * allocation/deallocation role of BufferQueue.
@@ -332,11 +301,7 @@ class Camera3OutputStream :
     bool mUseBufferManager;
 
     /**
-     * Offset used to override camera HAL produced timestamps
-     *
-     * The offset is first initialized to bootTime - monotonicTime in
-     * constructor, and may later be updated based on the client's timestampBase
-     * setting.
+     * Timestamp offset for video and hardware composer consumed streams
      */
     nsecs_t mTimestampOffset;
 
@@ -360,8 +325,6 @@ class Camera3OutputStream :
     std::vector<Surface::BatchBuffer> mBatchedBuffers;
     // ---- End of mBatchLock protected scope ----
 
-    const int mMirrorMode;
-
     /**
      * Internal Camera3Stream interface
      */
@@ -372,8 +335,7 @@ class Camera3OutputStream :
 
     virtual status_t returnBufferLocked(
             const camera_stream_buffer &buffer,
-            nsecs_t timestamp, nsecs_t readoutTimestamp,
-            int32_t transform, const std::vector<size_t>& surface_ids);
+            nsecs_t timestamp, int32_t transform, const std::vector<size_t>& surface_ids);
 
     virtual status_t queueBufferToConsumer(sp<ANativeWindow>& consumer,
             ANativeWindowBuffer* buffer, int anwReleaseFence,
@@ -405,32 +367,13 @@ class Camera3OutputStream :
 
     void returnPrefetchedBuffersLocked();
 
-
     static const int32_t kDequeueLatencyBinSize = 5; // in ms
     CameraLatencyHistogram mDequeueBufferLatency;
-    IPCTransport mIPCTransport = IPCTransport::INVALID;
 
     int mImageDumpMask = 0;
 
-    // Re-space frames by overriding timestamp to align with display Vsync.
-    // Default is on for SurfaceView bound streams.
-    nsecs_t mMinExpectedDuration = 0;
-    bool mSyncToDisplay = false;
-    DisplayEventReceiver mDisplayEventReceiver;
-    nsecs_t mLastCaptureTime = 0;
-    nsecs_t mLastPresentTime = 0;
-    nsecs_t mCaptureToPresentOffset = 0;
-    static constexpr size_t kDisplaySyncExtraBuffer = 2;
-    static constexpr nsecs_t kSpacingResetIntervalNs = 50000000LL; // 50 millisecond
-    static constexpr nsecs_t kTimelineThresholdNs = 1000000LL; // 1 millisecond
-    static constexpr float kMaxIntervalRatioDeviation = 0.05f;
-    static constexpr int kMaxTimelines = 3;
-    nsecs_t syncTimestampToDisplayLocked(nsecs_t t);
-
-    // Re-space frames by delaying queueBuffer so that frame delivery has
-    // the same cadence as capture. Default is on for SurfaceTexture bound
-    // streams.
-    sp<PreviewFrameSpacer> mPreviewFrameSpacer;
+    // The preview stream scheduler for re-timing frames
+    std::unique_ptr<PreviewFrameScheduler> mPreviewFrameScheduler;
 }; // class Camera3OutputStream
 
 } // namespace camera3
diff --git a/services/camera/libcameraservice/device3/Camera3OutputStreamInterface.h b/services/camera/libcameraservice/device3/Camera3OutputStreamInterface.h
index a6d4b96c7f..49f9f62b6d 100644
--- a/services/camera/libcameraservice/device3/Camera3OutputStreamInterface.h
+++ b/services/camera/libcameraservice/device3/Camera3OutputStreamInterface.h
@@ -34,7 +34,7 @@ class Camera3OutputStreamInterface : public virtual Camera3StreamInterface {
      * Set the transform on the output stream; one of the
      * HAL_TRANSFORM_* / NATIVE_WINDOW_TRANSFORM_* constants.
      */
-    virtual status_t setTransform(int transform, bool mayChangeMirror) = 0;
+    virtual status_t setTransform(int transform) = 0;
 
     /**
      * Return if this output stream is for video encoding.
@@ -108,14 +108,6 @@ class Camera3OutputStreamInterface : public virtual Camera3StreamInterface {
      * instead.
      */
     virtual status_t setBatchSize(size_t batchSize = 1) = 0;
-
-    /**
-     * Notify the output stream that the minimum frame duration has changed.
-     *
-     * The minimum frame duration is calculated based on the upper bound of
-     * AE_TARGET_FPS_RANGE in the capture request.
-     */
-    virtual void onMinDurationChanged(nsecs_t duration) = 0;
 };
 
 // Helper class to organize a synchronized mapping of stream IDs to stream instances
diff --git a/services/camera/libcameraservice/device3/Camera3OutputUtils.cpp b/services/camera/libcameraservice/device3/Camera3OutputUtils.cpp
index ed66df0eb1..d765b024d5 100644
--- a/services/camera/libcameraservice/device3/Camera3OutputUtils.cpp
+++ b/services/camera/libcameraservice/device3/Camera3OutputUtils.cpp
@@ -376,6 +376,43 @@ void sendCaptureResult(
     insertResultLocked(states, &captureResult, frameNumber);
 }
 
+// Reading one camera metadata from result argument via fmq or from the result
+// Assuming the fmq is protected by a lock already
+status_t readOneCameraMetadataLocked(
+        std::unique_ptr<ResultMetadataQueue>& fmq,
+        uint64_t fmqResultSize,
+        hardware::camera::device::V3_2::CameraMetadata& resultMetadata,
+        const hardware::camera::device::V3_2::CameraMetadata& result) {
+    if (fmqResultSize > 0) {
+        resultMetadata.resize(fmqResultSize);
+        if (fmq == nullptr) {
+            return NO_MEMORY; // logged in initialize()
+        }
+        if (!fmq->read(resultMetadata.data(), fmqResultSize)) {
+            ALOGE("%s: Cannot read camera metadata from fmq, size = %" PRIu64,
+                    __FUNCTION__, fmqResultSize);
+            return INVALID_OPERATION;
+        }
+    } else {
+        resultMetadata.setToExternal(const_cast<uint8_t *>(result.data()),
+                result.size());
+    }
+
+    if (resultMetadata.size() != 0) {
+        status_t res;
+        const camera_metadata_t* metadata =
+                reinterpret_cast<const camera_metadata_t*>(resultMetadata.data());
+        size_t expected_metadata_size = resultMetadata.size();
+        if ((res = validate_camera_metadata_structure(metadata, &expected_metadata_size)) != OK) {
+            ALOGE("%s: Invalid camera metadata received by camera service from HAL: %s (%d)",
+                    __FUNCTION__, strerror(-res), res);
+            return INVALID_OPERATION;
+        }
+    }
+
+    return OK;
+}
+
 void removeInFlightMapEntryLocked(CaptureOutputStates& states, int idx) {
     ATRACE_CALL();
     InFlightRequestMap& inflightMap = states.inflightMap;
@@ -426,7 +463,7 @@ void removeInFlightRequestIfReadyLocked(CaptureOutputStates& states, int idx) {
         returnOutputBuffers(
             states.useHalBufManager, states.listener,
             request.pendingOutputBuffers.array(),
-            request.pendingOutputBuffers.size(), /*timestamp*/0, /*readoutTimestamp*/0,
+            request.pendingOutputBuffers.size(), 0,
             /*requested*/true, request.requestTimeNs, states.sessionStatsBuilder,
             /*timestampIncreasing*/true,
             request.outputSurfaces, request.resultExtras,
@@ -435,7 +472,7 @@ void removeInFlightRequestIfReadyLocked(CaptureOutputStates& states, int idx) {
         // Note down the just completed frame number
         if (request.hasInputBuffer) {
             states.lastCompletedReprocessFrameNumber = frameNumber;
-        } else if (request.zslCapture && request.stillCapture) {
+        } else if (request.zslCapture) {
             states.lastCompletedZslFrameNumber = frameNumber;
         } else {
             states.lastCompletedRegularFrameNumber = frameNumber;
@@ -532,7 +569,7 @@ void processCaptureResult(CaptureOutputStates& states, const camera_capture_resu
                     auto orientation = deviceInfo->second.find(ANDROID_SENSOR_ORIENTATION);
                     if (orientation.count > 0) {
                         ret = CameraUtils::getRotationTransform(deviceInfo->second,
-                                OutputConfiguration::MIRROR_MODE_AUTO, &request.transform);
+                                &request.transform);
                         if (ret != OK) {
                             ALOGE("%s: Failed to calculate current stream transformation: %s (%d)",
                                     __FUNCTION__, strerror(-ret), ret);
@@ -682,13 +719,160 @@ void processCaptureResult(CaptureOutputStates& states, const camera_capture_resu
     }
 }
 
+void processOneCaptureResultLocked(
+        CaptureOutputStates& states,
+        const hardware::camera::device::V3_2::CaptureResult& result,
+        const hardware::hidl_vec<
+                hardware::camera::device::V3_4::PhysicalCameraMetadata> physicalCameraMetadata) {
+    using hardware::camera::device::V3_2::StreamBuffer;
+    using hardware::camera::device::V3_2::BufferStatus;
+    std::unique_ptr<ResultMetadataQueue>& fmq = states.fmq;
+    BufferRecordsInterface& bufferRecords = states.bufferRecordsIntf;
+    camera_capture_result r;
+    status_t res;
+    r.frame_number = result.frameNumber;
+
+    // Read and validate the result metadata.
+    hardware::camera::device::V3_2::CameraMetadata resultMetadata;
+    res = readOneCameraMetadataLocked(
+            fmq, result.fmqResultSize,
+            resultMetadata, result.result);
+    if (res != OK) {
+        ALOGE("%s: Frame %d: Failed to read capture result metadata",
+                __FUNCTION__, result.frameNumber);
+        return;
+    }
+    r.result = reinterpret_cast<const camera_metadata_t*>(resultMetadata.data());
+
+    // Read and validate physical camera metadata
+    size_t physResultCount = physicalCameraMetadata.size();
+    std::vector<const char*> physCamIds(physResultCount);
+    std::vector<const camera_metadata_t *> phyCamMetadatas(physResultCount);
+    std::vector<hardware::camera::device::V3_2::CameraMetadata> physResultMetadata;
+    physResultMetadata.resize(physResultCount);
+    for (size_t i = 0; i < physicalCameraMetadata.size(); i++) {
+        res = readOneCameraMetadataLocked(fmq, physicalCameraMetadata[i].fmqMetadataSize,
+                physResultMetadata[i], physicalCameraMetadata[i].metadata);
+        if (res != OK) {
+            ALOGE("%s: Frame %d: Failed to read capture result metadata for camera %s",
+                    __FUNCTION__, result.frameNumber,
+                    physicalCameraMetadata[i].physicalCameraId.c_str());
+            return;
+        }
+        physCamIds[i] = physicalCameraMetadata[i].physicalCameraId.c_str();
+        phyCamMetadatas[i] = reinterpret_cast<const camera_metadata_t*>(
+                physResultMetadata[i].data());
+    }
+    r.num_physcam_metadata = physResultCount;
+    r.physcam_ids = physCamIds.data();
+    r.physcam_metadata = phyCamMetadatas.data();
+
+    std::vector<camera_stream_buffer_t> outputBuffers(result.outputBuffers.size());
+    std::vector<buffer_handle_t> outputBufferHandles(result.outputBuffers.size());
+    for (size_t i = 0; i < result.outputBuffers.size(); i++) {
+        auto& bDst = outputBuffers[i];
+        const StreamBuffer &bSrc = result.outputBuffers[i];
+
+        sp<Camera3StreamInterface> stream = states.outputStreams.get(bSrc.streamId);
+        if (stream == nullptr) {
+            ALOGE("%s: Frame %d: Buffer %zu: Invalid output stream id %d",
+                    __FUNCTION__, result.frameNumber, i, bSrc.streamId);
+            return;
+        }
+        bDst.stream = stream->asHalStream();
+
+        bool noBufferReturned = false;
+        buffer_handle_t *buffer = nullptr;
+        if (states.useHalBufManager) {
+            // This is suspicious most of the time but can be correct during flush where HAL
+            // has to return capture result before a buffer is requested
+            if (bSrc.bufferId == BUFFER_ID_NO_BUFFER) {
+                if (bSrc.status == BufferStatus::OK) {
+                    ALOGE("%s: Frame %d: Buffer %zu: No bufferId for stream %d",
+                            __FUNCTION__, result.frameNumber, i, bSrc.streamId);
+                    // Still proceeds so other buffers can be returned
+                }
+                noBufferReturned = true;
+            }
+            if (noBufferReturned) {
+                res = OK;
+            } else {
+                res = bufferRecords.popInflightRequestBuffer(bSrc.bufferId, &buffer);
+            }
+        } else {
+            res = bufferRecords.popInflightBuffer(result.frameNumber, bSrc.streamId, &buffer);
+        }
+
+        if (res != OK) {
+            ALOGE("%s: Frame %d: Buffer %zu: No in-flight buffer for stream %d",
+                    __FUNCTION__, result.frameNumber, i, bSrc.streamId);
+            return;
+        }
+
+        bDst.buffer = buffer;
+        bDst.status = mapHidlBufferStatus(bSrc.status);
+        bDst.acquire_fence = -1;
+        if (bSrc.releaseFence == nullptr) {
+            bDst.release_fence = -1;
+        } else if (bSrc.releaseFence->numFds == 1) {
+            if (noBufferReturned) {
+                ALOGE("%s: got releaseFence without output buffer!", __FUNCTION__);
+            }
+            bDst.release_fence = dup(bSrc.releaseFence->data[0]);
+        } else {
+            ALOGE("%s: Frame %d: Invalid release fence for buffer %zu, fd count is %d, not 1",
+                    __FUNCTION__, result.frameNumber, i, bSrc.releaseFence->numFds);
+            return;
+        }
+    }
+    r.num_output_buffers = outputBuffers.size();
+    r.output_buffers = outputBuffers.data();
+
+    camera_stream_buffer_t inputBuffer;
+    if (result.inputBuffer.streamId == -1) {
+        r.input_buffer = nullptr;
+    } else {
+        if (states.inputStream->getId() != result.inputBuffer.streamId) {
+            ALOGE("%s: Frame %d: Invalid input stream id %d", __FUNCTION__,
+                    result.frameNumber, result.inputBuffer.streamId);
+            return;
+        }
+        inputBuffer.stream = states.inputStream->asHalStream();
+        buffer_handle_t *buffer;
+        res = bufferRecords.popInflightBuffer(result.frameNumber, result.inputBuffer.streamId,
+                &buffer);
+        if (res != OK) {
+            ALOGE("%s: Frame %d: Input buffer: No in-flight buffer for stream %d",
+                    __FUNCTION__, result.frameNumber, result.inputBuffer.streamId);
+            return;
+        }
+        inputBuffer.buffer = buffer;
+        inputBuffer.status = mapHidlBufferStatus(result.inputBuffer.status);
+        inputBuffer.acquire_fence = -1;
+        if (result.inputBuffer.releaseFence == nullptr) {
+            inputBuffer.release_fence = -1;
+        } else if (result.inputBuffer.releaseFence->numFds == 1) {
+            inputBuffer.release_fence = dup(result.inputBuffer.releaseFence->data[0]);
+        } else {
+            ALOGE("%s: Frame %d: Invalid release fence for input buffer, fd count is %d, not 1",
+                    __FUNCTION__, result.frameNumber, result.inputBuffer.releaseFence->numFds);
+            return;
+        }
+        r.input_buffer = &inputBuffer;
+    }
+
+    r.partial_result = result.partialResult;
+
+    processCaptureResult(states, &r);
+}
+
 void returnOutputBuffers(
         bool useHalBufManager,
         sp<NotificationListener> listener,
         const camera_stream_buffer_t *outputBuffers, size_t numBuffers,
-        nsecs_t timestamp, nsecs_t readoutTimestamp, bool requested,
-        nsecs_t requestTimeNs, SessionStatsBuilder& sessionStatsBuilder,
-        bool timestampIncreasing, const SurfaceMap& outputSurfaces,
+        nsecs_t timestamp, bool requested, nsecs_t requestTimeNs,
+        SessionStatsBuilder& sessionStatsBuilder, bool timestampIncreasing,
+        const SurfaceMap& outputSurfaces,
         const CaptureResultExtras &inResultExtras,
         ERROR_BUF_STRATEGY errorBufStrategy, int32_t transform) {
 
@@ -732,11 +916,11 @@ void returnOutputBuffers(
                 errorBufStrategy != ERROR_BUF_CACHE) {
             if (it != outputSurfaces.end()) {
                 res = stream->returnBuffer(
-                        outputBuffers[i], timestamp, readoutTimestamp, timestampIncreasing,
-                        it->second, inResultExtras.frameNumber, transform);
+                        outputBuffers[i], timestamp, timestampIncreasing, it->second,
+                        inResultExtras.frameNumber, transform);
             } else {
                 res = stream->returnBuffer(
-                        outputBuffers[i], timestamp, readoutTimestamp, timestampIncreasing,
+                        outputBuffers[i], timestamp, timestampIncreasing,
                         std::vector<size_t> (), inResultExtras.frameNumber, transform);
             }
         }
@@ -767,7 +951,7 @@ void returnOutputBuffers(
             // cancel the buffer
             camera_stream_buffer_t sb = outputBuffers[i];
             sb.status = CAMERA_BUFFER_STATUS_ERROR;
-            stream->returnBuffer(sb, /*timestamp*/0, /*readoutTimestamp*/0,
+            stream->returnBuffer(sb, /*timestamp*/0,
                     timestampIncreasing, std::vector<size_t> (),
                     inResultExtras.frameNumber, transform);
 
@@ -785,13 +969,12 @@ void returnOutputBuffers(
 void returnAndRemovePendingOutputBuffers(bool useHalBufManager,
         sp<NotificationListener> listener, InFlightRequest& request,
         SessionStatsBuilder& sessionStatsBuilder) {
-    bool timestampIncreasing =
-            !((request.zslCapture && request.stillCapture) || request.hasInputBuffer);
+    bool timestampIncreasing = !(request.zslCapture || request.hasInputBuffer);
     returnOutputBuffers(useHalBufManager, listener,
             request.pendingOutputBuffers.array(),
             request.pendingOutputBuffers.size(),
-            request.shutterTimestamp, request.shutterReadoutTimestamp,
-            /*requested*/true, request.requestTimeNs, sessionStatsBuilder, timestampIncreasing,
+            request.shutterTimestamp, /*requested*/true,
+            request.requestTimeNs, sessionStatsBuilder, timestampIncreasing,
             request.outputSurfaces, request.resultExtras,
             request.errorBufStrategy, request.transform);
 
@@ -852,14 +1035,6 @@ void notifyShutter(CaptureOutputStates& states, const camera_shutter_msg_t &msg)
             }
 
             r.shutterTimestamp = msg.timestamp;
-            r.shutterReadoutTimestamp = msg.readout_timestamp;
-            if (r.minExpectedDuration != states.minFrameDuration) {
-                for (size_t i = 0; i < states.outputStreams.size(); i++) {
-                    auto outputStream = states.outputStreams[i];
-                    outputStream->onMinDurationChanged(r.minExpectedDuration);
-                }
-                states.minFrameDuration = r.minExpectedDuration;
-            }
             if (r.hasCallback) {
                 ALOGVV("Camera %s: %s: Shutter fired for frame %d (id %d) at %" PRId64,
                     states.cameraId.string(), __FUNCTION__,
@@ -1017,6 +1192,296 @@ void notify(CaptureOutputStates& states, const camera_notify_msg *msg) {
     }
 }
 
+void notify(CaptureOutputStates& states,
+        const hardware::camera::device::V3_2::NotifyMsg& msg) {
+    using android::hardware::camera::device::V3_2::MsgType;
+    using android::hardware::camera::device::V3_2::ErrorCode;
+
+    ATRACE_CALL();
+    camera_notify_msg m;
+    switch (msg.type) {
+        case MsgType::ERROR:
+            m.type = CAMERA_MSG_ERROR;
+            m.message.error.frame_number = msg.msg.error.frameNumber;
+            if (msg.msg.error.errorStreamId >= 0) {
+                sp<Camera3StreamInterface> stream =
+                        states.outputStreams.get(msg.msg.error.errorStreamId);
+                if (stream == nullptr) {
+                    ALOGE("%s: Frame %d: Invalid error stream id %d", __FUNCTION__,
+                            m.message.error.frame_number, msg.msg.error.errorStreamId);
+                    return;
+                }
+                m.message.error.error_stream = stream->asHalStream();
+            } else {
+                m.message.error.error_stream = nullptr;
+            }
+            switch (msg.msg.error.errorCode) {
+                case ErrorCode::ERROR_DEVICE:
+                    m.message.error.error_code = CAMERA_MSG_ERROR_DEVICE;
+                    break;
+                case ErrorCode::ERROR_REQUEST:
+                    m.message.error.error_code = CAMERA_MSG_ERROR_REQUEST;
+                    break;
+                case ErrorCode::ERROR_RESULT:
+                    m.message.error.error_code = CAMERA_MSG_ERROR_RESULT;
+                    break;
+                case ErrorCode::ERROR_BUFFER:
+                    m.message.error.error_code = CAMERA_MSG_ERROR_BUFFER;
+                    break;
+            }
+            break;
+        case MsgType::SHUTTER:
+            m.type = CAMERA_MSG_SHUTTER;
+            m.message.shutter.frame_number = msg.msg.shutter.frameNumber;
+            m.message.shutter.timestamp = msg.msg.shutter.timestamp;
+            break;
+    }
+    notify(states, &m);
+}
+
+void requestStreamBuffers(RequestBufferStates& states,
+        const hardware::hidl_vec<hardware::camera::device::V3_5::BufferRequest>& bufReqs,
+        hardware::camera::device::V3_5::ICameraDeviceCallback::requestStreamBuffers_cb _hidl_cb) {
+    using android::hardware::camera::device::V3_2::BufferStatus;
+    using android::hardware::camera::device::V3_2::StreamBuffer;
+    using android::hardware::camera::device::V3_5::BufferRequestStatus;
+    using android::hardware::camera::device::V3_5::StreamBufferRet;
+    using android::hardware::camera::device::V3_5::StreamBufferRequestError;
+
+    std::lock_guard<std::mutex> lock(states.reqBufferLock);
+
+    hardware::hidl_vec<StreamBufferRet> bufRets;
+    if (!states.useHalBufManager) {
+        ALOGE("%s: Camera %s does not support HAL buffer management",
+                __FUNCTION__, states.cameraId.string());
+        _hidl_cb(BufferRequestStatus::FAILED_ILLEGAL_ARGUMENTS, bufRets);
+        return;
+    }
+
+    SortedVector<int32_t> streamIds;
+    ssize_t sz = streamIds.setCapacity(bufReqs.size());
+    if (sz < 0 || static_cast<size_t>(sz) != bufReqs.size()) {
+        ALOGE("%s: failed to allocate memory for %zu buffer requests",
+                __FUNCTION__, bufReqs.size());
+        _hidl_cb(BufferRequestStatus::FAILED_ILLEGAL_ARGUMENTS, bufRets);
+        return;
+    }
+
+    if (bufReqs.size() > states.outputStreams.size()) {
+        ALOGE("%s: too many buffer requests (%zu > # of output streams %zu)",
+                __FUNCTION__, bufReqs.size(), states.outputStreams.size());
+        _hidl_cb(BufferRequestStatus::FAILED_ILLEGAL_ARGUMENTS, bufRets);
+        return;
+    }
+
+    // Check for repeated streamId
+    for (const auto& bufReq : bufReqs) {
+        if (streamIds.indexOf(bufReq.streamId) != NAME_NOT_FOUND) {
+            ALOGE("%s: Stream %d appear multiple times in buffer requests",
+                    __FUNCTION__, bufReq.streamId);
+            _hidl_cb(BufferRequestStatus::FAILED_ILLEGAL_ARGUMENTS, bufRets);
+            return;
+        }
+        streamIds.add(bufReq.streamId);
+    }
+
+    if (!states.reqBufferIntf.startRequestBuffer()) {
+        ALOGE("%s: request buffer disallowed while camera service is configuring",
+                __FUNCTION__);
+        _hidl_cb(BufferRequestStatus::FAILED_CONFIGURING, bufRets);
+        return;
+    }
+
+    bufRets.resize(bufReqs.size());
+
+    bool allReqsSucceeds = true;
+    bool oneReqSucceeds = false;
+    for (size_t i = 0; i < bufReqs.size(); i++) {
+        const auto& bufReq = bufReqs[i];
+        auto& bufRet = bufRets[i];
+        int32_t streamId = bufReq.streamId;
+        sp<Camera3OutputStreamInterface> outputStream = states.outputStreams.get(streamId);
+        if (outputStream == nullptr) {
+            ALOGE("%s: Output stream id %d not found!", __FUNCTION__, streamId);
+            hardware::hidl_vec<StreamBufferRet> emptyBufRets;
+            _hidl_cb(BufferRequestStatus::FAILED_ILLEGAL_ARGUMENTS, emptyBufRets);
+            states.reqBufferIntf.endRequestBuffer();
+            return;
+        }
+
+        bufRet.streamId = streamId;
+        if (outputStream->isAbandoned()) {
+            bufRet.val.error(StreamBufferRequestError::STREAM_DISCONNECTED);
+            allReqsSucceeds = false;
+            continue;
+        }
+
+        size_t handOutBufferCount = outputStream->getOutstandingBuffersCount();
+        uint32_t numBuffersRequested = bufReq.numBuffersRequested;
+        size_t totalHandout = handOutBufferCount + numBuffersRequested;
+        uint32_t maxBuffers = outputStream->asHalStream()->max_buffers;
+        if (totalHandout > maxBuffers) {
+            // Not able to allocate enough buffer. Exit early for this stream
+            ALOGE("%s: request too much buffers for stream %d: at HAL: %zu + requesting: %d"
+                    " > max: %d", __FUNCTION__, streamId, handOutBufferCount,
+                    numBuffersRequested, maxBuffers);
+            bufRet.val.error(StreamBufferRequestError::MAX_BUFFER_EXCEEDED);
+            allReqsSucceeds = false;
+            continue;
+        }
+
+        hardware::hidl_vec<StreamBuffer> tmpRetBuffers(numBuffersRequested);
+        bool currentReqSucceeds = true;
+        std::vector<camera_stream_buffer_t> streamBuffers(numBuffersRequested);
+        std::vector<buffer_handle_t> newBuffers;
+        size_t numAllocatedBuffers = 0;
+        size_t numPushedInflightBuffers = 0;
+        for (size_t b = 0; b < numBuffersRequested; b++) {
+            camera_stream_buffer_t& sb = streamBuffers[b];
+            // Since this method can run concurrently with request thread
+            // We need to update the wait duration everytime we call getbuffer
+            nsecs_t waitDuration =  states.reqBufferIntf.getWaitDuration();
+            status_t res = outputStream->getBuffer(&sb, waitDuration);
+            if (res != OK) {
+                if (res == NO_INIT || res == DEAD_OBJECT) {
+                    ALOGV("%s: Can't get output buffer for stream %d: %s (%d)",
+                            __FUNCTION__, streamId, strerror(-res), res);
+                    bufRet.val.error(StreamBufferRequestError::STREAM_DISCONNECTED);
+                    states.sessionStatsBuilder.stopCounter(streamId);
+                } else {
+                    ALOGE("%s: Can't get output buffer for stream %d: %s (%d)",
+                            __FUNCTION__, streamId, strerror(-res), res);
+                    if (res == TIMED_OUT || res == NO_MEMORY) {
+                        bufRet.val.error(StreamBufferRequestError::NO_BUFFER_AVAILABLE);
+                    } else {
+                        bufRet.val.error(StreamBufferRequestError::UNKNOWN_ERROR);
+                    }
+                }
+                currentReqSucceeds = false;
+                break;
+            }
+            numAllocatedBuffers++;
+
+            buffer_handle_t *buffer = sb.buffer;
+            auto pair = states.bufferRecordsIntf.getBufferId(*buffer, streamId);
+            bool isNewBuffer = pair.first;
+            uint64_t bufferId = pair.second;
+            StreamBuffer& hBuf = tmpRetBuffers[b];
+
+            hBuf.streamId = streamId;
+            hBuf.bufferId = bufferId;
+            hBuf.buffer = (isNewBuffer) ? *buffer : nullptr;
+            hBuf.status = BufferStatus::OK;
+            hBuf.releaseFence = nullptr;
+            if (isNewBuffer) {
+                newBuffers.push_back(*buffer);
+            }
+
+            native_handle_t *acquireFence = nullptr;
+            if (sb.acquire_fence != -1) {
+                acquireFence = native_handle_create(1,0);
+                acquireFence->data[0] = sb.acquire_fence;
+            }
+            hBuf.acquireFence.setTo(acquireFence, /*shouldOwn*/true);
+            hBuf.releaseFence = nullptr;
+
+            res = states.bufferRecordsIntf.pushInflightRequestBuffer(bufferId, buffer, streamId);
+            if (res != OK) {
+                ALOGE("%s: Can't get register request buffers for stream %d: %s (%d)",
+                        __FUNCTION__, streamId, strerror(-res), res);
+                bufRet.val.error(StreamBufferRequestError::UNKNOWN_ERROR);
+                currentReqSucceeds = false;
+                break;
+            }
+            numPushedInflightBuffers++;
+        }
+        if (currentReqSucceeds) {
+            bufRet.val.buffers(std::move(tmpRetBuffers));
+            oneReqSucceeds = true;
+        } else {
+            allReqsSucceeds = false;
+            for (size_t b = 0; b < numPushedInflightBuffers; b++) {
+                StreamBuffer& hBuf = tmpRetBuffers[b];
+                buffer_handle_t* buffer;
+                status_t res = states.bufferRecordsIntf.popInflightRequestBuffer(
+                        hBuf.bufferId, &buffer);
+                if (res != OK) {
+                    SET_ERR("%s: popInflightRequestBuffer failed for stream %d: %s (%d)",
+                            __FUNCTION__, streamId, strerror(-res), res);
+                }
+            }
+            for (size_t b = 0; b < numAllocatedBuffers; b++) {
+                camera_stream_buffer_t& sb = streamBuffers[b];
+                sb.acquire_fence = -1;
+                sb.status = CAMERA_BUFFER_STATUS_ERROR;
+            }
+            returnOutputBuffers(states.useHalBufManager, /*listener*/nullptr,
+                    streamBuffers.data(), numAllocatedBuffers, 0, /*requested*/false,
+                    /*requestTimeNs*/0, states.sessionStatsBuilder);
+            for (auto buf : newBuffers) {
+                states.bufferRecordsIntf.removeOneBufferCache(streamId, buf);
+            }
+        }
+    }
+
+    _hidl_cb(allReqsSucceeds ? BufferRequestStatus::OK :
+            oneReqSucceeds ? BufferRequestStatus::FAILED_PARTIAL :
+                             BufferRequestStatus::FAILED_UNKNOWN,
+            bufRets);
+    states.reqBufferIntf.endRequestBuffer();
+}
+
+void returnStreamBuffers(ReturnBufferStates& states,
+        const hardware::hidl_vec<hardware::camera::device::V3_2::StreamBuffer>& buffers) {
+    if (!states.useHalBufManager) {
+        ALOGE("%s: Camera %s does not support HAL buffer managerment",
+                __FUNCTION__, states.cameraId.string());
+        return;
+    }
+
+    for (const auto& buf : buffers) {
+        if (buf.bufferId == BUFFER_ID_NO_BUFFER) {
+            ALOGE("%s: cannot return a buffer without bufferId", __FUNCTION__);
+            continue;
+        }
+
+        buffer_handle_t* buffer;
+        status_t res = states.bufferRecordsIntf.popInflightRequestBuffer(buf.bufferId, &buffer);
+
+        if (res != OK) {
+            ALOGE("%s: cannot find in-flight buffer %" PRIu64 " for stream %d",
+                    __FUNCTION__, buf.bufferId, buf.streamId);
+            continue;
+        }
+
+        camera_stream_buffer_t streamBuffer;
+        streamBuffer.buffer = buffer;
+        streamBuffer.status = CAMERA_BUFFER_STATUS_ERROR;
+        streamBuffer.acquire_fence = -1;
+        streamBuffer.release_fence = -1;
+
+        if (buf.releaseFence == nullptr) {
+            streamBuffer.release_fence = -1;
+        } else if (buf.releaseFence->numFds == 1) {
+            streamBuffer.release_fence = dup(buf.releaseFence->data[0]);
+        } else {
+            ALOGE("%s: Invalid release fence, fd count is %d, not 1",
+                    __FUNCTION__, buf.releaseFence->numFds);
+            continue;
+        }
+
+        sp<Camera3StreamInterface> stream = states.outputStreams.get(buf.streamId);
+        if (stream == nullptr) {
+            ALOGE("%s: Output stream id %d not found!", __FUNCTION__, buf.streamId);
+            continue;
+        }
+        streamBuffer.stream = stream->asHalStream();
+        returnOutputBuffers(states.useHalBufManager, /*listener*/nullptr,
+                &streamBuffer, /*size*/1, /*timestamp*/ 0, /*requested*/false,
+                /*requestTimeNs*/0, states.sessionStatsBuilder);
+    }
+}
+
 void flushInflightRequests(FlushInflightReqStates& states) {
     ATRACE_CALL();
     { // First return buffers cached in inFlightMap
@@ -1026,10 +1491,9 @@ void flushInflightRequests(FlushInflightReqStates& states) {
             returnOutputBuffers(
                 states.useHalBufManager, states.listener,
                 request.pendingOutputBuffers.array(),
-                request.pendingOutputBuffers.size(), /*timestamp*/0, /*readoutTimestamp*/0,
-                /*requested*/true, request.requestTimeNs, states.sessionStatsBuilder,
-                /*timestampIncreasing*/true, request.outputSurfaces, request.resultExtras,
-                request.errorBufStrategy);
+                request.pendingOutputBuffers.size(), 0, /*requested*/true,
+                request.requestTimeNs, states.sessionStatsBuilder, /*timestampIncreasing*/true,
+                request.outputSurfaces, request.resultExtras, request.errorBufStrategy);
             ALOGW("%s: Frame %d |  Timestamp: %" PRId64 ", metadata"
                     " arrived: %s, buffers left: %d.\n", __FUNCTION__,
                     states.inflightMap.keyAt(idx), request.shutterTimestamp,
@@ -1101,7 +1565,7 @@ void flushInflightRequests(FlushInflightReqStates& states) {
                 switch (halStream->stream_type) {
                     case CAMERA_STREAM_OUTPUT:
                         res = stream->returnBuffer(streamBuffer, /*timestamp*/ 0,
-                                /*readoutTimestamp*/0, /*timestampIncreasing*/true,
+                                /*timestampIncreasing*/true,
                                 std::vector<size_t> (), frameNumber);
                         if (res != OK) {
                             ALOGE("%s: Can't return output buffer for frame %d to"
diff --git a/services/camera/libcameraservice/device3/Camera3OutputUtils.h b/services/camera/libcameraservice/device3/Camera3OutputUtils.h
index d6107c28e4..98fbab566c 100644
--- a/services/camera/libcameraservice/device3/Camera3OutputUtils.h
+++ b/services/camera/libcameraservice/device3/Camera3OutputUtils.h
@@ -38,6 +38,8 @@
 
 namespace android {
 
+using ResultMetadataQueue = hardware::MessageQueue<uint8_t, hardware::kSynchronizedReadWrite>;
+
 namespace camera3 {
 
     /**
@@ -50,8 +52,7 @@ namespace camera3 {
             bool useHalBufManager,
             sp<NotificationListener> listener, // Only needed when outputSurfaces is not empty
             const camera_stream_buffer_t *outputBuffers,
-            size_t numBuffers, nsecs_t timestamp,
-            nsecs_t readoutTimestamp, bool requested, nsecs_t requestTimeNs,
+            size_t numBuffers, nsecs_t timestamp, bool requested, nsecs_t requestTimeNs,
             SessionStatsBuilder& sessionStatsBuilder, bool timestampIncreasing = true,
             // The following arguments are only meant for surface sharing use case
             const SurfaceMap& outputSurfaces = SurfaceMap{},
@@ -93,6 +94,7 @@ namespace camera3 {
         const metadata_vendor_id_t vendorTagId;
         const CameraMetadata& deviceInfo;
         const std::unordered_map<std::string, CameraMetadata>& physicalDeviceInfoMap;
+        std::unique_ptr<ResultMetadataQueue>& fmq;
         std::unordered_map<std::string, camera3::DistortionMapper>& distortionMappers;
         std::unordered_map<std::string, camera3::ZoomRatioMapper>& zoomRatioMappers;
         std::unordered_map<std::string, camera3::RotateAndCropMapper>& rotateAndCropMappers;
@@ -105,11 +107,19 @@ namespace camera3 {
         InflightRequestUpdateInterface& inflightIntf;
         BufferRecordsInterface& bufferRecordsIntf;
         bool legacyClient;
-        nsecs_t& minFrameDuration;
     };
 
-    void processCaptureResult(CaptureOutputStates& states, const camera_capture_result *result);
-    void notify(CaptureOutputStates& states, const camera_notify_msg *msg);
+    // Handle one capture result. Assume callers hold the lock to serialize all
+    // processCaptureResult calls
+    void processOneCaptureResultLocked(
+            CaptureOutputStates& states,
+            const hardware::camera::device::V3_2::CaptureResult& result,
+            const hardware::hidl_vec<
+                    hardware::camera::device::V3_4::PhysicalCameraMetadata> physicalCameraMetadata);
+
+    // Handle one notify message
+    void notify(CaptureOutputStates& states,
+            const hardware::camera::device::V3_2::NotifyMsg& msg);
 
     struct RequestBufferStates {
         const String8& cameraId;
@@ -122,6 +132,10 @@ namespace camera3 {
         RequestBufferInterface& reqBufferIntf;
     };
 
+    void requestStreamBuffers(RequestBufferStates& states,
+            const hardware::hidl_vec<hardware::camera::device::V3_5::BufferRequest>& bufReqs,
+            hardware::camera::device::V3_5::ICameraDeviceCallback::requestStreamBuffers_cb _hidl_cb);
+
     struct ReturnBufferStates {
         const String8& cameraId;
         const bool useHalBufManager;
@@ -130,6 +144,9 @@ namespace camera3 {
         BufferRecordsInterface& bufferRecordsIntf;
     };
 
+    void returnStreamBuffers(ReturnBufferStates& states,
+            const hardware::hidl_vec<hardware::camera::device::V3_2::StreamBuffer>& buffers);
+
     struct FlushInflightReqStates {
         const String8& cameraId;
         std::mutex& inflightLock;
diff --git a/services/camera/libcameraservice/device3/Camera3OutputUtilsTemplated.h b/services/camera/libcameraservice/device3/Camera3OutputUtilsTemplated.h
deleted file mode 100644
index 2e05dda45c..0000000000
--- a/services/camera/libcameraservice/device3/Camera3OutputUtilsTemplated.h
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SERVERS_CAMERA3_OUTPUT_TEMPLUTILS_H
-#define ANDROID_SERVERS_CAMERA3_OUTPUT_TEMPLUTILS_H
-
-#include <inttypes.h>
-
-#include <utils/Log.h>
-#include <utils/SortedVector.h>
-#include <utils/Trace.h>
-
-#include <aidl/android/hardware/common/NativeHandle.h>
-#include <android/hardware/camera2/ICameraDeviceCallbacks.h>
-
-#include <android/hardware/camera/device/3.4/ICameraDeviceCallback.h>
-#include <android/hardware/camera/device/3.5/ICameraDeviceCallback.h>
-#include <android/hardware/camera/device/3.5/ICameraDeviceSession.h>
-
-#include <camera/CameraUtils.h>
-#include <camera_metadata_hidden.h>
-
-#include "device3/Camera3OutputUtils.h"
-
-#include "system/camera_metadata.h"
-
-using namespace android::camera3;
-using namespace android::hardware::camera;
-
-namespace android {
-namespace camera3 {
-
-template <class BufferStatusType>
-camera_buffer_status_t mapBufferStatus(BufferStatusType status) {
-    switch (status) {
-        case BufferStatusType::OK: return CAMERA_BUFFER_STATUS_OK;
-        case BufferStatusType::ERROR: return CAMERA_BUFFER_STATUS_ERROR;
-    }
-    return CAMERA_BUFFER_STATUS_ERROR;
-}
-
-inline void readBufferFromVec(hardware::hidl_vec<uint8_t> &dst,
-        const hardware::hidl_vec<uint8_t> &src) {
-    // Not cloning here since that will be done in processCaptureResult whil
-    // assigning to CameraMetadata.
-    dst.setToExternal(const_cast<uint8_t *>(src.data()), src.size());
-}
-
-inline void readBufferFromVec(std::vector<uint8_t> &dst, const std::vector<uint8_t> &src) {
-    dst = src;
-}
-
-// Reading one camera metadata from result argument via fmq or from the result
-// Assuming the fmq is protected by a lock already
-template <class FmqType, class FmqPayloadType, class MetadataType>
-status_t readOneCameraMetadataLockedT(
-        std::unique_ptr<FmqType>& fmq,
-        uint64_t fmqResultSize,
-        MetadataType& resultMetadata,
-        const MetadataType& result) {
-    if (fmqResultSize > 0) {
-        resultMetadata.resize(fmqResultSize);
-        if (fmq == nullptr) {
-            return NO_MEMORY; // logged in initialize()
-        }
-        if (!fmq->read(reinterpret_cast<FmqPayloadType *>(resultMetadata.data()), fmqResultSize)) {
-            ALOGE("%s: Cannot read camera metadata from fmq, size = %" PRIu64,
-                    __FUNCTION__, fmqResultSize);
-            return INVALID_OPERATION;
-        }
-    } else {
-        readBufferFromVec(resultMetadata, result);
-    }
-
-    if (resultMetadata.size() != 0) {
-        status_t res;
-        const camera_metadata_t* metadata =
-                reinterpret_cast<const camera_metadata_t*>(resultMetadata.data());
-        size_t expected_metadata_size = resultMetadata.size();
-        if ((res = validate_camera_metadata_structure(metadata, &expected_metadata_size)) != OK) {
-            ALOGE("%s: Invalid camera metadata received by camera service from HAL: %s (%d)",
-                    __FUNCTION__, strerror(-res), res);
-            return INVALID_OPERATION;
-        }
-    }
-
-    return OK;
-}
-
-inline bool isHandleNull(const hardware::hidl_handle &handle) {
-    return handle == nullptr;
-}
-
-inline bool isHandleNull(const aidl::android::hardware::common::NativeHandle &handle) {
-    return (handle.fds.size() == 0) && (handle.ints.size() == 0);
-}
-
-inline size_t numFdsInHandle(const hardware::hidl_handle &handle) {
-    return handle->numFds;
-}
-
-inline size_t numFdsInHandle(const aidl::android::hardware::common::NativeHandle &handle) {
-    return handle.fds.size();
-}
-
-inline int32_t getHandleFirstFd(const hardware::hidl_handle &handle) {
-    if (handle->numFds != 1) {
-        return -1;
-    }
-    return handle->data[0];
-}
-
-inline int32_t getHandleFirstFd(const aidl::android::hardware::common::NativeHandle &handle) {
-    if (handle.fds.size() != 1) {
-        return -1;
-    }
-    return handle.fds[0].get();
-}
-
-inline const hardware::hidl_vec<uint8_t>&
-getResultMetadata(const android::hardware::camera::device::V3_2::CameraMetadata &result) {
-    return result;
-}
-
-inline const std::vector<uint8_t>&
-getResultMetadata(const aidl::android::hardware::camera::device::CameraMetadata &result) {
-    return result.metadata;
-}
-
-// Fmqpayload type is needed since AIDL generates an fmq of payload type int8_t
-// for a byte fmq vs MetadataType which is uint8_t. For HIDL, the same type is
-// generated for metadata and fmq payload : uint8_t.
-template <class StatesType, class CaptureResultType, class PhysMetadataType, class MetadataType,
-         class FmqType, class BufferStatusType, class FmqPayloadType = uint8_t>
-void processOneCaptureResultLockedT(
-        StatesType& states,
-        const CaptureResultType& result,
-        const PhysMetadataType &physicalCameraMetadata) {
-    std::unique_ptr<FmqType>& fmq = states.fmq;
-    BufferRecordsInterface& bufferRecords = states.bufferRecordsIntf;
-    camera_capture_result r;
-    status_t res;
-    r.frame_number = result.frameNumber;
-
-    // Read and validate the result metadata.
-    MetadataType resultMetadata;
-    res = readOneCameraMetadataLockedT<FmqType, FmqPayloadType, MetadataType>(
-            fmq, result.fmqResultSize,
-            resultMetadata, getResultMetadata(result.result));
-    if (res != OK) {
-        ALOGE("%s: Frame %d: Failed to read capture result metadata",
-                __FUNCTION__, result.frameNumber);
-        return;
-    }
-    r.result = reinterpret_cast<const camera_metadata_t*>(resultMetadata.data());
-
-    // Read and validate physical camera metadata
-    size_t physResultCount = physicalCameraMetadata.size();
-    std::vector<const char*> physCamIds(physResultCount);
-    std::vector<const camera_metadata_t *> phyCamMetadatas(physResultCount);
-    std::vector<MetadataType> physResultMetadata;
-    physResultMetadata.resize(physResultCount);
-    for (size_t i = 0; i < physicalCameraMetadata.size(); i++) {
-        res = readOneCameraMetadataLockedT<FmqType, FmqPayloadType, MetadataType>(fmq,
-                physicalCameraMetadata[i].fmqMetadataSize,
-                physResultMetadata[i], getResultMetadata(physicalCameraMetadata[i].metadata));
-        if (res != OK) {
-            ALOGE("%s: Frame %d: Failed to read capture result metadata for camera %s",
-                    __FUNCTION__, result.frameNumber,
-                    physicalCameraMetadata[i].physicalCameraId.c_str());
-            return;
-        }
-        physCamIds[i] = physicalCameraMetadata[i].physicalCameraId.c_str();
-        phyCamMetadatas[i] =
-                reinterpret_cast<const camera_metadata_t*>(physResultMetadata[i].data());
-    }
-    r.num_physcam_metadata = physResultCount;
-    r.physcam_ids = physCamIds.data();
-    r.physcam_metadata = phyCamMetadatas.data();
-
-    std::vector<camera_stream_buffer_t> outputBuffers(result.outputBuffers.size());
-    std::vector<buffer_handle_t> outputBufferHandles(result.outputBuffers.size());
-    for (size_t i = 0; i < result.outputBuffers.size(); i++) {
-        auto& bDst = outputBuffers[i];
-        const auto &bSrc = result.outputBuffers[i];
-
-        sp<Camera3StreamInterface> stream = states.outputStreams.get(bSrc.streamId);
-        if (stream == nullptr) {
-            ALOGE("%s: Frame %d: Buffer %zu: Invalid output stream id %d",
-                    __FUNCTION__, result.frameNumber, i, bSrc.streamId);
-            return;
-        }
-        bDst.stream = stream->asHalStream();
-
-        bool noBufferReturned = false;
-        buffer_handle_t *buffer = nullptr;
-        if (states.useHalBufManager) {
-            // This is suspicious most of the time but can be correct during flush where HAL
-            // has to return capture result before a buffer is requested
-            if (bSrc.bufferId == BUFFER_ID_NO_BUFFER) {
-                if (bSrc.status == BufferStatusType::OK) {
-                    ALOGE("%s: Frame %d: Buffer %zu: No bufferId for stream %d",
-                            __FUNCTION__, result.frameNumber, i, bSrc.streamId);
-                    // Still proceeds so other buffers can be returned
-                }
-                noBufferReturned = true;
-            }
-            if (noBufferReturned) {
-                res = OK;
-            } else {
-                res = bufferRecords.popInflightRequestBuffer(bSrc.bufferId, &buffer);
-            }
-        } else {
-            res = bufferRecords.popInflightBuffer(result.frameNumber, bSrc.streamId, &buffer);
-        }
-
-        if (res != OK) {
-            ALOGE("%s: Frame %d: Buffer %zu: No in-flight buffer for stream %d",
-                    __FUNCTION__, result.frameNumber, i, bSrc.streamId);
-            return;
-        }
-
-        bDst.buffer = buffer;
-        bDst.status = mapBufferStatus<BufferStatusType>(bSrc.status);
-        bDst.acquire_fence = -1;
-        if (isHandleNull(bSrc.releaseFence)) {
-            bDst.release_fence = -1;
-        } else if (numFdsInHandle(bSrc.releaseFence) == 1) {
-            if (noBufferReturned) {
-                ALOGE("%s: got releaseFence without output buffer!", __FUNCTION__);
-            }
-            bDst.release_fence = dup(getHandleFirstFd(bSrc.releaseFence));
-        } else {
-            ALOGE("%s: Frame %d: Invalid release fence for buffer %zu, fd count is %d, not 1",
-                    __FUNCTION__, result.frameNumber, i, (int)numFdsInHandle(bSrc.releaseFence));
-            return;
-        }
-    }
-    r.num_output_buffers = outputBuffers.size();
-    r.output_buffers = outputBuffers.data();
-
-    camera_stream_buffer_t inputBuffer;
-    if (result.inputBuffer.streamId == -1) {
-        r.input_buffer = nullptr;
-    } else {
-        if (states.inputStream->getId() != result.inputBuffer.streamId) {
-            ALOGE("%s: Frame %d: Invalid input stream id %d", __FUNCTION__,
-                    result.frameNumber, result.inputBuffer.streamId);
-            return;
-        }
-        inputBuffer.stream = states.inputStream->asHalStream();
-        buffer_handle_t *buffer;
-        res = bufferRecords.popInflightBuffer(result.frameNumber, result.inputBuffer.streamId,
-                &buffer);
-        if (res != OK) {
-            ALOGE("%s: Frame %d: Input buffer: No in-flight buffer for stream %d",
-                    __FUNCTION__, result.frameNumber, result.inputBuffer.streamId);
-            return;
-        }
-        inputBuffer.buffer = buffer;
-        inputBuffer.status = mapBufferStatus<BufferStatusType>(result.inputBuffer.status);
-        inputBuffer.acquire_fence = -1;
-        if (isHandleNull(result.inputBuffer.releaseFence)) {
-            inputBuffer.release_fence = -1;
-        } else if (numFdsInHandle(result.inputBuffer.releaseFence) == 1) {
-            inputBuffer.release_fence = dup(getHandleFirstFd(result.inputBuffer.releaseFence));
-        } else {
-            ALOGE("%s: Frame %d: Invalid release fence for input buffer, fd count is %d, not 1",
-                    __FUNCTION__, result.frameNumber,
-                    (int)numFdsInHandle(result.inputBuffer.releaseFence));
-            return;
-        }
-        r.input_buffer = &inputBuffer;
-    }
-
-    r.partial_result = result.partialResult;
-
-    processCaptureResult(states, &r);
-}
-
-template <class VecStreamBufferType>
-void returnStreamBuffersT(ReturnBufferStates& states,
-        const VecStreamBufferType& buffers) {
-    if (!states.useHalBufManager) {
-        ALOGE("%s: Camera %s does not support HAL buffer managerment",
-                __FUNCTION__, states.cameraId.string());
-        return;
-    }
-
-    for (const auto& buf : buffers) {
-        if (buf.bufferId == BUFFER_ID_NO_BUFFER) {
-            ALOGE("%s: cannot return a buffer without bufferId", __FUNCTION__);
-            continue;
-        }
-
-        buffer_handle_t* buffer;
-        status_t res = states.bufferRecordsIntf.popInflightRequestBuffer(buf.bufferId, &buffer);
-
-        if (res != OK) {
-            ALOGE("%s: cannot find in-flight buffer %" PRIu64 " for stream %d",
-                    __FUNCTION__, buf.bufferId, buf.streamId);
-            continue;
-        }
-
-        camera_stream_buffer_t streamBuffer;
-        streamBuffer.buffer = buffer;
-        streamBuffer.status = CAMERA_BUFFER_STATUS_ERROR;
-        streamBuffer.acquire_fence = -1;
-        streamBuffer.release_fence = -1;
-
-        if (isHandleNull(buf.releaseFence)) {
-            streamBuffer.release_fence = -1;
-        } else if (numFdsInHandle(buf.releaseFence) == 1) {
-            streamBuffer.release_fence = dup(getHandleFirstFd(buf.releaseFence));
-        } else {
-            ALOGE("%s: Invalid release fence, fd count is %d, not 1",
-                    __FUNCTION__, (int)numFdsInHandle(buf.releaseFence));
-            continue;
-        }
-
-        sp<Camera3StreamInterface> stream = states.outputStreams.get(buf.streamId);
-        if (stream == nullptr) {
-            ALOGE("%s: Output stream id %d not found!", __FUNCTION__, buf.streamId);
-            continue;
-        }
-        streamBuffer.stream = stream->asHalStream();
-        returnOutputBuffers(states.useHalBufManager, /*listener*/nullptr,
-                &streamBuffer, /*size*/1, /*timestamp*/ 0, /*readoutTimestamp*/0,
-                /*requested*/false, /*requestTimeNs*/0, states.sessionStatsBuilder);
-    }
-}
-
-} // camera3
-} // namespace android
-
-#endif
diff --git a/services/camera/libcameraservice/device3/Camera3SharedOutputStream.cpp b/services/camera/libcameraservice/device3/Camera3SharedOutputStream.cpp
index 9215f23ecb..9e0c8f3d96 100644
--- a/services/camera/libcameraservice/device3/Camera3SharedOutputStream.cpp
+++ b/services/camera/libcameraservice/device3/Camera3SharedOutputStream.cpp
@@ -32,15 +32,11 @@ Camera3SharedOutputStream::Camera3SharedOutputStream(int id,
         uint64_t consumerUsage, android_dataspace dataSpace,
         camera_stream_rotation_t rotation,
         nsecs_t timestampOffset, const String8& physicalCameraId,
-        const std::unordered_set<int32_t> &sensorPixelModesUsed, IPCTransport transport,
-        int setId, bool useHalBufManager, int64_t dynamicProfile,
-        int64_t streamUseCase, bool deviceTimeBaseIsRealtime, int timestampBase,
-        int mirrorMode) :
+        const std::unordered_set<int32_t> &sensorPixelModesUsed,
+        int setId, bool useHalBufManager) :
         Camera3OutputStream(id, CAMERA_STREAM_OUTPUT, width, height,
                             format, dataSpace, rotation, physicalCameraId, sensorPixelModesUsed,
-                            transport, consumerUsage, timestampOffset, setId,
-                            /*isMultiResolution*/false, dynamicProfile, streamUseCase,
-                            deviceTimeBaseIsRealtime, timestampBase, mirrorMode),
+                            consumerUsage, timestampOffset, setId),
         mUseHalBufManager(useHalBufManager) {
     size_t consumerCount = std::min(surfaces.size(), kMaxOutputs);
     if (surfaces.size() > consumerCount) {
@@ -71,7 +67,7 @@ status_t Camera3SharedOutputStream::connectStreamSplitterLocked() {
     }
 
     res = mStreamSplitter->connect(initialSurfaces, usage, mUsage, camera_stream::max_buffers,
-            getWidth(), getHeight(), getFormat(), &mConsumer, camera_stream::dynamic_range_profile);
+            getWidth(), getHeight(), getFormat(), &mConsumer);
     if (res != OK) {
         ALOGE("%s: Failed to connect to stream splitter: %s(%d)",
                 __FUNCTION__, strerror(-res), res);
@@ -251,7 +247,7 @@ status_t Camera3SharedOutputStream::configureQueueLocked() {
         return res;
     }
 
-    res = configureConsumerQueueLocked(false/*allowPreviewRespace*/);
+    res = configureConsumerQueueLocked(false/*allowPreviewScheduler*/);
     if (res != OK) {
         ALOGE("Failed to configureConsumerQueueLocked: %s(%d)", strerror(-res), res);
         return res;
@@ -392,15 +388,13 @@ status_t Camera3SharedOutputStream::updateStream(const std::vector<sp<Surface>>
         bool sizeMismatch = ((static_cast<uint32_t>(infoIt.width) != getWidth()) ||
                                 (static_cast<uint32_t> (infoIt.height) != getHeight())) ?
                                 true : false;
-        bool dynamicRangeMismatch = dynamic_range_profile != infoIt.dynamicRangeProfile;
-        if ((imgReaderUsage && sizeMismatch) || dynamicRangeMismatch ||
+        if ((imgReaderUsage && sizeMismatch) ||
                 (infoIt.format != getOriginalFormat() && infoIt.format != getFormat()) ||
                 (infoIt.dataSpace != getDataSpace() &&
                  infoIt.dataSpace != getOriginalDataSpace())) {
-            ALOGE("%s: Shared surface parameters format: 0x%x dataSpace: 0x%x dynamic range 0x%"
-                    PRIx64 " don't match source stream format: 0x%x  dataSpace: 0x%x dynamic"
-                    " range 0x%" PRIx64 , __FUNCTION__, infoIt.format, infoIt.dataSpace,
-                    infoIt.dynamicRangeProfile, getFormat(), getDataSpace(), dynamic_range_profile);
+            ALOGE("%s: Shared surface parameters format: 0x%x dataSpace: 0x%x "
+                    " don't match source stream format: 0x%x  dataSpace: 0x%x", __FUNCTION__,
+                    infoIt.format, infoIt.dataSpace, getFormat(), getDataSpace());
             return BAD_VALUE;
         }
     }
diff --git a/services/camera/libcameraservice/device3/Camera3SharedOutputStream.h b/services/camera/libcameraservice/device3/Camera3SharedOutputStream.h
index aac3c2a868..4b6341bf2b 100644
--- a/services/camera/libcameraservice/device3/Camera3SharedOutputStream.h
+++ b/services/camera/libcameraservice/device3/Camera3SharedOutputStream.h
@@ -38,14 +38,9 @@ public:
             uint64_t consumerUsage, android_dataspace dataSpace,
             camera_stream_rotation_t rotation, nsecs_t timestampOffset,
             const String8& physicalCameraId,
-            const std::unordered_set<int32_t> &sensorPixelModesUsed, IPCTransport transport,
+            const std::unordered_set<int32_t> &sensorPixelModesUsed,
             int setId = CAMERA3_STREAM_SET_ID_INVALID,
-            bool useHalBufManager = false,
-            int64_t dynamicProfile = ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD,
-            int64_t streamUseCase = ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT,
-            bool deviceTimeBaseIsRealtime = false,
-            int timestampBase = OutputConfiguration::TIMESTAMP_BASE_DEFAULT,
-            int mirrorMode = OutputConfiguration::MIRROR_MODE_AUTO);
+            bool useHalBufManager = false);
 
     virtual ~Camera3SharedOutputStream();
 
diff --git a/services/camera/libcameraservice/device3/Camera3Stream.cpp b/services/camera/libcameraservice/device3/Camera3Stream.cpp
index 7ad6649754..afcfd2a026 100644
--- a/services/camera/libcameraservice/device3/Camera3Stream.cpp
+++ b/services/camera/libcameraservice/device3/Camera3Stream.cpp
@@ -14,8 +14,6 @@
  * limitations under the License.
  */
 
-#include <vector>
-#include "system/window.h"
 #define LOG_TAG "Camera3-Stream"
 #define ATRACE_TAG ATRACE_TAG_CAMERA
 //#define LOG_NDEBUG 0
@@ -25,7 +23,6 @@
 #include "device3/Camera3Stream.h"
 #include "device3/StatusTracker.h"
 #include "utils/TraceHFR.h"
-#include "ui/GraphicBufferMapper.h"
 
 #include <cutils/properties.h>
 
@@ -54,8 +51,7 @@ Camera3Stream::Camera3Stream(int id,
         android_dataspace dataSpace, camera_stream_rotation_t rotation,
         const String8& physicalCameraId,
         const std::unordered_set<int32_t> &sensorPixelModesUsed,
-        int setId, bool isMultiResolution, int64_t dynamicRangeProfile,
-        int64_t streamUseCase, bool deviceTimeBaseIsRealtime, int timestampBase) :
+        int setId, bool isMultiResolution) :
     camera_stream(),
     mId(id),
     mSetId(setId),
@@ -80,9 +76,7 @@ Camera3Stream::Camera3Stream(int id,
     mOriginalDataSpace(dataSpace),
     mPhysicalCameraId(physicalCameraId),
     mLastTimestamp(0),
-    mIsMultiResolution(isMultiResolution),
-    mDeviceTimeBaseIsRealtime(deviceTimeBaseIsRealtime),
-    mTimestampBase(timestampBase) {
+    mIsMultiResolution(isMultiResolution) {
 
     camera_stream::stream_type = type;
     camera_stream::width = width;
@@ -93,8 +87,6 @@ Camera3Stream::Camera3Stream(int id,
     camera_stream::max_buffers = 0;
     camera_stream::physical_camera_id = mPhysicalCameraId.string();
     camera_stream::sensor_pixel_modes_used = sensorPixelModesUsed;
-    camera_stream::dynamic_range_profile = dynamicRangeProfile;
-    camera_stream::use_case = streamUseCase;
 
     if ((format == HAL_PIXEL_FORMAT_BLOB || format == HAL_PIXEL_FORMAT_RAW_OPAQUE) &&
             maxSize == 0) {
@@ -155,10 +147,6 @@ int Camera3Stream::getOriginalFormat() const {
     return mOriginalFormat;
 }
 
-int64_t Camera3Stream::getDynamicRangeProfile() const {
-    return camera_stream::dynamic_range_profile;
-}
-
 void Camera3Stream::setDataSpaceOverride(bool dataSpaceOverridden) {
     mDataSpaceOverridden = dataSpaceOverridden;
 }
@@ -179,18 +167,6 @@ int Camera3Stream::getMaxHalBuffers() const {
     return camera_stream::max_buffers;
 }
 
-int64_t Camera3Stream::getStreamUseCase() const {
-    return camera_stream::use_case;
-}
-
-int Camera3Stream::getTimestampBase() const {
-    return mTimestampBase;
-}
-
-bool Camera3Stream::isDeviceTimeBaseRealtime() const {
-    return mDeviceTimeBaseIsRealtime;
-}
-
 void Camera3Stream::setOfflineProcessingSupport(bool support) {
     mSupportOfflineProcessing = support;
 }
@@ -581,8 +557,7 @@ status_t Camera3Stream::cancelPrepareLocked() {
     for (size_t i = 0; i < mPreparedBufferIdx; i++) {
         mPreparedBuffers.editItemAt(i).release_fence = -1;
         mPreparedBuffers.editItemAt(i).status = CAMERA_BUFFER_STATUS_ERROR;
-        returnBufferLocked(mPreparedBuffers[i], /*timestamp*/0, /*readoutTimestamp*/0,
-                /*transform*/ -1);
+        returnBufferLocked(mPreparedBuffers[i], 0, /*transform*/ -1);
     }
     mPreparedBuffers.clear();
     mPreparedBufferIdx = 0;
@@ -738,7 +713,7 @@ void Camera3Stream::removeOutstandingBuffer(const camera_stream_buffer &buffer)
 }
 
 status_t Camera3Stream::returnBuffer(const camera_stream_buffer &buffer,
-        nsecs_t timestamp, nsecs_t readoutTimestamp, bool timestampIncreasing,
+        nsecs_t timestamp, bool timestampIncreasing,
          const std::vector<size_t>& surface_ids, uint64_t frameNumber, int32_t transform) {
     ATRACE_HFR_CALL();
     Mutex::Autolock l(mLock);
@@ -768,7 +743,7 @@ status_t Camera3Stream::returnBuffer(const camera_stream_buffer &buffer,
      *
      * Do this for getBuffer as well.
      */
-    status_t res = returnBufferLocked(b, timestamp, readoutTimestamp, transform, surface_ids);
+    status_t res = returnBufferLocked(b, timestamp, transform, surface_ids);
     if (res == OK) {
         fireBufferListenersLocked(b, /*acquired*/false, /*output*/true, timestamp, frameNumber);
     }
@@ -956,7 +931,7 @@ status_t Camera3Stream::getBuffersLocked(std::vector<OutstandingBuffer>*) {
 }
 
 status_t Camera3Stream::returnBufferLocked(const camera_stream_buffer &,
-                                           nsecs_t, nsecs_t, int32_t, const std::vector<size_t>&) {
+                                           nsecs_t, int32_t, const std::vector<size_t>&) {
     ALOGE("%s: This type of stream does not support output", __FUNCTION__);
     return INVALID_OPERATION;
 }
@@ -1102,52 +1077,6 @@ status_t Camera3Stream::getBuffers(std::vector<OutstandingBuffer>* buffers,
     return res;
 }
 
-void Camera3Stream::queueHDRMetadata(buffer_handle_t buffer, sp<ANativeWindow>& anw,
-        int64_t dynamicRangeProfile) {
-    auto& mapper = GraphicBufferMapper::get();
-    switch (dynamicRangeProfile) {
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10: {
-            std::optional<ui::Smpte2086> smpte2086;
-            auto res = mapper.getSmpte2086(buffer, &smpte2086);
-            if ((res == OK) && smpte2086.has_value()) {
-                const auto& metaValue = smpte2086.value();
-                android_smpte2086_metadata meta = {
-                    .displayPrimaryRed.x = metaValue.primaryRed.x,
-                    .displayPrimaryRed.y = metaValue.primaryRed.y,
-                    .displayPrimaryGreen.x = metaValue.primaryGreen.x,
-                    .displayPrimaryGreen.y = metaValue.primaryGreen.y,
-                    .displayPrimaryBlue.x = metaValue.primaryBlue.x,
-                    .displayPrimaryBlue.y = metaValue.primaryBlue.y,
-                    .whitePoint.x = metaValue.whitePoint.x,
-                    .whitePoint.y = metaValue.whitePoint.y,
-                    .maxLuminance = metaValue.maxLuminance,
-                    .minLuminance = metaValue.minLuminance};
-                native_window_set_buffers_smpte2086_metadata(anw.get(), &meta);
-            } else {
-                ALOGE("%s Couldn't retrieve Smpte2086 metadata %s (%d)",
-                        __FUNCTION__, strerror(-res), res);
-            }
-            break;
-        }
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10_PLUS: {
-            std::optional<std::vector<uint8_t>> smpte2094_40;
-            auto res = mapper.getSmpte2094_40(buffer, &smpte2094_40);
-            if ((res == OK) && smpte2094_40.has_value()) {
-                native_window_set_buffers_hdr10_plus_metadata(anw.get(),
-                        smpte2094_40.value().size(), smpte2094_40.value().data());
-            } else {
-                ALOGE("%s Couldn't retrieve Smpte2094_40 metadata %s (%d)",
-                        __FUNCTION__, strerror(-res), res);
-            }
-            break;
-        }
-        default:
-            // No-op
-            break;
-    }
-}
-
-
 }; // namespace camera3
 
 }; // namespace android
diff --git a/services/camera/libcameraservice/device3/Camera3Stream.h b/services/camera/libcameraservice/device3/Camera3Stream.h
index d429e6caa8..fc75f79f9e 100644
--- a/services/camera/libcameraservice/device3/Camera3Stream.h
+++ b/services/camera/libcameraservice/device3/Camera3Stream.h
@@ -138,10 +138,6 @@ class Camera3Stream :
     static Camera3Stream*       cast(camera_stream *stream);
     static const Camera3Stream* cast(const camera_stream *stream);
 
-    // Queue corresponding HDR metadata to given native window.
-    static void queueHDRMetadata(buffer_handle_t buffer, sp<ANativeWindow>& anw,
-            int64_t dynamicRangeProfile);
-
     /**
      * Get the stream's ID
      */
@@ -172,15 +168,11 @@ class Camera3Stream :
     void              setFormatOverride(bool formatOverriden);
     bool              isFormatOverridden() const;
     int               getOriginalFormat() const;
-    int64_t           getDynamicRangeProfile() const;
     void              setDataSpaceOverride(bool dataSpaceOverriden);
     bool              isDataSpaceOverridden() const;
     android_dataspace getOriginalDataSpace() const;
     int               getMaxHalBuffers() const;
     const String8&    physicalCameraId() const;
-    int64_t           getStreamUseCase() const;
-    int               getTimestampBase() const;
-    bool              isDeviceTimeBaseRealtime() const;
 
     void              setOfflineProcessingSupport(bool) override;
     bool              getOfflineProcessingSupport() const override;
@@ -360,7 +352,7 @@ class Camera3Stream :
      * For bidirectional streams, this method applies to the output-side buffers
      */
     status_t         returnBuffer(const camera_stream_buffer &buffer,
-            nsecs_t timestamp, nsecs_t readoutTimestamp, bool timestampIncreasing,
+            nsecs_t timestamp, bool timestampIncreasing,
             const std::vector<size_t>& surface_ids = std::vector<size_t>(),
             uint64_t frameNumber = 0, int32_t transform = -1);
 
@@ -508,8 +500,7 @@ class Camera3Stream :
             android_dataspace dataSpace, camera_stream_rotation_t rotation,
             const String8& physicalCameraId,
             const std::unordered_set<int32_t> &sensorPixelModesUsed,
-            int setId, bool isMultiResolution, int64_t dynamicRangeProfile,
-            int64_t streamUseCase, bool deviceTimeBaseIsRealtime, int timestampBase);
+            int setId, bool isMultiResolution);
 
     wp<Camera3StreamBufferFreedListener> mBufferFreedListener;
 
@@ -526,7 +517,7 @@ class Camera3Stream :
     virtual status_t getBufferLocked(camera_stream_buffer *buffer,
             const std::vector<size_t>& surface_ids = std::vector<size_t>());
     virtual status_t returnBufferLocked(const camera_stream_buffer &buffer,
-            nsecs_t timestamp, nsecs_t readoutTimestamp, int32_t transform,
+            nsecs_t timestamp, int32_t transform,
             const std::vector<size_t>& surface_ids = std::vector<size_t>());
 
     virtual status_t getBuffersLocked(std::vector<OutstandingBuffer>*);
@@ -632,9 +623,6 @@ class Camera3Stream :
 
     bool mIsMultiResolution = false;
     bool mSupportOfflineProcessing = false;
-
-    bool mDeviceTimeBaseIsRealtime;
-    int mTimestampBase;
 }; // class Camera3Stream
 
 }; // namespace camera3
diff --git a/services/camera/libcameraservice/device3/Camera3StreamInterface.h b/services/camera/libcameraservice/device3/Camera3StreamInterface.h
index 6812e89581..3aa5a3ce41 100644
--- a/services/camera/libcameraservice/device3/Camera3StreamInterface.h
+++ b/services/camera/libcameraservice/device3/Camera3StreamInterface.h
@@ -19,7 +19,6 @@
 
 #include <utils/RefBase.h>
 
-#include <camera/camera2/OutputConfiguration.h>
 #include <camera/CameraMetadata.h>
 #include "Camera3StreamBufferListener.h"
 #include "Camera3StreamBufferFreedListener.h"
@@ -65,8 +64,6 @@ typedef struct camera_stream {
     const char* physical_camera_id;
 
     std::unordered_set<int32_t> sensor_pixel_modes_used;
-    int64_t dynamic_range_profile;
-    int64_t use_case;
 } camera_stream_t;
 
 typedef struct camera_stream_buffer {
@@ -110,61 +107,14 @@ class OutputStreamInfo {
         bool finalized = false;
         bool supportsOffline = false;
         std::unordered_set<int32_t> sensorPixelModesUsed;
-        int64_t dynamicRangeProfile;
-        int64_t streamUseCase;
-        int timestampBase;
-        int mirrorMode;
         OutputStreamInfo() :
             width(-1), height(-1), format(-1), dataSpace(HAL_DATASPACE_UNKNOWN),
-            consumerUsage(0),
-            dynamicRangeProfile(ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD),
-            streamUseCase(ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT),
-            timestampBase(OutputConfiguration::TIMESTAMP_BASE_DEFAULT),
-            mirrorMode(OutputConfiguration::MIRROR_MODE_AUTO) {}
+            consumerUsage(0) {}
         OutputStreamInfo(int _width, int _height, int _format, android_dataspace _dataSpace,
-                uint64_t _consumerUsage, const std::unordered_set<int32_t>& _sensorPixelModesUsed,
-                int64_t _dynamicRangeProfile, int _streamUseCase, int _timestampBase, int _mirrorMode) :
+                uint64_t _consumerUsage, const std::unordered_set<int32_t>& _sensorPixelModesUsed) :
             width(_width), height(_height), format(_format),
             dataSpace(_dataSpace), consumerUsage(_consumerUsage),
-            sensorPixelModesUsed(_sensorPixelModesUsed), dynamicRangeProfile(_dynamicRangeProfile),
-            streamUseCase(_streamUseCase), timestampBase(_timestampBase), mirrorMode(_mirrorMode) {}
-};
-
-// Utility class to lock and unlock a GraphicBuffer
-class GraphicBufferLocker {
-public:
-    GraphicBufferLocker(sp<GraphicBuffer> buffer) : _buffer(buffer) {}
-
-    status_t lockAsync(uint32_t usage, void** dstBuffer, int fenceFd) {
-        if (_buffer == nullptr) return BAD_VALUE;
-
-        status_t res = OK;
-        if (!_locked) {
-            status_t res =  _buffer->lockAsync(usage, dstBuffer, fenceFd);
-            if (res == OK) {
-                _locked = true;
-            }
-        }
-        return res;
-    }
-
-    status_t lockAsync(void** dstBuffer, int fenceFd) {
-        return lockAsync(GRALLOC_USAGE_SW_WRITE_OFTEN, dstBuffer, fenceFd);
-    }
-
-    ~GraphicBufferLocker() {
-        if (_locked && _buffer != nullptr) {
-            auto res = _buffer->unlock();
-            if (res != OK) {
-                ALOGE("%s: Error trying to unlock buffer: %s (%d)", __FUNCTION__,
-                        strerror(-res), res);
-            }
-        }
-    }
-
-private:
-    sp<GraphicBuffer> _buffer;
-    bool _locked = false;
+            sensorPixelModesUsed(_sensorPixelModesUsed) {}
 };
 
 /**
@@ -204,7 +154,6 @@ class Camera3StreamInterface : public virtual RefBase {
     virtual uint32_t getWidth() const = 0;
     virtual uint32_t getHeight() const = 0;
     virtual int      getFormat() const = 0;
-    virtual int64_t  getDynamicRangeProfile() const = 0;
     virtual android_dataspace getDataSpace() const = 0;
     virtual void setFormatOverride(bool formatOverriden) = 0;
     virtual bool isFormatOverridden() const = 0;
@@ -408,7 +357,7 @@ class Camera3StreamInterface : public virtual RefBase {
      * For bidirectional streams, this method applies to the output-side buffers
      */
     virtual status_t returnBuffer(const camera_stream_buffer &buffer,
-            nsecs_t timestamp, nsecs_t readoutTimestamp, bool timestampIncreasing = true,
+            nsecs_t timestamp, bool timestampIncreasing = true,
             const std::vector<size_t>& surface_ids = std::vector<size_t>(),
             uint64_t frameNumber = 0, int32_t transform = -1) = 0;
 
diff --git a/services/camera/libcameraservice/device3/Camera3StreamSplitter.cpp b/services/camera/libcameraservice/device3/Camera3StreamSplitter.cpp
index fd239589e5..5c6c518fae 100644
--- a/services/camera/libcameraservice/device3/Camera3StreamSplitter.cpp
+++ b/services/camera/libcameraservice/device3/Camera3StreamSplitter.cpp
@@ -34,16 +34,13 @@
 
 #include <cutils/atomic.h>
 
-#include "Camera3Stream.h"
-
 #include "Camera3StreamSplitter.h"
 
 namespace android {
 
 status_t Camera3StreamSplitter::connect(const std::unordered_map<size_t, sp<Surface>> &surfaces,
         uint64_t consumerUsage, uint64_t producerUsage, size_t halMaxBuffers, uint32_t width,
-        uint32_t height, android::PixelFormat format, sp<Surface>* consumer,
-        int64_t dynamicRangeProfile) {
+        uint32_t height, android::PixelFormat format, sp<Surface>* consumer) {
     ATRACE_CALL();
     if (consumer == nullptr) {
         SP_LOGE("%s: consumer pointer is NULL", __FUNCTION__);
@@ -64,7 +61,6 @@ status_t Camera3StreamSplitter::connect(const std::unordered_map<size_t, sp<Surf
 
     mMaxHalBuffers = halMaxBuffers;
     mConsumerName = getUniqueConsumerName();
-    mDynamicRangeProfile = dynamicRangeProfile;
     // Add output surfaces. This has to be before creating internal buffer queue
     // in order to get max consumer side buffers.
     for (auto &it : surfaces) {
@@ -140,7 +136,6 @@ void Camera3StreamSplitter::disconnect() {
         }
     }
     mOutputs.clear();
-    mOutputSurfaces.clear();
     mOutputSlots.clear();
     mConsumerBufferCount.clear();
 
@@ -263,7 +258,6 @@ status_t Camera3StreamSplitter::addOutputLocked(size_t surfaceId, const sp<Surfa
 
     // Add new entry into mOutputs
     mOutputs[surfaceId] = gbp;
-    mOutputSurfaces[surfaceId] = outputQueue;
     mConsumerBufferCount[surfaceId] = maxConsumerBuffers;
     if (mConsumerBufferCount[surfaceId] > mMaxHalBuffers) {
         SP_LOGW("%s: Consumer buffer count %zu larger than max. Hal buffers: %zu", __FUNCTION__,
@@ -322,7 +316,6 @@ status_t Camera3StreamSplitter::removeOutputLocked(size_t surfaceId) {
         }
     }
     mOutputs[surfaceId] = nullptr;
-    mOutputSurfaces[surfaceId] = nullptr;
     mOutputSlots[gbp] = nullptr;
     for (const auto &id : pendingBufferIds) {
         decrementBufRefCountLocked(id, surfaceId);
@@ -363,14 +356,6 @@ status_t Camera3StreamSplitter::outputBufferLocked(const sp<IGraphicBufferProduc
     const BufferTracker& tracker = *(mBuffers[bufferId]);
     int slot = getSlotForOutputLocked(output, tracker.getBuffer());
 
-    if (mOutputSurfaces[surfaceId] != nullptr) {
-        sp<ANativeWindow> anw = mOutputSurfaces[surfaceId];
-        camera3::Camera3Stream::queueHDRMetadata(
-                bufferItem.mGraphicBuffer->getNativeBuffer()->handle, anw, mDynamicRangeProfile);
-    } else {
-        SP_LOGE("%s: Invalid surface id: %zu!", __FUNCTION__, surfaceId);
-    }
-
     // In case the output BufferQueue has its own lock, if we hold splitter lock while calling
     // queueBuffer (which will try to acquire the output lock), the output could be holding its
     // own lock calling releaseBuffer (which  will try to acquire the splitter lock), running into
diff --git a/services/camera/libcameraservice/device3/Camera3StreamSplitter.h b/services/camera/libcameraservice/device3/Camera3StreamSplitter.h
index 0f728a0786..4eb455abea 100644
--- a/services/camera/libcameraservice/device3/Camera3StreamSplitter.h
+++ b/services/camera/libcameraservice/device3/Camera3StreamSplitter.h
@@ -19,8 +19,6 @@
 
 #include <unordered_set>
 
-#include <camera/CameraMetadata.h>
-
 #include <gui/IConsumerListener.h>
 #include <gui/IProducerListener.h>
 #include <gui/BufferItemConsumer.h>
@@ -57,8 +55,7 @@ public:
     // with output surfaces.
     status_t connect(const std::unordered_map<size_t, sp<Surface>> &surfaces,
             uint64_t consumerUsage, uint64_t producerUsage, size_t halMaxBuffers, uint32_t width,
-            uint32_t height, android::PixelFormat format, sp<Surface>* consumer,
-            int64_t dynamicRangeProfile);
+            uint32_t height, android::PixelFormat format, sp<Surface>* consumer);
 
     // addOutput adds an output BufferQueue to the splitter. The splitter
     // connects to outputQueue as a CPU producer, and any buffers queued
@@ -235,7 +232,6 @@ private:
     uint32_t mHeight = 0;
     android::PixelFormat mFormat = android::PIXEL_FORMAT_NONE;
     uint64_t mProducerUsage = 0;
-    int mDynamicRangeProfile = ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD;
 
     // The attachBuffer call will happen on different thread according to mUseHalBufManager and have
     // different timing constraint.
@@ -255,9 +251,6 @@ private:
     //Map surface ids -> gbp outputs
     std::unordered_map<int, sp<IGraphicBufferProducer> > mOutputs;
 
-    //Map surface ids -> gbp outputs
-    std::unordered_map<int, sp<Surface>> mOutputSurfaces;
-
     //Map surface ids -> consumer buffer count
     std::unordered_map<int, size_t > mConsumerBufferCount;
 
diff --git a/services/camera/libcameraservice/device3/DistortionMapper.cpp b/services/camera/libcameraservice/device3/DistortionMapper.cpp
index 15807bf6cf..89dd115392 100644
--- a/services/camera/libcameraservice/device3/DistortionMapper.cpp
+++ b/services/camera/libcameraservice/device3/DistortionMapper.cpp
@@ -22,7 +22,7 @@
 #include <cmath>
 
 #include "device3/DistortionMapper.h"
-#include "utils/SessionConfigurationUtilsHost.h"
+#include "utils/SessionConfigurationUtils.h"
 
 namespace android {
 
diff --git a/services/camera/libcameraservice/device3/InFlightRequest.h b/services/camera/libcameraservice/device3/InFlightRequest.h
index 493a9e2fb6..e752c8c5ad 100644
--- a/services/camera/libcameraservice/device3/InFlightRequest.h
+++ b/services/camera/libcameraservice/device3/InFlightRequest.h
@@ -65,7 +65,6 @@ typedef struct camera_capture_result {
 typedef struct camera_shutter_msg {
     uint32_t frame_number;
     uint64_t timestamp;
-    uint64_t readout_timestamp;
 } camera_shutter_msg_t;
 
 typedef struct camera_error_msg {
@@ -102,10 +101,9 @@ typedef enum {
 } ERROR_BUF_STRATEGY;
 
 struct InFlightRequest {
+
     // Set by notify() SHUTTER call.
     nsecs_t shutterTimestamp;
-    // Set by notify() SHUTTER call with readout time.
-    nsecs_t shutterReadoutTimestamp;
     // Set by process_capture_result().
     nsecs_t sensorTimestamp;
     int     requestStatus;
@@ -143,11 +141,6 @@ struct InFlightRequest {
     // is not for constrained high speed recording, this flag will also be true.
     bool hasCallback;
 
-    // Minimum expected frame duration for this request
-    // For manual captures, equal to the max of requested exposure time and frame duration
-    // For auto-exposure modes, equal to 1/(higher end of target FPS range)
-    nsecs_t minExpectedDuration;
-
     // Maximum expected frame duration for this request.
     // For manual captures, equal to the max of requested exposure time and frame duration
     // For auto-exposure modes, equal to 1/(lower end of target FPS range)
@@ -192,8 +185,8 @@ struct InFlightRequest {
     // Current output transformation
     int32_t transform;
 
-    static const nsecs_t kDefaultMinExpectedDuration = 33333333; // 33 ms
-    static const nsecs_t kDefaultMaxExpectedDuration = 100000000; // 100 ms
+    // TODO: dedupe
+    static const nsecs_t kDefaultExpectedDuration = 100000000; // 100 ms
 
     // Default constructor needed by KeyedVector
     InFlightRequest() :
@@ -204,8 +197,7 @@ struct InFlightRequest {
             numBuffersLeft(0),
             hasInputBuffer(false),
             hasCallback(true),
-            minExpectedDuration(kDefaultMinExpectedDuration),
-            maxExpectedDuration(kDefaultMaxExpectedDuration),
+            maxExpectedDuration(kDefaultExpectedDuration),
             skipResultMetadata(false),
             errorBufStrategy(ERROR_BUF_CACHE),
             stillCapture(false),
@@ -216,7 +208,7 @@ struct InFlightRequest {
     }
 
     InFlightRequest(int numBuffers, CaptureResultExtras extras, bool hasInput,
-            bool hasAppCallback, nsecs_t minDuration, nsecs_t maxDuration,
+            bool hasAppCallback, nsecs_t maxDuration,
             const std::set<std::set<String8>>& physicalCameraIdSet, bool isStillCapture,
             bool isZslCapture, bool rotateAndCropAuto, const std::set<std::string>& idsWithZoom,
             nsecs_t requestNs, const SurfaceMap& outSurfaces = SurfaceMap{}) :
@@ -228,7 +220,6 @@ struct InFlightRequest {
             resultExtras(extras),
             hasInputBuffer(hasInput),
             hasCallback(hasAppCallback),
-            minExpectedDuration(minDuration),
             maxExpectedDuration(maxDuration),
             skipResultMetadata(false),
             errorBufStrategy(ERROR_BUF_CACHE),
diff --git a/services/camera/libcameraservice/device3/PreviewFrameScheduler.cpp b/services/camera/libcameraservice/device3/PreviewFrameScheduler.cpp
new file mode 100644
index 0000000000..2de2732b4c
--- /dev/null
+++ b/services/camera/libcameraservice/device3/PreviewFrameScheduler.cpp
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "Camera3-PreviewFrameScheduler"
+#define ATRACE_TAG ATRACE_TAG_CAMERA
+//#define LOG_NDEBUG 0
+
+#include <utils/Log.h>
+#include <utils/Trace.h>
+
+#include <android/looper.h>
+#include "PreviewFrameScheduler.h"
+#include "Camera3OutputStream.h"
+
+namespace android {
+
+namespace camera3 {
+
+/**
+ * Internal Choreographer thread implementation for polling and handling callbacks
+ */
+
+// Callback function for Choreographer
+static void frameCallback(const AChoreographerFrameCallbackData* callbackData, void* data) {
+    PreviewFrameScheduler* parent = static_cast<PreviewFrameScheduler*>(data);
+    if (parent == nullptr) {
+        ALOGE("%s: Invalid data for Choreographer callback!", __FUNCTION__);
+        return;
+    }
+
+    size_t length = AChoreographerFrameCallbackData_getFrameTimelinesLength(callbackData);
+    std::vector<nsecs_t> timeline(length);
+    for (size_t i = 0; i < length; i++) {
+        nsecs_t timestamp = AChoreographerFrameCallbackData_getFrameTimelineExpectedPresentationTimeNanos(
+                callbackData, i);
+        timeline[i] = timestamp;
+    }
+
+    parent->onNewPresentationTime(timeline);
+
+    AChoreographer_postVsyncCallback(AChoreographer_getInstance(), frameCallback, data);
+}
+
+struct ChoreographerThread : public Thread {
+    ChoreographerThread();
+    status_t start(PreviewFrameScheduler* parent);
+    virtual status_t readyToRun() override;
+    virtual bool threadLoop() override;
+
+protected:
+    virtual ~ChoreographerThread() {}
+
+private:
+    ChoreographerThread &operator=(const ChoreographerThread &);
+
+    // This only impacts the shutdown time. It won't impact the choreographer
+    // callback frequency.
+    static constexpr nsecs_t kPollingTimeoutMs = 5;
+    PreviewFrameScheduler* mParent = nullptr;
+};
+
+ChoreographerThread::ChoreographerThread() : Thread(false /*canCallJava*/) {
+}
+
+status_t ChoreographerThread::start(PreviewFrameScheduler* parent) {
+    mParent = parent;
+    return run("PreviewChoreographer");
+}
+
+status_t ChoreographerThread::readyToRun() {
+    ALooper_prepare(ALOOPER_PREPARE_ALLOW_NON_CALLBACKS);
+    if (AChoreographer_getInstance() == NULL) {
+        return NO_INIT;
+    }
+
+    AChoreographer_postVsyncCallback(
+            AChoreographer_getInstance(), frameCallback, mParent);
+    return OK;
+}
+
+bool ChoreographerThread::threadLoop() {
+    if (exitPending()) {
+        return false;
+    }
+    ALooper_pollOnce(kPollingTimeoutMs, nullptr, nullptr, nullptr);
+    return true;
+}
+
+/**
+ * PreviewFrameScheduler implementation
+ */
+
+PreviewFrameScheduler::PreviewFrameScheduler(Camera3OutputStream& parent, sp<Surface> consumer) :
+        mParent(parent),
+        mConsumer(consumer),
+        mChoreographerThread(new ChoreographerThread()) {
+}
+
+PreviewFrameScheduler::~PreviewFrameScheduler() {
+    {
+        Mutex::Autolock l(mLock);
+        mChoreographerThread->requestExit();
+    }
+    mChoreographerThread->join();
+}
+
+status_t PreviewFrameScheduler::queuePreviewBuffer(nsecs_t timestamp, int32_t transform,
+        ANativeWindowBuffer* anwBuffer, int releaseFence) {
+    // Start choreographer thread if it's not already running.
+    if (!mChoreographerThread->isRunning()) {
+        status_t res = mChoreographerThread->start(this);
+        if (res != OK) {
+            ALOGE("%s: Failed to init choreographer thread!", __FUNCTION__);
+            return res;
+        }
+    }
+
+    {
+        Mutex::Autolock l(mLock);
+        mPendingBuffers.emplace(timestamp, transform, anwBuffer, releaseFence);
+
+        // Queue buffer to client right away if pending buffers are more than
+        // the queue depth watermark.
+        if (mPendingBuffers.size() > kQueueDepthWatermark) {
+            auto oldBuffer = mPendingBuffers.front();
+            mPendingBuffers.pop();
+
+            status_t res = queueBufferToClientLocked(oldBuffer, oldBuffer.timestamp);
+            if (res != OK) {
+                return res;
+            }
+
+            // Reset the last capture and presentation time
+            mLastCameraCaptureTime = 0;
+            mLastCameraPresentTime = 0;
+        } else {
+            ATRACE_INT(kPendingBufferTraceName, mPendingBuffers.size());
+        }
+    }
+    return OK;
+}
+
+void PreviewFrameScheduler::onNewPresentationTime(const std::vector<nsecs_t>& timeline) {
+    ATRACE_CALL();
+    Mutex::Autolock l(mLock);
+    if (mPendingBuffers.size() > 0) {
+        auto nextBuffer = mPendingBuffers.front();
+        mPendingBuffers.pop();
+
+        // Find the best presentation time by finding the element in the
+        // choreographer timeline that's closest to the ideal presentation time.
+        // The ideal presentation time is the last presentation time + frame
+        // interval.
+        nsecs_t cameraInterval = nextBuffer.timestamp - mLastCameraCaptureTime;
+        nsecs_t idealPresentTime = (cameraInterval < kSpacingResetIntervalNs) ?
+                (mLastCameraPresentTime + cameraInterval) : nextBuffer.timestamp;
+        nsecs_t presentTime = *std::min_element(timeline.begin(), timeline.end(),
+                [idealPresentTime](nsecs_t p1, nsecs_t p2) {
+                        return std::abs(p1 - idealPresentTime) < std::abs(p2 - idealPresentTime);
+                });
+
+        status_t res = queueBufferToClientLocked(nextBuffer, presentTime);
+        ATRACE_INT(kPendingBufferTraceName, mPendingBuffers.size());
+
+        if (mParent.shouldLogError(res)) {
+            ALOGE("%s: Preview Stream: Error queueing buffer to native window:"
+                    " %s (%d)", __FUNCTION__, strerror(-res), res);
+        }
+
+        mLastCameraCaptureTime = nextBuffer.timestamp;
+        mLastCameraPresentTime = presentTime;
+    }
+}
+
+status_t PreviewFrameScheduler::queueBufferToClientLocked(
+        const BufferHolder& bufferHolder, nsecs_t timestamp) {
+    mParent.setTransform(bufferHolder.transform);
+
+    status_t res = native_window_set_buffers_timestamp(mConsumer.get(), timestamp);
+    if (res != OK) {
+        ALOGE("%s: Preview Stream: Error setting timestamp: %s (%d)",
+                __FUNCTION__, strerror(-res), res);
+        return res;
+    }
+
+    res = mConsumer->queueBuffer(mConsumer.get(), bufferHolder.anwBuffer.get(),
+            bufferHolder.releaseFence);
+    if (res != OK) {
+        close(bufferHolder.releaseFence);
+    }
+
+    return res;
+}
+
+}; // namespace camera3
+
+}; // namespace android
diff --git a/services/camera/libcameraservice/device3/PreviewFrameScheduler.h b/services/camera/libcameraservice/device3/PreviewFrameScheduler.h
new file mode 100644
index 0000000000..c0574fd3d4
--- /dev/null
+++ b/services/camera/libcameraservice/device3/PreviewFrameScheduler.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_SERVERS_CAMERA_CAMERA3_PREVIEWFRAMESCHEDULER_H
+#define ANDROID_SERVERS_CAMERA_CAMERA3_PREVIEWFRAMESCHEDULER_H
+
+#include <queue>
+
+#include <android/choreographer.h>
+#include <gui/Surface.h>
+#include <gui/ISurfaceComposer.h>
+#include <utils/Condition.h>
+#include <utils/Mutex.h>
+#include <utils/Looper.h>
+#include <utils/Thread.h>
+#include <utils/Timers.h>
+
+namespace android {
+
+namespace camera3 {
+
+class Camera3OutputStream;
+struct ChoreographerThread;
+
+/***
+ * Preview stream scheduler for better preview display synchronization
+ *
+ * The ideal viewfinder user experience is that frames are presented to the
+ * user in the same cadence as outputed by the camera sensor. However, the
+ * processing latency between frames could vary, due to factors such
+ * as CPU load, differences in request settings, etc. This frame processing
+ * latency results in variation in presentation of frames to the user.
+ *
+ * The PreviewFrameScheduler improves the viewfinder user experience by:
+ * 1. Cache preview buffers in the scheduler
+ * 2. For each choreographer callback, queue the oldest cached buffer with
+ *    the best matching presentation timestamp. Frame N's presentation timestamp
+ *    is the choreographer timeline timestamp closest to (Frame N-1's
+ *    presentation time + camera capture interval between frame N-1 and frame N).
+ * 3. Maintain at most 2 queue-able buffers. If the 3rd preview buffer becomes
+ *    available, queue the oldest cached buffer to the buffer queue.
+ */
+class PreviewFrameScheduler {
+  public:
+    explicit PreviewFrameScheduler(Camera3OutputStream& parent, sp<Surface> consumer);
+    virtual ~PreviewFrameScheduler();
+
+    // Queue preview buffer locally
+    status_t queuePreviewBuffer(nsecs_t timestamp, int32_t transform,
+            ANativeWindowBuffer* anwBuffer, int releaseFence);
+
+    // Callback function with a new presentation timeline from choreographer. This
+    // will trigger a locally queued buffer be sent to the buffer queue.
+    void onNewPresentationTime(const std::vector<nsecs_t>& presentationTimeline);
+
+    // Maintain at most 2 queue-able buffers
+    static constexpr int32_t kQueueDepthWatermark = 2;
+
+  private:
+    // structure holding cached preview buffer info
+    struct BufferHolder {
+        nsecs_t timestamp;
+        int32_t transform;
+        sp<ANativeWindowBuffer> anwBuffer;
+        int releaseFence;
+
+        BufferHolder(nsecs_t t, int32_t tr, ANativeWindowBuffer* anwb, int rf) :
+                timestamp(t), transform(tr), anwBuffer(anwb), releaseFence(rf) {}
+    };
+
+    status_t queueBufferToClientLocked(const BufferHolder& bufferHolder,
+            nsecs_t presentTime);
+
+    static constexpr char kPendingBufferTraceName[] = "pending_preview_buffers";
+
+    // Camera capture interval for resetting frame spacing between preview sessions
+    static constexpr nsecs_t kSpacingResetIntervalNs = 1000000000L; // 1 second
+
+    Camera3OutputStream& mParent;
+    sp<ANativeWindow> mConsumer;
+    mutable Mutex mLock;
+
+    std::queue<BufferHolder> mPendingBuffers;
+    nsecs_t mLastCameraCaptureTime = 0;
+    nsecs_t mLastCameraPresentTime = 0;
+
+    // Choreographer related
+    sp<Looper> mLooper;
+    sp<ChoreographerThread> mChoreographerThread;
+};
+
+}; //namespace camera3
+}; //namespace android
+
+#endif
diff --git a/services/camera/libcameraservice/device3/PreviewFrameSpacer.cpp b/services/camera/libcameraservice/device3/PreviewFrameSpacer.cpp
deleted file mode 100644
index 0439501733..0000000000
--- a/services/camera/libcameraservice/device3/PreviewFrameSpacer.cpp
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "Camera3-PreviewFrameSpacer"
-#define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
-
-#include <utils/Log.h>
-
-#include "PreviewFrameSpacer.h"
-#include "Camera3OutputStream.h"
-
-namespace android {
-
-namespace camera3 {
-
-PreviewFrameSpacer::PreviewFrameSpacer(wp<Camera3OutputStream> parent, sp<Surface> consumer) :
-        mParent(parent),
-        mConsumer(consumer) {
-}
-
-PreviewFrameSpacer::~PreviewFrameSpacer() {
-}
-
-status_t PreviewFrameSpacer::queuePreviewBuffer(nsecs_t timestamp, nsecs_t readoutTimestamp,
-        int32_t transform, ANativeWindowBuffer* anwBuffer, int releaseFence) {
-    Mutex::Autolock l(mLock);
-    mPendingBuffers.emplace(timestamp, readoutTimestamp, transform, anwBuffer, releaseFence);
-    ALOGV("%s: mPendingBuffers size %zu, timestamp %" PRId64 ", readoutTime %" PRId64,
-            __FUNCTION__, mPendingBuffers.size(), timestamp, readoutTimestamp);
-
-    mBufferCond.signal();
-    return OK;
-}
-
-bool PreviewFrameSpacer::threadLoop() {
-    Mutex::Autolock l(mLock);
-    if (mPendingBuffers.size() == 0) {
-        mBufferCond.waitRelative(mLock, kWaitDuration);
-        if (exitPending()) {
-            return false;
-        } else {
-            return true;
-        }
-    }
-
-    nsecs_t currentTime = systemTime();
-    auto buffer = mPendingBuffers.front();
-    nsecs_t readoutInterval = buffer.readoutTimestamp - mLastCameraReadoutTime;
-    // If the readout interval exceeds threshold, directly queue
-    // cached buffer.
-    if (readoutInterval >= kFrameIntervalThreshold) {
-        mPendingBuffers.pop();
-        queueBufferToClientLocked(buffer, currentTime);
-        return true;
-    }
-
-    // Cache the frame to match readout time interval, for up to 33ms
-    nsecs_t expectedQueueTime = mLastCameraPresentTime + readoutInterval;
-    nsecs_t frameWaitTime = std::min(kMaxFrameWaitTime, expectedQueueTime - currentTime);
-    if (frameWaitTime > 0 && mPendingBuffers.size() < 2) {
-        mBufferCond.waitRelative(mLock, frameWaitTime);
-        if (exitPending()) {
-            return false;
-        }
-        currentTime = systemTime();
-    }
-    ALOGV("%s: readoutInterval %" PRId64 ", queueInterval %" PRId64 ", waited for %" PRId64
-            ", timestamp %" PRId64, __FUNCTION__, readoutInterval,
-            currentTime - mLastCameraPresentTime, frameWaitTime, buffer.timestamp);
-    mPendingBuffers.pop();
-    queueBufferToClientLocked(buffer, currentTime);
-    return true;
-}
-
-void PreviewFrameSpacer::requestExit() {
-    // Call parent to set up shutdown
-    Thread::requestExit();
-    // Exit from other possible wait
-    mBufferCond.signal();
-}
-
-void PreviewFrameSpacer::queueBufferToClientLocked(
-        const BufferHolder& bufferHolder, nsecs_t currentTime) {
-    sp<Camera3OutputStream> parent = mParent.promote();
-    if (parent == nullptr) {
-        ALOGV("%s: Parent camera3 output stream was destroyed", __FUNCTION__);
-        return;
-    }
-
-    parent->setTransform(bufferHolder.transform, true/*mayChangeMirror*/);
-
-    status_t res = native_window_set_buffers_timestamp(mConsumer.get(), bufferHolder.timestamp);
-    if (res != OK) {
-        ALOGE("%s: Preview Stream: Error setting timestamp: %s (%d)",
-                __FUNCTION__, strerror(-res), res);
-    }
-
-    Camera3Stream::queueHDRMetadata(bufferHolder.anwBuffer.get()->handle, mConsumer,
-            parent->getDynamicRangeProfile());
-
-    res = mConsumer->queueBuffer(mConsumer.get(), bufferHolder.anwBuffer.get(),
-            bufferHolder.releaseFence);
-    if (res != OK) {
-        close(bufferHolder.releaseFence);
-        if (parent->shouldLogError(res)) {
-            ALOGE("%s: Failed to queue buffer to client: %s(%d)", __FUNCTION__,
-                    strerror(-res), res);
-        }
-    }
-
-    mLastCameraPresentTime = currentTime;
-    mLastCameraReadoutTime = bufferHolder.readoutTimestamp;
-}
-
-}; // namespace camera3
-
-}; // namespace android
diff --git a/services/camera/libcameraservice/device3/PreviewFrameSpacer.h b/services/camera/libcameraservice/device3/PreviewFrameSpacer.h
deleted file mode 100644
index e165768b97..0000000000
--- a/services/camera/libcameraservice/device3/PreviewFrameSpacer.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SERVERS_CAMERA_CAMERA3_PREVIEWFRAMESPACER_H
-#define ANDROID_SERVERS_CAMERA_CAMERA3_PREVIEWFRAMESPACER_H
-
-#include <queue>
-
-#include <gui/Surface.h>
-#include <utils/Condition.h>
-#include <utils/Mutex.h>
-#include <utils/Thread.h>
-#include <utils/Timers.h>
-
-namespace android {
-
-namespace camera3 {
-
-class Camera3OutputStream;
-
-/***
- * Preview stream spacer for better frame spacing
- *
- * The ideal viewfinder user experience is that frames are presented to the
- * user in the same cadence as outputed by the camera sensor. However, the
- * processing latency between frames could vary, due to factors such
- * as CPU load, differences in request settings, etc. This frame processing
- * latency results in variation in presentation of frames to the user.
- *
- * The PreviewFrameSpacer improves the viewfinder user experience by:
- * - Cache the frame buffers if the intervals between queueBuffer is shorter
- *   than the camera readout intervals.
- * - Queue frame buffers in the same cadence as the camera readout time.
- * - Maintain at most 1 queue-able buffer. If the 2nd preview buffer becomes
- *   available, queue the oldest cached buffer to the buffer queue.
- */
-class PreviewFrameSpacer : public Thread {
-  public:
-    explicit PreviewFrameSpacer(wp<Camera3OutputStream> parent, sp<Surface> consumer);
-    virtual ~PreviewFrameSpacer();
-
-    // Queue preview buffer locally
-    status_t queuePreviewBuffer(nsecs_t timestamp, nsecs_t readoutTimestamp,
-            int32_t transform, ANativeWindowBuffer* anwBuffer, int releaseFence);
-
-    bool threadLoop() override;
-    void requestExit() override;
-
-  private:
-    // structure holding cached preview buffer info
-    struct BufferHolder {
-        nsecs_t timestamp;
-        nsecs_t readoutTimestamp;
-        int32_t transform;
-        sp<ANativeWindowBuffer> anwBuffer;
-        int releaseFence;
-
-        BufferHolder(nsecs_t t, nsecs_t readoutT, int32_t tr, ANativeWindowBuffer* anwb, int rf) :
-                timestamp(t), readoutTimestamp(readoutT), transform(tr), anwBuffer(anwb),
-                releaseFence(rf) {}
-    };
-
-    void queueBufferToClientLocked(const BufferHolder& bufferHolder, nsecs_t currentTime);
-
-    wp<Camera3OutputStream> mParent;
-    sp<ANativeWindow> mConsumer;
-    mutable Mutex mLock;
-    Condition mBufferCond;
-
-    std::queue<BufferHolder> mPendingBuffers;
-    nsecs_t mLastCameraReadoutTime = 0;
-    nsecs_t mLastCameraPresentTime = 0;
-    static constexpr nsecs_t kWaitDuration = 5000000LL; // 50ms
-    static constexpr nsecs_t kFrameIntervalThreshold = 80000000LL; // 80ms
-    static constexpr nsecs_t kMaxFrameWaitTime = 33333333LL; // 33ms
-};
-
-}; //namespace camera3
-}; //namespace android
-
-#endif
diff --git a/services/camera/libcameraservice/device3/ZoomRatioMapper.cpp b/services/camera/libcameraservice/device3/ZoomRatioMapper.cpp
index 27b00c930e..7ec0956d1e 100644
--- a/services/camera/libcameraservice/device3/ZoomRatioMapper.cpp
+++ b/services/camera/libcameraservice/device3/ZoomRatioMapper.cpp
@@ -20,7 +20,7 @@
 #include <algorithm>
 
 #include "device3/ZoomRatioMapper.h"
-#include "utils/SessionConfigurationUtilsHost.h"
+#include "utils/SessionConfigurationUtils.h"
 
 namespace android {
 
diff --git a/services/camera/libcameraservice/device3/aidl/AidlCamera3Device.cpp b/services/camera/libcameraservice/device3/aidl/AidlCamera3Device.cpp
deleted file mode 100644
index f05520f53e..0000000000
--- a/services/camera/libcameraservice/device3/aidl/AidlCamera3Device.cpp
+++ /dev/null
@@ -1,1583 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "AidlCamera3-Device"
-#define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
-//#define LOG_NNDEBUG 0  // Per-frame verbose logging
-
-#ifdef LOG_NNDEBUG
-#define ALOGVV(...) ALOGV(__VA_ARGS__)
-#else
-#define ALOGVV(...) ((void)0)
-#endif
-
-// Convenience macro for transient errors
-#define CLOGE(fmt, ...) ALOGE("Camera %s: %s: " fmt, mId.string(), __FUNCTION__, \
-            ##__VA_ARGS__)
-
-#define CLOGW(fmt, ...) ALOGW("Camera %s: %s: " fmt, mId.string(), __FUNCTION__, \
-            ##__VA_ARGS__)
-
-// Convenience macros for transitioning to the error state
-#define SET_ERR(fmt, ...) setErrorState(   \
-    "%s: " fmt, __FUNCTION__,              \
-    ##__VA_ARGS__)
-#define SET_ERR_L(fmt, ...) setErrorStateLocked( \
-    "%s: " fmt, __FUNCTION__,                    \
-    ##__VA_ARGS__)
-
-#include <inttypes.h>
-
-#include <utility>
-
-#include <utils/Log.h>
-#include <utils/Trace.h>
-#include <utils/Timers.h>
-#include <cutils/properties.h>
-
-#include <aidl/android/hardware/camera/device/ICameraInjectionSession.h>
-#include <aidlcommonsupport/NativeHandle.h>
-#include <android/hardware/camera2/ICameraDeviceUser.h>
-
-#include "utils/CameraTraces.h"
-#include "mediautils/SchedulingPolicyService.h"
-#include "device3/Camera3OutputStream.h"
-#include "device3/Camera3InputStream.h"
-#include "device3/Camera3FakeStream.h"
-#include "device3/Camera3SharedOutputStream.h"
-#include "device3/aidl/AidlCamera3OutputUtils.h"
-#include "device3/aidl/AidlCamera3OfflineSession.h"
-#include "CameraService.h"
-#include "utils/CameraThreadState.h"
-#include "utils/SessionConfigurationUtils.h"
-#include "utils/TraceHFR.h"
-#include "utils/CameraServiceProxyWrapper.h"
-
-#include "../../common/aidl/AidlProviderInfo.h"
-
-#include <algorithm>
-
-#include "AidlCamera3Device.h"
-
-using namespace android::camera3;
-using namespace aidl::android::hardware;
-using aidl::android::hardware::camera::metadata::SensorPixelMode;
-using aidl::android::hardware::camera::metadata::RequestAvailableDynamicRangeProfilesMap;
-using aidl::android::hardware::camera::metadata::ScalerAvailableStreamUseCases;
-
-namespace android {
-
-RequestAvailableDynamicRangeProfilesMap
-mapToAidlDynamicProfile(int64_t dynamicRangeProfile) {
-    return static_cast<RequestAvailableDynamicRangeProfilesMap>(dynamicRangeProfile);
-}
-
-aidl::android::hardware::graphics::common::PixelFormat AidlCamera3Device::mapToAidlPixelFormat(
-        int frameworkFormat) {
-    return (aidl::android::hardware::graphics::common::PixelFormat) frameworkFormat;
-}
-
-aidl::android::hardware::graphics::common::Dataspace AidlCamera3Device::mapToAidlDataspace(
-        android_dataspace dataSpace) {
-    return (aidl::android::hardware::graphics::common::Dataspace)dataSpace;
-}
-
-aidl::android::hardware::graphics::common::BufferUsage AidlCamera3Device::mapToAidlConsumerUsage(
-        uint64_t usage) {
-    return (aidl::android::hardware::graphics::common::BufferUsage)usage;
-}
-
-aidl::android::hardware::camera::device::StreamRotation
-AidlCamera3Device::mapToAidlStreamRotation(camera_stream_rotation_t rotation) {
-    switch (rotation) {
-        case CAMERA_STREAM_ROTATION_0:
-            return aidl::android::hardware::camera::device::StreamRotation::ROTATION_0;
-        case CAMERA_STREAM_ROTATION_90:
-            return aidl::android::hardware::camera::device::StreamRotation::ROTATION_90;
-        case CAMERA_STREAM_ROTATION_180:
-            return aidl::android::hardware::camera::device::StreamRotation::ROTATION_180;
-        case CAMERA_STREAM_ROTATION_270:
-            return aidl::android::hardware::camera::device::StreamRotation::ROTATION_270;
-    }
-    ALOGE("%s: Unknown stream rotation %d", __FUNCTION__, rotation);
-    return aidl::android::hardware::camera::device::StreamRotation::ROTATION_0;
-}
-
-status_t AidlCamera3Device::mapToAidlStreamConfigurationMode(
-        camera_stream_configuration_mode_t operationMode,
-        aidl::android::hardware::camera::device::StreamConfigurationMode *mode) {
-    using StreamConfigurationMode =
-            aidl::android::hardware::camera::device::StreamConfigurationMode;
-    if (mode == nullptr) return BAD_VALUE;
-    if (operationMode < CAMERA_VENDOR_STREAM_CONFIGURATION_MODE_START) {
-        switch(operationMode) {
-            case CAMERA_STREAM_CONFIGURATION_NORMAL_MODE:
-                *mode = StreamConfigurationMode::NORMAL_MODE;
-                break;
-            case CAMERA_STREAM_CONFIGURATION_CONSTRAINED_HIGH_SPEED_MODE:
-                *mode = StreamConfigurationMode::CONSTRAINED_HIGH_SPEED_MODE;
-                break;
-            default:
-                ALOGE("%s: Unknown stream configuration mode %d", __FUNCTION__, operationMode);
-                return BAD_VALUE;
-        }
-    } else {
-        *mode = static_cast<StreamConfigurationMode>(operationMode);
-    }
-    return OK;
-}
-
-int AidlCamera3Device::mapToFrameworkFormat(
-        aidl::android::hardware::graphics::common::PixelFormat pixelFormat) {
-    return static_cast<uint32_t>(pixelFormat);
-}
-
-android_dataspace AidlCamera3Device::mapToFrameworkDataspace(
-        aidl::android::hardware::graphics::common::Dataspace dataSpace) {
-    return static_cast<android_dataspace>(dataSpace);
-}
-
-uint64_t AidlCamera3Device::mapConsumerToFrameworkUsage(
-        aidl::android::hardware::graphics::common::BufferUsage usage) {
-    return (uint64_t)usage;
-}
-
-uint64_t AidlCamera3Device::mapProducerToFrameworkUsage(
-       aidl::android::hardware::graphics::common::BufferUsage usage) {
-    return (uint64_t)usage;
-}
-
-AidlCamera3Device::AidlCamera3Device(const String8& id, bool overrideForPerfClass,
-            bool legacyClient) : Camera3Device(id, overrideForPerfClass, legacyClient) {
-        mCallbacks = ndk::SharedRefBase::make<AidlCameraDeviceCallbacks>(this);
-}
-
-status_t AidlCamera3Device::initialize(sp<CameraProviderManager> manager,
-        const String8& monitorTags) {
-    ATRACE_CALL();
-    Mutex::Autolock il(mInterfaceLock);
-    Mutex::Autolock l(mLock);
-
-    ALOGV("%s: Initializing AIDL device for camera %s", __FUNCTION__, mId.string());
-    if (mStatus != STATUS_UNINITIALIZED) {
-        CLOGE("Already initialized!");
-        return INVALID_OPERATION;
-    }
-    if (manager == nullptr) return INVALID_OPERATION;
-
-    std::shared_ptr<camera::device::ICameraDeviceSession> session;
-    ATRACE_BEGIN("CameraHal::openSession");
-    status_t res = manager->openAidlSession(mId.string(), mCallbacks,
-            /*out*/ &session);
-    ATRACE_END();
-    if (res != OK) {
-        SET_ERR_L("Could not open camera session: %s (%d)", strerror(-res), res);
-        return res;
-    }
-    if (session == nullptr) {
-      SET_ERR("Session iface returned is null");
-      return INVALID_OPERATION;
-    }
-    res = manager->getCameraCharacteristics(mId.string(), mOverrideForPerfClass, &mDeviceInfo);
-    if (res != OK) {
-        SET_ERR_L("Could not retrieve camera characteristics: %s (%d)", strerror(-res), res);
-        session->close();
-        return res;
-    }
-    mSupportNativeZoomRatio = manager->supportNativeZoomRatio(mId.string());
-
-    std::vector<std::string> physicalCameraIds;
-    bool isLogical = manager->isLogicalCamera(mId.string(), &physicalCameraIds);
-    if (isLogical) {
-        for (auto& physicalId : physicalCameraIds) {
-            // Do not override characteristics for physical cameras
-            res = manager->getCameraCharacteristics(
-                    physicalId, /*overrideForPerfClass*/false, &mPhysicalDeviceInfoMap[physicalId]);
-            if (res != OK) {
-                SET_ERR_L("Could not retrieve camera %s characteristics: %s (%d)",
-                        physicalId.c_str(), strerror(-res), res);
-                session->close();
-                return res;
-            }
-
-            bool usePrecorrectArray =
-                    DistortionMapper::isDistortionSupported(mPhysicalDeviceInfoMap[physicalId]);
-            if (usePrecorrectArray) {
-                res = mDistortionMappers[physicalId].setupStaticInfo(
-                        mPhysicalDeviceInfoMap[physicalId]);
-                if (res != OK) {
-                    SET_ERR_L("Unable to read camera %s's calibration fields for distortion "
-                            "correction", physicalId.c_str());
-                    session->close();
-                    return res;
-                }
-            }
-
-            mZoomRatioMappers[physicalId] = ZoomRatioMapper(
-                    &mPhysicalDeviceInfoMap[physicalId],
-                    mSupportNativeZoomRatio, usePrecorrectArray);
-
-            if (SessionConfigurationUtils::isUltraHighResolutionSensor(
-                    mPhysicalDeviceInfoMap[physicalId])) {
-                mUHRCropAndMeteringRegionMappers[physicalId] =
-                        UHRCropAndMeteringRegionMapper(mPhysicalDeviceInfoMap[physicalId],
-                                usePrecorrectArray);
-            }
-        }
-    }
-
-    std::shared_ptr<AidlRequestMetadataQueue> queue;
-    ::aidl::android::hardware::common::fmq::MQDescriptor<
-            int8_t, ::aidl::android::hardware::common::fmq::SynchronizedReadWrite> desc;
-
-    ::ndk::ScopedAStatus requestQueueRet = session->getCaptureRequestMetadataQueue(&desc);
-    if (!requestQueueRet.isOk()) {
-        ALOGE("Transaction error when getting result metadata queue from camera session: %s",
-                requestQueueRet.getMessage());
-        return AidlProviderInfo::mapToStatusT(requestQueueRet);
-    }
-    queue = std::make_unique<AidlRequestMetadataQueue>(desc);
-    if (!queue->isValid() || queue->availableToWrite() <= 0) {
-        ALOGE("HAL returns empty result metadata fmq, not use it");
-        queue = nullptr;
-        // Don't use resQueue onwards.
-    }
-
-    std::unique_ptr<AidlResultMetadataQueue>& resQueue = mResultMetadataQueue;
-    ::aidl::android::hardware::common::fmq::MQDescriptor<
-        int8_t, ::aidl::android::hardware::common::fmq::SynchronizedReadWrite> resDesc;
-    ::ndk::ScopedAStatus resultQueueRet = session->getCaptureResultMetadataQueue(&resDesc);
-    if (!resultQueueRet.isOk()) {
-        ALOGE("Transaction error when getting result metadata queue from camera session: %s",
-                resultQueueRet.getMessage());
-        return AidlProviderInfo::mapToStatusT(resultQueueRet);
-    }
-    resQueue = std::make_unique<AidlResultMetadataQueue>(resDesc);
-    if (!resQueue->isValid() || resQueue->availableToWrite() <= 0) {
-        ALOGE("HAL returns empty result metadata fmq, not use it");
-        resQueue = nullptr;
-        // Don't use resQueue onwards.
-    }
-
-    camera_metadata_entry bufMgrMode =
-            mDeviceInfo.find(ANDROID_INFO_SUPPORTED_BUFFER_MANAGEMENT_VERSION);
-    if (bufMgrMode.count > 0) {
-        mUseHalBufManager = (bufMgrMode.data.u8[0] ==
-                ANDROID_INFO_SUPPORTED_BUFFER_MANAGEMENT_VERSION_HIDL_DEVICE_3_5);
-    }
-
-    camera_metadata_entry_t capabilities = mDeviceInfo.find(ANDROID_REQUEST_AVAILABLE_CAPABILITIES);
-    for (size_t i = 0; i < capabilities.count; i++) {
-        uint8_t capability = capabilities.data.u8[i];
-        if (capability == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_OFFLINE_PROCESSING) {
-            mSupportOfflineProcessing = true;
-        }
-    }
-
-    mInterface = new AidlHalInterface(session, queue, mUseHalBufManager, mSupportOfflineProcessing);
-
-    std::string providerType;
-    mVendorTagId = manager->getProviderTagIdLocked(mId.string());
-    mTagMonitor.initialize(mVendorTagId);
-    if (!monitorTags.isEmpty()) {
-        mTagMonitor.parseTagsToMonitor(String8(monitorTags));
-    }
-
-    for (size_t i = 0; i < capabilities.count; i++) {
-        uint8_t capability = capabilities.data.u8[i];
-        if (capability == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME) {
-            mNeedFixupMonochromeTags = true;
-        }
-    }
-
-    return initializeCommonLocked();
-}
-
-::ndk::ScopedAStatus AidlCamera3Device::AidlCameraDeviceCallbacks::processCaptureResult(
-            const std::vector<camera::device::CaptureResult>& results) {
-    sp<AidlCamera3Device> p = mParent.promote();
-    if (p == nullptr) {
-        ALOGE("%s Parent AidlCameraDevice not alive, can't process callbacks", __FUNCTION__);
-        return ::ndk::ScopedAStatus::ok();
-    }
-    return p->processCaptureResult(results);
-}
-
-::ndk::ScopedAStatus AidlCamera3Device::AidlCameraDeviceCallbacks::notify(
-        const std::vector<camera::device::NotifyMsg>& msgs) {
-    sp<AidlCamera3Device> p = mParent.promote();
-    if (p == nullptr) {
-        ALOGE("%s Parent AidlCameraDevice not alive, can't process callbacks", __FUNCTION__);
-        return ::ndk::ScopedAStatus::ok();
-    }
-    return p->notify(msgs);
-}
-
-::ndk::ScopedAStatus AidlCamera3Device::processCaptureResult(
-            const std::vector<camera::device::CaptureResult>& results) {
-    // Ideally we should grab mLock, but that can lead to deadlock, and
-    // it's not super important to get up to date value of mStatus for this
-    // warning print, hence skipping the lock here
-    if (mStatus == STATUS_ERROR) {
-        // Per API contract, HAL should act as closed after device error
-        // But mStatus can be set to error by framework as well, so just log
-        // a warning here.
-        ALOGW("%s: received capture result in error state.", __FUNCTION__);
-    }
-
-    sp<NotificationListener> listener;
-    {
-        std::lock_guard<std::mutex> l(mOutputLock);
-        listener = mListener.promote();
-    }
-
-    if (mProcessCaptureResultLock.tryLock() != OK) {
-        // This should never happen; it indicates a wrong client implementation
-        // that doesn't follow the contract. But, we can be tolerant here.
-        ALOGE("%s: callback overlapped! waiting 1s...",
-                __FUNCTION__);
-        if (mProcessCaptureResultLock.timedLock(1000000000 /* 1s */) != OK) {
-            ALOGE("%s: cannot acquire lock in 1s, dropping results",
-                    __FUNCTION__);
-            // really don't know what to do, so bail out.
-            return ::ndk::ScopedAStatus::ok();
-        }
-    }
-    AidlCaptureOutputStates states {
-       {
-        mId,
-        mInFlightLock, mLastCompletedRegularFrameNumber,
-        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
-        mInFlightMap, mOutputLock, mResultQueue, mResultSignal,
-        mNextShutterFrameNumber,
-        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
-        mNextResultFrameNumber,
-        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
-        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
-        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
-        mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
-        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this,
-        *this, *(mInterface), mLegacyClient, mMinExpectedDuration}, mResultMetadataQueue
-    };
-
-    for (const auto& result : results) {
-        processOneCaptureResultLocked(states, result, result.physicalCameraMetadata);
-    }
-    mProcessCaptureResultLock.unlock();
-    return ::ndk::ScopedAStatus::ok();
-}
-
-::ndk::ScopedAStatus AidlCamera3Device::notify(
-        const std::vector<camera::device::NotifyMsg>& msgs) {
-    // Ideally we should grab mLock, but that can lead to deadlock, and
-    // it's not super important to get up to date value of mStatus for this
-    // warning print, hence skipping the lock here
-    if (mStatus == STATUS_ERROR) {
-        // Per API contract, HAL should act as closed after device error
-        // But mStatus can be set to error by framework as well, so just log
-        // a warning here.
-        ALOGW("%s: received notify message in error state.", __FUNCTION__);
-    }
-
-    sp<NotificationListener> listener;
-    {
-        std::lock_guard<std::mutex> l(mOutputLock);
-        listener = mListener.promote();
-    }
-
-    AidlCaptureOutputStates states {
-      { mId,
-        mInFlightLock, mLastCompletedRegularFrameNumber,
-        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
-        mInFlightMap, mOutputLock, mResultQueue, mResultSignal,
-        mNextShutterFrameNumber,
-        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
-        mNextResultFrameNumber,
-        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
-        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
-        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
-        mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
-        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this,
-        *this, *(mInterface), mLegacyClient, mMinExpectedDuration}, mResultMetadataQueue
-    };
-    for (const auto& msg : msgs) {
-        camera3::notify(states, msg);
-    }
-    return ::ndk::ScopedAStatus::ok();
-
-}
-
-status_t AidlCamera3Device::switchToOffline(
-        const std::vector<int32_t>& streamsToKeep,
-        /*out*/ sp<CameraOfflineSessionBase>* session) {
-    ATRACE_CALL();
-    if (session == nullptr) {
-        ALOGE("%s: session must not be null", __FUNCTION__);
-        return BAD_VALUE;
-    }
-
-    Mutex::Autolock il(mInterfaceLock);
-
-    bool hasInputStream = mInputStream != nullptr;
-    int32_t inputStreamId = hasInputStream ? mInputStream->getId() : -1;
-    bool inputStreamSupportsOffline = hasInputStream ?
-            mInputStream->getOfflineProcessingSupport() : false;
-    auto outputStreamIds = mOutputStreams.getStreamIds();
-    auto streamIds = outputStreamIds;
-    if (hasInputStream) {
-        streamIds.push_back(mInputStream->getId());
-    }
-
-    // Check all streams in streamsToKeep supports offline mode
-    for (auto id : streamsToKeep) {
-        if (std::find(streamIds.begin(), streamIds.end(), id) == streamIds.end()) {
-            ALOGE("%s: Unknown stream ID %d", __FUNCTION__, id);
-            return BAD_VALUE;
-        } else if (id == inputStreamId) {
-            if (!inputStreamSupportsOffline) {
-                ALOGE("%s: input stream %d cannot be switched to offline",
-                        __FUNCTION__, id);
-                return BAD_VALUE;
-            }
-        } else {
-            sp<camera3::Camera3OutputStreamInterface> stream = mOutputStreams.get(id);
-            if (!stream->getOfflineProcessingSupport()) {
-                ALOGE("%s: output stream %d cannot be switched to offline",
-                        __FUNCTION__, id);
-                return BAD_VALUE;
-            }
-        }
-    }
-    // TODO: block surface sharing and surface group streams until we can support them
-
-    // Stop repeating request, wait until all remaining requests are submitted, then call into
-    // HAL switchToOffline
-    camera::device::CameraOfflineSessionInfo offlineSessionInfo;
-    std::shared_ptr<camera::device::ICameraOfflineSession> offlineSession;
-    camera3::BufferRecords bufferRecords;
-    status_t ret = static_cast<AidlRequestThread *>(mRequestThread.get())->switchToOffline(
-            streamsToKeep, &offlineSessionInfo, &offlineSession, &bufferRecords);
-
-    if (ret != OK) {
-        SET_ERR("Switch to offline failed: %s (%d)", strerror(-ret), ret);
-        return ret;
-    }
-
-    bool succ = mRequestBufferSM.onSwitchToOfflineSuccess();
-    if (!succ) {
-        SET_ERR("HAL must not be calling requestStreamBuffers call");
-        // TODO: block ALL callbacks from HAL till app configured new streams?
-        return UNKNOWN_ERROR;
-    }
-
-    // Verify offlineSessionInfo
-    std::vector<int32_t> offlineStreamIds;
-    offlineStreamIds.reserve(offlineSessionInfo.offlineStreams.size());
-    for (auto offlineStream : offlineSessionInfo.offlineStreams) {
-        // verify stream IDs
-        int32_t id = offlineStream.id;
-        if (std::find(streamIds.begin(), streamIds.end(), id) == streamIds.end()) {
-            SET_ERR("stream ID %d not found!", id);
-            return UNKNOWN_ERROR;
-        }
-
-        // When not using HAL buf manager, only allow streams requested by app to be preserved
-        if (!mUseHalBufManager) {
-            if (std::find(streamsToKeep.begin(), streamsToKeep.end(), id) == streamsToKeep.end()) {
-                SET_ERR("stream ID %d must not be switched to offline!", id);
-                return UNKNOWN_ERROR;
-            }
-        }
-
-        offlineStreamIds.push_back(id);
-        sp<Camera3StreamInterface> stream = (id == inputStreamId) ?
-                static_cast<sp<Camera3StreamInterface>>(mInputStream) :
-                static_cast<sp<Camera3StreamInterface>>(mOutputStreams.get(id));
-        // Verify number of outstanding buffers
-        if (stream->getOutstandingBuffersCount() != (uint32_t)offlineStream.numOutstandingBuffers) {
-            SET_ERR("Offline stream %d # of remaining buffer mismatch: (%zu,%d) (service/HAL)",
-                    id, stream->getOutstandingBuffersCount(), offlineStream.numOutstandingBuffers);
-            return UNKNOWN_ERROR;
-        }
-    }
-
-    // Verify all streams to be deleted don't have any outstanding buffers
-    if (hasInputStream && std::find(offlineStreamIds.begin(), offlineStreamIds.end(),
-                inputStreamId) == offlineStreamIds.end()) {
-        if (mInputStream->hasOutstandingBuffers()) {
-            SET_ERR("Input stream %d still has %zu outstanding buffer!",
-                    inputStreamId, mInputStream->getOutstandingBuffersCount());
-            return UNKNOWN_ERROR;
-        }
-    }
-
-    for (const auto& outStreamId : outputStreamIds) {
-        if (std::find(offlineStreamIds.begin(), offlineStreamIds.end(),
-                outStreamId) == offlineStreamIds.end()) {
-            auto outStream = mOutputStreams.get(outStreamId);
-            if (outStream->hasOutstandingBuffers()) {
-                SET_ERR("Output stream %d still has %zu outstanding buffer!",
-                        outStreamId, outStream->getOutstandingBuffersCount());
-                return UNKNOWN_ERROR;
-            }
-        }
-    }
-
-    InFlightRequestMap offlineReqs;
-    // Verify inflight requests and their pending buffers
-    {
-        std::lock_guard<std::mutex> l(mInFlightLock);
-        for (auto offlineReq : offlineSessionInfo.offlineRequests) {
-            int idx = mInFlightMap.indexOfKey(offlineReq.frameNumber);
-            if (idx == NAME_NOT_FOUND) {
-                SET_ERR("Offline request frame number %d not found!", offlineReq.frameNumber);
-                return UNKNOWN_ERROR;
-            }
-
-            const auto& inflightReq = mInFlightMap.valueAt(idx);
-            // TODO: check specific stream IDs
-            size_t numBuffersLeft = static_cast<size_t>(inflightReq.numBuffersLeft);
-            if (numBuffersLeft != offlineReq.pendingStreams.size()) {
-                SET_ERR("Offline request # of remaining buffer mismatch: (%d,%d) (service/HAL)",
-                        inflightReq.numBuffersLeft, offlineReq.pendingStreams.size());
-                return UNKNOWN_ERROR;
-            }
-            offlineReqs.add(offlineReq.frameNumber, inflightReq);
-        }
-    }
-
-    // Create Camera3OfflineSession and transfer object ownership
-    //   (streams, inflight requests, buffer caches)
-    camera3::StreamSet offlineStreamSet;
-    sp<camera3::Camera3Stream> inputStream;
-    for (auto offlineStream : offlineSessionInfo.offlineStreams) {
-        int32_t id = offlineStream.id;
-        if (mInputStream != nullptr && id == mInputStream->getId()) {
-            inputStream = mInputStream;
-        } else {
-            offlineStreamSet.add(id, mOutputStreams.get(id));
-        }
-    }
-
-    // TODO: check if we need to lock before copying states
-    //       though technically no other thread should be talking to Camera3Device at this point
-    Camera3OfflineStates offlineStates(
-            mTagMonitor, mVendorTagId, mUseHalBufManager, mNeedFixupMonochromeTags,
-            mUsePartialResult, mNumPartialResults, mLastCompletedRegularFrameNumber,
-            mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
-            mNextResultFrameNumber, mNextReprocessResultFrameNumber,
-            mNextZslStillResultFrameNumber, mNextShutterFrameNumber,
-            mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
-            mDeviceInfo, mPhysicalDeviceInfoMap, mDistortionMappers,
-            mZoomRatioMappers, mRotateAndCropMappers);
-
-    *session = new AidlCamera3OfflineSession(mId, inputStream, offlineStreamSet,
-            std::move(bufferRecords), offlineReqs, offlineStates, offlineSession);
-
-    // Delete all streams that has been transferred to offline session
-    Mutex::Autolock l(mLock);
-    for (auto offlineStream : offlineSessionInfo.offlineStreams) {
-        int32_t id = offlineStream.id;
-        if (mInputStream != nullptr && id == mInputStream->getId()) {
-            mInputStream.clear();
-        } else {
-            mOutputStreams.remove(id);
-        }
-    }
-
-    // disconnect all other streams and switch to UNCONFIGURED state
-    if (mInputStream != nullptr) {
-        ret = mInputStream->disconnect();
-        if (ret != OK) {
-            SET_ERR_L("disconnect input stream failed!");
-            return UNKNOWN_ERROR;
-        }
-    }
-
-    for (auto streamId : mOutputStreams.getStreamIds()) {
-        sp<Camera3StreamInterface> stream = mOutputStreams.get(streamId);
-        ret = stream->disconnect();
-        if (ret != OK) {
-            SET_ERR_L("disconnect output stream %d failed!", streamId);
-            return UNKNOWN_ERROR;
-        }
-    }
-
-    mInputStream.clear();
-    mOutputStreams.clear();
-    mNeedConfig = true;
-    internalUpdateStatusLocked(STATUS_UNCONFIGURED);
-    mOperatingMode = NO_MODE;
-    mIsConstrainedHighSpeedConfiguration = false;
-    mRequestThread->clearPreviousRequest();
-
-    return OK;
-    // TO be done by CameraDeviceClient/Camera3OfflineSession
-    // register the offline client to camera service
-    // Setup result passthing threads etc
-    // Initialize offline session so HAL can start sending callback to it (result Fmq)
-    // TODO: check how many onIdle callback will be sent
-    // Java side to make sure the CameraCaptureSession is properly closed
-}
-
-::ndk::ScopedAStatus AidlCamera3Device::AidlCameraDeviceCallbacks::requestStreamBuffers(
-        const std::vector<camera::device::BufferRequest>& bufReqs,
-        std::vector<aidl::android::hardware::camera::device::StreamBufferRet>* outBuffers,
-        aidl::android::hardware::camera::device::BufferRequestStatus* status) {
-
-    sp<AidlCamera3Device> p = mParent.promote();
-    if (p == nullptr) {
-        ALOGE("%s Parent AidlCameraDevice not alive, can't process callbacks", __FUNCTION__);
-        return ::ndk::ScopedAStatus::ok();
-    }
-    return p->requestStreamBuffers(bufReqs, outBuffers, status);
-}
-
-::ndk::ScopedAStatus AidlCamera3Device::requestStreamBuffers(
-        const std::vector<camera::device::BufferRequest>& bufReqs,
-        std::vector<aidl::android::hardware::camera::device::StreamBufferRet>* outBuffers,
-        aidl::android::hardware::camera::device::BufferRequestStatus* status) {
-
-    RequestBufferStates states {
-        mId, mRequestBufferInterfaceLock, mUseHalBufManager, mOutputStreams,
-        mSessionStatsBuilder, *this, *(mInterface), *this};
-    camera3::requestStreamBuffers(states, bufReqs, outBuffers, status);
-    return ::ndk::ScopedAStatus::ok();
-}
-
-::ndk::ScopedAStatus AidlCamera3Device::AidlCameraDeviceCallbacks::returnStreamBuffers(
-        const std::vector<camera::device::StreamBuffer>& buffers) {
-    sp<AidlCamera3Device> p = mParent.promote();
-    if (p == nullptr) {
-        ALOGE("%s Parent AidlCameraDevice not alive, can't process callbacks", __FUNCTION__);
-        return ::ndk::ScopedAStatus::ok();
-    }
-    return p->returnStreamBuffers(buffers);
-}
-
-::ndk::ScopedAStatus AidlCamera3Device::returnStreamBuffers(
-        const std::vector<camera::device::StreamBuffer>& buffers) {
-    ReturnBufferStates states {
-        mId, mUseHalBufManager, mOutputStreams,  mSessionStatsBuilder,
-        *(mInterface)};
-    camera3::returnStreamBuffers(states, buffers);
-    return ::ndk::ScopedAStatus::ok();
-}
-
-AidlCamera3Device::AidlHalInterface::AidlHalInterface(
-            std::shared_ptr<aidl::android::hardware::camera::device::ICameraDeviceSession> &session,
-            std::shared_ptr<AidlRequestMetadataQueue> queue,
-            bool useHalBufManager, bool supportOfflineProcessing) :
-        HalInterface(useHalBufManager, supportOfflineProcessing),
-        mAidlSession(session),
-        mRequestMetadataQueue(queue) { }
-
-AidlCamera3Device::AidlHalInterface::AidlHalInterface(
-            std::shared_ptr<aidl::android::hardware::camera::device::ICameraDeviceSession>
-                    &deviceSession,
-            std::shared_ptr<aidl::android::hardware::camera::device::ICameraInjectionSession>
-                    &injectionSession, std::shared_ptr<AidlRequestMetadataQueue> queue,
-            bool useHalBufManager, bool supportOfflineProcessing) :
-        HalInterface(useHalBufManager, supportOfflineProcessing),
-        mAidlSession(deviceSession),
-        mAidlInjectionSession(injectionSession),
-        mRequestMetadataQueue(queue) { }
-
-bool AidlCamera3Device::AidlHalInterface::valid() {
-    return (mAidlSession != nullptr);
-}
-
-void AidlCamera3Device::AidlHalInterface::clear() {
-    mAidlSession.reset();
-}
-
-status_t AidlCamera3Device::AidlHalInterface::flush() {
-    ATRACE_NAME("CameraHal::flush");
-    if (!valid()) return INVALID_OPERATION;
-    status_t res = OK;
-
-    auto err = mAidlSession->flush();
-    if (!err.isOk()) {
-        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.getMessage());
-        res = AidlProviderInfo::mapToStatusT(err);
-    }
-
-    return res;
-}
-
-status_t AidlCamera3Device::AidlHalInterface::dump(int /*fd*/) {
-    ATRACE_NAME("CameraHal::dump");
-    if (!valid()) return INVALID_OPERATION;
-
-    // Handled by CameraProviderManager::dump
-
-    return OK;
-}
-
-status_t AidlCamera3Device::AidlHalInterface::repeatingRequestEnd(uint32_t frameNumber,
-        const std::vector<int32_t> &streamIds) {
-    ATRACE_NAME("AidlCameraHal::repeatingRequestEnd");
-    if (!valid()) return INVALID_OPERATION;
-
-    auto err = mAidlSession->repeatingRequestEnd(frameNumber, streamIds);
-    if (!err.isOk()) {
-        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.getMessage());
-        return AidlProviderInfo::mapToStatusT(err);
-    }
-
-    return OK;
-}
-
-status_t AidlCamera3Device::AidlHalInterface::close() {
-    ATRACE_NAME("CameraHal::close()");
-    if (!valid()) return INVALID_OPERATION;
-    status_t res = OK;
-
-    auto err = mAidlSession->close();
-    // Interface will be dead shortly anyway, so don't log errors
-    if (!err.isOk()) {
-        res = DEAD_OBJECT;
-    }
-
-    return res;
-}
-
-void AidlCamera3Device::AidlHalInterface::signalPipelineDrain(const std::vector<int>& streamIds) {
-    ATRACE_NAME("CameraHal::signalPipelineDrain");
-    if (!valid()) {
-        ALOGE("%s called on invalid camera!", __FUNCTION__);
-        return;
-    }
-
-    auto err = mAidlSession->signalStreamFlush(streamIds, mNextStreamConfigCounter - 1);
-    if (!err.isOk()) {
-        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.getMessage());
-        return;
-    }
-}
-
-bool AidlCamera3Device::AidlHalInterface::isReconfigurationRequired(
-        CameraMetadata& oldSessionParams, CameraMetadata& newSessionParams) {
-    // We do reconfiguration by default;
-    bool required = true;
-    if (mIsReconfigurationQuerySupported) {
-        aidl::android::hardware::camera::device::CameraMetadata oldParams, newParams;
-        camera_metadata_t* oldSessionMeta = const_cast<camera_metadata_t*>(
-                oldSessionParams.getAndLock());
-        uint8_t *oldSessionByteP = reinterpret_cast<uint8_t*>(oldSessionMeta);
-
-        camera_metadata_t* newSessionMeta = const_cast<camera_metadata_t*>(
-                newSessionParams.getAndLock());
-        uint8_t *newSessionByteP = reinterpret_cast<uint8_t*>(newSessionMeta);
-        // std::vector has no setToExternal, so we hacve to copy
-        oldParams.metadata.assign(oldSessionByteP,
-                oldSessionByteP + get_camera_metadata_size(oldSessionMeta));
-        newParams.metadata.assign(newSessionByteP,
-                newSessionByteP + get_camera_metadata_size(newSessionMeta));
-        auto err = mAidlSession->isReconfigurationRequired(oldParams, newParams, &required);
-        oldSessionParams.unlock(oldSessionMeta);
-        newSessionParams.unlock(newSessionMeta);
-        if (!err.isOk()) {
-            ALOGE("%s: Unexpected binder error: %s", __FUNCTION__, err.getMessage());
-            return true;
-        }
-    }
-
-    return required;
-}
-
-status_t AidlCamera3Device::AidlHalInterface::constructDefaultRequestSettings(
-        camera_request_template_t templateId,
-        /*out*/ camera_metadata_t **requestTemplate) {
-    ATRACE_NAME("CameraAidlHal::constructDefaultRequestSettings");
-    using aidl::android::hardware::camera::device::RequestTemplate;
-    if (!valid()) return INVALID_OPERATION;
-    status_t res = OK;
-
-    RequestTemplate id;
-    aidl::android::hardware::camera::device::CameraMetadata request;
-    switch (templateId) {
-        case CAMERA_TEMPLATE_PREVIEW:
-            id = RequestTemplate::PREVIEW;
-            break;
-        case CAMERA_TEMPLATE_STILL_CAPTURE:
-            id = RequestTemplate::STILL_CAPTURE;
-            break;
-        case CAMERA_TEMPLATE_VIDEO_RECORD:
-            id = RequestTemplate::VIDEO_RECORD;
-            break;
-        case CAMERA_TEMPLATE_VIDEO_SNAPSHOT:
-            id = RequestTemplate::VIDEO_SNAPSHOT;
-            break;
-        case CAMERA_TEMPLATE_ZERO_SHUTTER_LAG:
-            id = RequestTemplate::ZERO_SHUTTER_LAG;
-            break;
-        case CAMERA_TEMPLATE_MANUAL:
-            id = RequestTemplate::MANUAL;
-            break;
-        default:
-            // Unknown template ID, or this HAL is too old to support it
-            return BAD_VALUE;
-    }
-    auto err = mAidlSession->constructDefaultRequestSettings(id, &request);
-
-    if (!err.isOk()) {
-        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.getMessage());
-        return AidlProviderInfo::mapToStatusT(err);
-    }
-    const camera_metadata *r =
-            reinterpret_cast<const camera_metadata_t*>(request.metadata.data());
-    size_t expectedSize = request.metadata.size();
-    int ret = validate_camera_metadata_structure(r, &expectedSize);
-    if (ret == OK || ret == CAMERA_METADATA_VALIDATION_SHIFTED) {
-        *requestTemplate = clone_camera_metadata(r);
-        if (*requestTemplate == nullptr) {
-            ALOGE("%s: Unable to clone camera metadata received from HAL",
-                    __FUNCTION__);
-            res = UNKNOWN_ERROR;
-        }
-    } else {
-        ALOGE("%s: Malformed camera metadata received from HAL", __FUNCTION__);
-        res = UNKNOWN_ERROR;
-    }
-
-    return res;
-}
-
-status_t AidlCamera3Device::AidlHalInterface::configureStreams(
-    const camera_metadata_t *sessionParams,
-        camera_stream_configuration *config, const std::vector<uint32_t>& bufferSizes) {
-    using camera::device::StreamType;
-    using camera::device::StreamConfigurationMode;
-
-    ATRACE_NAME("CameraHal::configureStreams");
-    if (!valid()) return INVALID_OPERATION;
-    status_t res = OK;
-
-    // Convert stream config to AIDL
-    std::set<int> activeStreams;
-    camera::device::StreamConfiguration requestedConfiguration;
-    requestedConfiguration.streams.resize(config->num_streams);
-    for (size_t i = 0; i < config->num_streams; i++) {
-        camera::device::Stream &dst = requestedConfiguration.streams[i];
-        camera3::camera_stream_t *src = config->streams[i];
-
-        Camera3Stream* cam3stream = Camera3Stream::cast(src);
-        cam3stream->setBufferFreedListener(this);
-        int streamId = cam3stream->getId();
-        StreamType streamType;
-        switch (src->stream_type) {
-            case CAMERA_STREAM_OUTPUT:
-                streamType = StreamType::OUTPUT;
-                break;
-            case CAMERA_STREAM_INPUT:
-                streamType = StreamType::INPUT;
-                break;
-            default:
-                ALOGE("%s: Stream %d: Unsupported stream type %d",
-                        __FUNCTION__, streamId, config->streams[i]->stream_type);
-                return BAD_VALUE;
-        }
-        dst.id = streamId;
-        dst.streamType = streamType;
-        dst.width = src->width;
-        dst.height = src->height;
-        dst.usage = mapToAidlConsumerUsage(cam3stream->getUsage());
-        dst.rotation = mapToAidlStreamRotation((camera_stream_rotation_t) src->rotation);
-        dst.format = mapToAidlPixelFormat(cam3stream->isFormatOverridden() ?
-                    cam3stream->getOriginalFormat() : src->format);
-        dst.dataSpace = mapToAidlDataspace(cam3stream->isDataSpaceOverridden() ?
-                    cam3stream->getOriginalDataSpace() : src->data_space);
-
-        dst.bufferSize = bufferSizes[i];
-        if (src->physical_camera_id != nullptr) {
-            dst.physicalCameraId = src->physical_camera_id;
-        }
-        dst.groupId = cam3stream->getHalStreamGroupId();
-        dst.sensorPixelModesUsed.resize(src->sensor_pixel_modes_used.size());
-        size_t j = 0;
-        for (int mode : src->sensor_pixel_modes_used) {
-            dst.sensorPixelModesUsed[j++] = static_cast<SensorPixelMode>(mode);
-        }
-        dst.dynamicRangeProfile = mapToAidlDynamicProfile(src->dynamic_range_profile);
-        dst.useCase = static_cast<ScalerAvailableStreamUseCases>(src->use_case);
-        activeStreams.insert(streamId);
-        // Create Buffer ID map if necessary
-        mBufferRecords.tryCreateBufferCache(streamId);
-    }
-    // remove BufferIdMap for deleted streams
-    mBufferRecords.removeInactiveBufferCaches(activeStreams);
-
-    StreamConfigurationMode operationMode;
-    res = mapToAidlStreamConfigurationMode(
-            (camera_stream_configuration_mode_t) config->operation_mode,
-            /*out*/ &operationMode);
-    if (res != OK) {
-        return res;
-    }
-    requestedConfiguration.operationMode = operationMode;
-    size_t sessionParamSize = get_camera_metadata_size(sessionParams);
-    uint8_t *sessionParamP =
-            reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(sessionParams));
-
-    // std::vector has no setToExternal, so we have to copy
-    requestedConfiguration.sessionParams.metadata.assign(
-                sessionParamP, sessionParamP + sessionParamSize);
-    requestedConfiguration.operationMode = operationMode;
-
-    // Invoke configureStreams
-    std::vector<camera::device::HalStream> finalConfiguration;
-
-    requestedConfiguration.streamConfigCounter = mNextStreamConfigCounter++;
-    requestedConfiguration.multiResolutionInputImage = config->input_is_multi_resolution;
-    auto err = mAidlSession->configureStreams(requestedConfiguration, &finalConfiguration);
-    if (!err.isOk()) {
-        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.getMessage());
-        return AidlProviderInfo::mapToStatusT(err);
-    }
-
-    // And convert output stream configuration from AIDL
-
-    for (size_t i = 0; i < config->num_streams; i++) {
-        camera3::camera_stream_t *dst = config->streams[i];
-        int streamId = Camera3Stream::cast(dst)->getId();
-
-        // Start scan at i, with the assumption that the stream order matches
-        size_t realIdx = i;
-        bool found = false;
-        size_t halStreamCount = finalConfiguration.size();
-        for (size_t idx = 0; idx < halStreamCount; idx++) {
-            if (finalConfiguration[realIdx].id == streamId) {
-                found = true;
-                break;
-            }
-            realIdx = (realIdx >= halStreamCount - 1) ? 0 : realIdx + 1;
-        }
-        if (!found) {
-            ALOGE("%s: Stream %d not found in stream configuration response from HAL",
-                    __FUNCTION__, streamId);
-            return INVALID_OPERATION;
-        }
-        camera::device::HalStream &src = finalConfiguration[realIdx];
-
-        Camera3Stream* dstStream = Camera3Stream::cast(dst);
-        int overrideFormat = mapToFrameworkFormat(src.overrideFormat);
-        android_dataspace overrideDataSpace = mapToFrameworkDataspace(src.overrideDataSpace);
-
-        dstStream->setOfflineProcessingSupport(src.supportOffline);
-
-        if (dstStream->getOriginalFormat() != HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED) {
-            dstStream->setFormatOverride(false);
-            dstStream->setDataSpaceOverride(false);
-            if (dst->format != overrideFormat) {
-                ALOGE("%s: Stream %d: Format override not allowed for format 0x%x", __FUNCTION__,
-                        streamId, dst->format);
-            }
-            if (dst->data_space != overrideDataSpace) {
-                ALOGE("%s: Stream %d: DataSpace override not allowed for format 0x%x", __FUNCTION__,
-                        streamId, dst->format);
-            }
-        } else {
-            bool needFormatOverride =
-                    requestedConfiguration.streams[i].format != src.overrideFormat;
-            bool needDataspaceOverride =
-                    requestedConfiguration.streams[i].dataSpace != src.overrideDataSpace;
-            // Override allowed with IMPLEMENTATION_DEFINED
-            dstStream->setFormatOverride(needFormatOverride);
-            dstStream->setDataSpaceOverride(needDataspaceOverride);
-            dst->format = overrideFormat;
-            dst->data_space = overrideDataSpace;
-        }
-
-        if (dst->stream_type == CAMERA_STREAM_INPUT) {
-            if (static_cast<int64_t>(src.producerUsage) != 0) {
-                ALOGE("%s: Stream %d: INPUT streams must have 0 for producer usage",
-                        __FUNCTION__, streamId);
-                return INVALID_OPERATION;
-            }
-            dstStream->setUsage(
-                    mapConsumerToFrameworkUsage(src.consumerUsage));
-        } else {
-            // OUTPUT
-            if (static_cast<int64_t>(src.consumerUsage) != 0) {
-                ALOGE("%s: Stream %d: OUTPUT streams must have 0 for consumer usage",
-                        __FUNCTION__, streamId);
-                return INVALID_OPERATION;
-            }
-            dstStream->setUsage(
-                    mapProducerToFrameworkUsage(src.producerUsage));
-        }
-        dst->max_buffers = src.maxBuffers;
-    }
-
-    return res;
-}
-
-status_t AidlCamera3Device::AidlHalInterface::configureInjectedStreams(
-        const camera_metadata_t* sessionParams, camera_stream_configuration* config,
-        const std::vector<uint32_t>& bufferSizes,
-        const CameraMetadata& cameraCharacteristics) {
-    using camera::device::StreamType;
-    using camera::device::StreamConfigurationMode;
-
-    ATRACE_NAME("InjectionCameraHal::configureStreams");
-    if (!valid()) return INVALID_OPERATION;
-    status_t res = OK;
-
-    if (config->input_is_multi_resolution) {
-        ALOGE("%s: Injection camera device doesn't support multi-resolution input "
-                "stream", __FUNCTION__);
-        return BAD_VALUE;
-    }
-
-    // Convert stream config to AIDL
-    std::set<int> activeStreams;
-    camera::device::StreamConfiguration requestedConfiguration;
-    requestedConfiguration.streams.resize(config->num_streams);
-    for (size_t i = 0; i < config->num_streams; i++) {
-        camera::device::Stream& dst = requestedConfiguration.streams[i];
-        camera3::camera_stream_t* src = config->streams[i];
-
-        Camera3Stream* cam3stream = Camera3Stream::cast(src);
-        cam3stream->setBufferFreedListener(this);
-        int streamId = cam3stream->getId();
-        StreamType streamType;
-        switch (src->stream_type) {
-            case CAMERA_STREAM_OUTPUT:
-                streamType = StreamType::OUTPUT;
-                break;
-            case CAMERA_STREAM_INPUT:
-                streamType = StreamType::INPUT;
-                break;
-            default:
-                ALOGE("%s: Stream %d: Unsupported stream type %d", __FUNCTION__,
-                        streamId, config->streams[i]->stream_type);
-            return BAD_VALUE;
-        }
-        dst.id = streamId;
-        dst.streamType = streamType;
-        dst.width = src->width;
-        dst.height = src->height;
-        dst.usage = mapToAidlConsumerUsage(cam3stream->getUsage());
-        dst.rotation = mapToAidlStreamRotation((camera_stream_rotation_t)src->rotation);
-        dst.format =
-            mapToAidlPixelFormat(cam3stream->isFormatOverridden() ? cam3stream->getOriginalFormat()
-                    : src->format);
-        dst.dataSpace =
-            mapToAidlDataspace(cam3stream->isDataSpaceOverridden() ?
-                    cam3stream->getOriginalDataSpace() : src->data_space);
-        dst.bufferSize = bufferSizes[i];
-        if (src->physical_camera_id != nullptr) {
-            dst.physicalCameraId = src->physical_camera_id;
-        }
-        dst.groupId = cam3stream->getHalStreamGroupId();
-        dst.sensorPixelModesUsed.resize(src->sensor_pixel_modes_used.size());
-        size_t j = 0;
-        for (int mode : src->sensor_pixel_modes_used) {
-            dst.sensorPixelModesUsed[j++] = static_cast<SensorPixelMode>(mode);
-        }
-        activeStreams.insert(streamId);
-        // Create Buffer ID map if necessary
-        mBufferRecords.tryCreateBufferCache(streamId);
-    }
-    // remove BufferIdMap for deleted streams
-    mBufferRecords.removeInactiveBufferCaches(activeStreams);
-
-    StreamConfigurationMode operationMode;
-    res = mapToAidlStreamConfigurationMode(
-            (camera_stream_configuration_mode_t)config->operation_mode,
-            /*out*/ &operationMode);
-    if (res != OK) {
-        return res;
-    }
-    requestedConfiguration.operationMode = operationMode;
-    size_t sessionParamSize = get_camera_metadata_size(sessionParams);
-    uint8_t *sessionParamP =
-            reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(sessionParams));
-    requestedConfiguration.operationMode = operationMode;
-    requestedConfiguration.sessionParams.metadata.assign(
-            sessionParamP, sessionParamP + sessionParamSize);
-
-    // See which version of HAL we have
-    if (mAidlInjectionSession != nullptr) {
-        requestedConfiguration.streamConfigCounter = mNextStreamConfigCounter++;
-        requestedConfiguration.multiResolutionInputImage = config->input_is_multi_resolution;
-
-        const camera_metadata_t* rawMetadata = cameraCharacteristics.getAndLock();
-        uint8_t *aidlCharsP =
-                reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(rawMetadata));
-        aidl::android::hardware::camera::device::CameraMetadata aidlChars;
-        aidlChars.metadata.assign(aidlCharsP, aidlCharsP + get_camera_metadata_size(rawMetadata));
-        cameraCharacteristics.unlock(rawMetadata);
-
-        auto err = mAidlInjectionSession->configureInjectionStreams(requestedConfiguration,
-                aidlChars);
-        if (!err.isOk()) {
-            ALOGE("%s: Transaction error: %s", __FUNCTION__, err.getMessage());
-            return AidlProviderInfo::mapToStatusT(err);
-        }
-    } else {
-        ALOGE("%s: mAidlInjectionSession == nullptr, the injection not supported ", __FUNCTION__);
-        return INVALID_OPERATION;
-   }
-
-    return res;
-}
-
-status_t AidlCamera3Device::AidlHalInterface::processBatchCaptureRequests(
-        std::vector<camera_capture_request_t*>& requests,/*out*/uint32_t* numRequestProcessed) {
-    ATRACE_NAME("CameraHal::processBatchCaptureRequests");
-    if (!valid()) return INVALID_OPERATION;
-
-    std::vector<camera::device::CaptureRequest> captureRequests;
-    size_t batchSize = requests.size();
-    if (batchSize > INT_MAX) {
-        ALOGE("%s batchSize %zu > INT_MAX, aidl interface cannot handle batch size", __FUNCTION__,
-                  batchSize);
-        return BAD_VALUE;
-    }
-    captureRequests.resize(batchSize);
-    std::vector<native_handle_t*> handlesCreated;
-    std::vector<std::pair<int32_t, int32_t>> inflightBuffers;
-
-    status_t res = OK;
-    for (size_t i = 0; i < batchSize; i++) {
-       res = wrapAsAidlRequest(requests[i], /*out*/&captureRequests[i],
-                    /*out*/&handlesCreated, /*out*/&inflightBuffers);
-
-        if (res != OK) {
-            mBufferRecords.popInflightBuffers(inflightBuffers);
-            cleanupNativeHandles(&handlesCreated);
-            return res;
-        }
-    }
-
-    std::vector<camera::device::BufferCache> cachesToRemove;
-    {
-        std::lock_guard<std::mutex> lock(mFreedBuffersLock);
-        for (auto& pair : mFreedBuffers) {
-            // The stream might have been removed since onBufferFreed
-            if (mBufferRecords.isStreamCached(pair.first)) {
-                cachesToRemove.push_back({pair.first, static_cast<int64_t>(pair.second)});
-            }
-        }
-        mFreedBuffers.clear();
-    }
-
-    *numRequestProcessed = 0;
-
-    // Write metadata to FMQ.
-    for (size_t i = 0; i < batchSize; i++) {
-        camera_capture_request_t* request = requests[i];
-        camera::device::CaptureRequest* captureRequest;
-        captureRequest = &captureRequests[i];
-
-        if (request->settings != nullptr) {
-            size_t settingsSize = get_camera_metadata_size(request->settings);
-            if (mRequestMetadataQueue != nullptr && mRequestMetadataQueue->write(
-                    reinterpret_cast<const int8_t*>(request->settings), settingsSize)) {
-                captureRequest->settings.metadata.resize(0);
-                captureRequest->fmqSettingsSize = settingsSize;
-            } else {
-                if (mRequestMetadataQueue != nullptr) {
-                    ALOGW("%s: couldn't utilize fmq, fallback to hwbinder", __FUNCTION__);
-                }
-                uint8_t *settingsP =
-                        reinterpret_cast<uint8_t*>(
-                                const_cast<camera_metadata_t*>(request->settings));
-                size_t settingsSize =  get_camera_metadata_size(request->settings);
-                captureRequest->settings.metadata.assign(settingsP, settingsP + settingsSize);
-                captureRequest->fmqSettingsSize = 0u;
-            }
-        } else {
-            // A null request settings maps to a size-0 CameraMetadata
-            captureRequest->settings.metadata.resize(0);
-            captureRequest->fmqSettingsSize = 0u;
-        }
-
-        captureRequest ->inputWidth = request->input_width;
-        captureRequest->inputHeight = request->input_height;
-
-        std::vector<camera::device::PhysicalCameraSetting>& physicalCameraSettings =
-                captureRequest->physicalCameraSettings;
-        physicalCameraSettings.resize(request->num_physcam_settings);
-        for (size_t j = 0; j < request->num_physcam_settings; j++) {
-            if (request->physcam_settings != nullptr) {
-                size_t settingsSize = get_camera_metadata_size(request->physcam_settings[j]);
-                if (mRequestMetadataQueue != nullptr && mRequestMetadataQueue->write(
-                            reinterpret_cast<const int8_t*>(request->physcam_settings[j]),
-                            settingsSize)) {
-                    physicalCameraSettings[j].settings.metadata.resize(0);
-                    physicalCameraSettings[j].fmqSettingsSize = settingsSize;
-                } else {
-                    if (mRequestMetadataQueue != nullptr) {
-                        ALOGW("%s: couldn't utilize fmq, fallback to hwbinder", __FUNCTION__);
-                    }
-                    uint8_t *physicalSettingsP =
-                            reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(
-                                    request->physcam_settings[j]));
-                    physicalCameraSettings[j].settings.metadata.assign(physicalSettingsP,
-                            physicalSettingsP + settingsSize);
-                    physicalCameraSettings[j].fmqSettingsSize = 0u;
-                }
-            } else {
-                physicalCameraSettings[j].fmqSettingsSize = 0u;
-                physicalCameraSettings[j].settings.metadata.resize(0);
-            }
-            physicalCameraSettings[j].physicalCameraId = request->physcam_id[j];
-        }
-    }
-
-    int32_t numRequests = 0;
-    auto retS = mAidlSession->processCaptureRequest(captureRequests, cachesToRemove,
-            &numRequests);
-    if (!retS.isOk()) {
-        res = AidlProviderInfo::mapToStatusT(retS);
-    }
-    if (res == OK) {
-        if (numRequests < 0) {
-            res = INVALID_OPERATION;
-        } else {
-            *numRequestProcessed = static_cast<uint32_t>(numRequests);
-        }
-
-    }
-    if (res == OK && *numRequestProcessed == batchSize) {
-        if (mAidlSession->isRemote()) {
-            // Only close acquire fence FDs when the AIDL transaction succeeds (so the FDs have been
-            // sent to camera HAL processes)
-            cleanupNativeHandles(&handlesCreated, /*closeFd*/true);
-        } else {
-            // In passthrough mode the FDs are now owned by HAL
-            cleanupNativeHandles(&handlesCreated);
-        }
-    } else {
-        ALOGE("%s Error with processCaptureRequest %s ", __FUNCTION__, retS.getMessage());
-        mBufferRecords.popInflightBuffers(inflightBuffers);
-        cleanupNativeHandles(&handlesCreated);
-    }
-    return res;
-}
-
-status_t AidlCamera3Device::AidlHalInterface::wrapAsAidlRequest(camera_capture_request_t* request,
-        /*out*/camera::device::CaptureRequest* captureRequest,
-        /*out*/std::vector<native_handle_t*>* handlesCreated,
-        /*out*/std::vector<std::pair<int32_t, int32_t>>* inflightBuffers) {
-    using camera::device::BufferStatus;
-    using camera::device::StreamBuffer;
-    ATRACE_CALL();
-    if (captureRequest == nullptr || handlesCreated == nullptr || inflightBuffers == nullptr) {
-        ALOGE("%s: captureRequest (%p), handlesCreated (%p), and inflightBuffers(%p) "
-                "must not be null", __FUNCTION__, captureRequest, handlesCreated, inflightBuffers);
-        return BAD_VALUE;
-    }
-
-    captureRequest->frameNumber = request->frame_number;
-
-    captureRequest->fmqSettingsSize = 0;
-
-    {
-        if (request->input_buffer != nullptr) {
-            int32_t streamId = Camera3Stream::cast(request->input_buffer->stream)->getId();
-            buffer_handle_t buf = *(request->input_buffer->buffer);
-            auto pair = getBufferId(buf, streamId);
-            bool isNewBuffer = pair.first;
-            uint64_t bufferId = pair.second;
-            captureRequest->inputBuffer.streamId = streamId;
-            captureRequest->inputBuffer.bufferId = bufferId;
-            captureRequest->inputBuffer.buffer =
-                    (isNewBuffer) ? camera3::dupToAidlIfNotNull(buf) :
-                            aidl::android::hardware::common::NativeHandle();
-            captureRequest->inputBuffer.status = BufferStatus::OK;
-            native_handle_t *acquireFence = nullptr;
-            if (request->input_buffer->acquire_fence != -1) {
-                acquireFence = native_handle_create(1,0);
-                acquireFence->data[0] = request->input_buffer->acquire_fence;
-                handlesCreated->push_back(acquireFence);
-            }
-            // duping here is okay, in aidl ownership is not given to aidl_handle
-            captureRequest->inputBuffer.acquireFence = camera3::dupToAidlIfNotNull(acquireFence);
-            captureRequest->inputBuffer.releaseFence =
-                    aidl::android::hardware::common::NativeHandle();
-
-            mBufferRecords.pushInflightBuffer(captureRequest->frameNumber, streamId,
-                    request->input_buffer->buffer);
-            inflightBuffers->push_back(std::make_pair(captureRequest->frameNumber, streamId));
-        } else {
-            captureRequest->inputBuffer.streamId = -1;
-            captureRequest->inputBuffer.bufferId = BUFFER_ID_NO_BUFFER;
-        }
-
-        captureRequest->outputBuffers.resize(request->num_output_buffers);
-        for (size_t i = 0; i < request->num_output_buffers; i++) {
-            const camera_stream_buffer_t *src = request->output_buffers + i;
-            StreamBuffer &dst = captureRequest->outputBuffers[i];
-            int32_t streamId = Camera3Stream::cast(src->stream)->getId();
-            if (src->buffer != nullptr) {
-                buffer_handle_t buf = *(src->buffer);
-                auto pair = getBufferId(buf, streamId);
-                bool isNewBuffer = pair.first;
-                dst.bufferId = pair.second;
-                dst.buffer = isNewBuffer ?
-                        camera3::dupToAidlIfNotNull(buf) :
-                                aidl::android::hardware::common::NativeHandle();
-                native_handle_t *acquireFence = nullptr;
-                if (src->acquire_fence != -1) {
-                    acquireFence = native_handle_create(1,0);
-                    acquireFence->data[0] = src->acquire_fence;
-                    handlesCreated->push_back(acquireFence);
-                }
-                dst.acquireFence = camera3::dupToAidlIfNotNull(acquireFence);
-            } else if (mUseHalBufManager) {
-                // HAL buffer management path
-                dst.bufferId = BUFFER_ID_NO_BUFFER;
-                dst.buffer = aidl::android::hardware::common::NativeHandle();
-                dst.acquireFence = aidl::android::hardware::common::NativeHandle();
-            } else {
-                ALOGE("%s: cannot send a null buffer in capture request!", __FUNCTION__);
-                return BAD_VALUE;
-            }
-            dst.streamId = streamId;
-            dst.status = BufferStatus::OK;
-            dst.releaseFence = aidl::android::hardware::common::NativeHandle();
-
-            // Output buffers are empty when using HAL buffer manager
-            if (!mUseHalBufManager) {
-                mBufferRecords.pushInflightBuffer(
-                        captureRequest->frameNumber, streamId, src->buffer);
-                inflightBuffers->push_back(std::make_pair(captureRequest->frameNumber, streamId));
-            }
-        }
-    }
-    return OK;
-}
-
-status_t AidlCamera3Device::AidlHalInterface::switchToOffline(
-        const std::vector<int32_t>& streamsToKeep,
-        /*out*/aidl::android::hardware::camera::device::CameraOfflineSessionInfo*
-                offlineSessionInfo,
-        /*out*/std::shared_ptr<aidl::android::hardware::camera::device::ICameraOfflineSession>*
-                offlineSession,
-        /*out*/camera3::BufferRecords* bufferRecords) {
-    ATRACE_NAME("CameraHal::switchToOffline");
-    if (!valid()) {
-        ALOGE("%s called on invalid camera!", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-
-    if (offlineSessionInfo == nullptr || offlineSession == nullptr || bufferRecords == nullptr) {
-        ALOGE("%s: output arguments must not be null!", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-
-    auto err = mAidlSession->switchToOffline(streamsToKeep, offlineSessionInfo, offlineSession);
-
-    if (!err.isOk()) {
-        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.getMessage());
-        return AidlProviderInfo::mapToStatusT(err);
-    }
-
-    return verifyBufferCaches(offlineSessionInfo, bufferRecords);
-}
-
-AidlCamera3Device::AidlRequestThread::AidlRequestThread(wp<Camera3Device> parent,
-                sp<camera3::StatusTracker> statusTracker,
-                sp<HalInterface> interface,
-                const Vector<int32_t>& sessionParamKeys,
-                bool useHalBufManager,
-                bool supportCameraMute) :
-          RequestThread(parent, statusTracker, interface, sessionParamKeys, useHalBufManager,
-                  supportCameraMute) {}
-
-status_t AidlCamera3Device::AidlRequestThread::switchToOffline(
-        const std::vector<int32_t>& streamsToKeep,
-        /*out*/camera::device::CameraOfflineSessionInfo* offlineSessionInfo,
-        /*out*/std::shared_ptr<camera::device::ICameraOfflineSession>* offlineSession,
-        /*out*/camera3::BufferRecords* bufferRecords) {
-    Mutex::Autolock l(mRequestLock);
-    clearRepeatingRequestsLocked(/*lastFrameNumber*/nullptr);
-
-    // Wait until request thread is fully stopped
-    // TBD: check if request thread is being paused by other APIs (shouldn't be)
-
-    // We could also check for mRepeatingRequests.empty(), but the API interface
-    // is serialized by Camera3Device::mInterfaceLock so no one should be able to submit any
-    // new requests during the call; hence skip that check.
-    bool queueEmpty = mNextRequests.empty() && mRequestQueue.empty();
-    while (!queueEmpty) {
-        status_t res = mRequestSubmittedSignal.waitRelative(mRequestLock, kRequestSubmitTimeout);
-        if (res == TIMED_OUT) {
-            ALOGE("%s: request thread failed to submit one request within timeout!", __FUNCTION__);
-            return res;
-        } else if (res != OK) {
-            ALOGE("%s: request thread failed to submit a request: %s (%d)!",
-                    __FUNCTION__, strerror(-res), res);
-            return res;
-        }
-        queueEmpty = mNextRequests.empty() && mRequestQueue.empty();
-    }
-    return (static_cast<AidlHalInterface *>(mInterface.get()))->switchToOffline(
-            streamsToKeep, offlineSessionInfo, offlineSession, bufferRecords);
-}
-
-status_t AidlCamera3Device::AidlCamera3DeviceInjectionMethods::injectionInitialize(
-        const String8& injectedCamId, sp<CameraProviderManager> manager,
-        const std::shared_ptr<camera::device::ICameraDeviceCallback>&callback) {
-    ATRACE_CALL();
-    Mutex::Autolock lock(mInjectionLock);
-
-    if (manager == nullptr) {
-        ALOGE("%s: manager does not exist!", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-
-    sp<Camera3Device> parent = mParent.promote();
-    if (parent == nullptr) {
-        ALOGE("%s: parent does not exist!", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-
-    if (parent->getTransportType() != IPCTransport::AIDL) {
-        ALOGE("%s Parent transport not AIDL for injected camera id %s, aborting", __FUNCTION__,
-                  injectedCamId.c_str());
-        return INVALID_OPERATION;
-    }
-    mInjectedCamId = injectedCamId;
-    std::shared_ptr<camera::device::ICameraInjectionSession> injectionSession;
-    ATRACE_BEGIN("Injection CameraHal::openSession");
-    status_t res = manager->openAidlInjectionSession(injectedCamId.string(), callback,
-                                          /*out*/ &injectionSession);
-    ATRACE_END();
-    if (res != OK) {
-        ALOGE("Injection camera could not open camera session: %s (%d)",
-                strerror(-res), res);
-        return res;
-    }
-    std::shared_ptr<camera::device::ICameraDeviceSession> deviceSession = nullptr;
-    auto ret = injectionSession->getCameraDeviceSession(&deviceSession);
-    if (!ret.isOk() || deviceSession == nullptr) {
-        ALOGE("%s Camera injection session couldn't return ICameraDeviceSession", __FUNCTION__);
-        return AidlProviderInfo::mapToStatusT(ret);
-    }
-
-    std::shared_ptr<AidlRequestMetadataQueue> queue;
-    ::aidl::android::hardware::common::fmq::MQDescriptor<
-            int8_t, ::aidl::android::hardware::common::fmq::SynchronizedReadWrite> desc;
-
-    ::ndk::ScopedAStatus requestQueueRet = deviceSession->getCaptureRequestMetadataQueue(&desc);
-    if (!requestQueueRet.isOk()) {
-        ALOGE("Injection camera transaction error when getting result metadata queue from camera"
-                " session: %s", requestQueueRet.getMessage());
-        return AidlProviderInfo::mapToStatusT(requestQueueRet);
-    }
-    queue = std::make_unique<AidlRequestMetadataQueue>(desc);
-    if (!queue->isValid() || queue->availableToWrite() <= 0) {
-        ALOGE("HAL returns empty result metadata fmq, not use it");
-        queue = nullptr;
-        // Don't use resQueue onwards.
-    }
-
-    std::unique_ptr<AidlResultMetadataQueue>& resQueue = mInjectionResultMetadataQueue;
-    ::aidl::android::hardware::common::fmq::MQDescriptor<
-        int8_t, ::aidl::android::hardware::common::fmq::SynchronizedReadWrite> resDesc;
-    ::ndk::ScopedAStatus resultQueueRet = deviceSession->getCaptureResultMetadataQueue(&resDesc);
-    if (!resultQueueRet.isOk()) {
-        ALOGE("Transaction error when getting result metadata queue from camera session: %s",
-                resultQueueRet.getMessage());
-        return AidlProviderInfo::mapToStatusT(resultQueueRet);
-    }
-    resQueue = std::make_unique<AidlResultMetadataQueue>(resDesc);
-    if (!resQueue->isValid() || resQueue->availableToWrite() <= 0) {
-        ALOGE("HAL returns empty result metadata fmq, not use it");
-        resQueue = nullptr;
-        // Don't use resQueue onwards.
-    }
-
-    ALOGV("%s: Injection camera interface = new HalInterface()", __FUNCTION__);
-
-    mInjectedCamHalInterface =
-            new AidlHalInterface(deviceSession, injectionSession, queue, parent->mUseHalBufManager,
-                       parent->mSupportOfflineProcessing);
-    if (mInjectedCamHalInterface == nullptr) {
-        ALOGE("%s: mInjectedCamHalInterface does not exist!", __FUNCTION__);
-        return DEAD_OBJECT;
-    }
-
-    return OK;
-}
-
-status_t AidlCamera3Device::AidlCamera3DeviceInjectionMethods::replaceHalInterface(
-        sp<HalInterface> newHalInterface, bool keepBackup) {
-    Mutex::Autolock lock(mInjectionLock);
-    if (newHalInterface.get() == nullptr) {
-        ALOGE("%s: The newHalInterface does not exist, to stop replacing.",
-                __FUNCTION__);
-        return DEAD_OBJECT;
-    }
-
-    sp<Camera3Device> parent = mParent.promote();
-    if (parent == nullptr) {
-        ALOGE("%s: parent does not exist!", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-    if (parent->getTransportType() != IPCTransport::AIDL ||
-            newHalInterface->getTransportType() != IPCTransport::AIDL) {
-        ALOGE("%s Parent transport not AIDL for replacing hal interface", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-
-    AidlCamera3Device *aidlParent = static_cast<AidlCamera3Device *>(parent.get());
-    if (keepBackup) {
-        if (mBackupHalInterface == nullptr) {
-            mBackupHalInterface = parent->mInterface;
-        }
-        if (mBackupResultMetadataQueue == nullptr) {
-            mBackupResultMetadataQueue = std::move(aidlParent->mResultMetadataQueue);
-            aidlParent->mResultMetadataQueue = std::move(mInjectionResultMetadataQueue);
-        }
-    } else {
-        mBackupHalInterface = nullptr;
-        aidlParent->mResultMetadataQueue = std::move(mBackupResultMetadataQueue);
-        mBackupResultMetadataQueue = nullptr;
-    }
-    parent->mInterface = newHalInterface;
-    return OK;
-}
-
-status_t AidlCamera3Device::injectionCameraInitialize(const String8 &injectedCamId,
-            sp<CameraProviderManager> manager) {
-        return (static_cast<AidlCamera3DeviceInjectionMethods *>
-                    (mInjectionMethods.get()))->injectionInitialize(injectedCamId, manager,
-                        std::shared_ptr<camera::device::ICameraDeviceCallback>(mCallbacks));
-};
-
-sp<Camera3Device::RequestThread> AidlCamera3Device::createNewRequestThread(
-                wp<Camera3Device> parent, sp<camera3::StatusTracker> statusTracker,
-                sp<Camera3Device::HalInterface> interface,
-                const Vector<int32_t>& sessionParamKeys,
-                bool useHalBufManager,
-                bool supportCameraMute) {
-    return new AidlRequestThread(parent, statusTracker, interface, sessionParamKeys,
-            useHalBufManager, supportCameraMute);
-};
-
-sp<Camera3Device::Camera3DeviceInjectionMethods>
-AidlCamera3Device::createCamera3DeviceInjectionMethods(wp<Camera3Device> parent) {
-    return new AidlCamera3DeviceInjectionMethods(parent);
-}
-
-}; // namespace android
diff --git a/services/camera/libcameraservice/device3/aidl/AidlCamera3Device.h b/services/camera/libcameraservice/device3/aidl/AidlCamera3Device.h
deleted file mode 100644
index d20a7ebdc9..0000000000
--- a/services/camera/libcameraservice/device3/aidl/AidlCamera3Device.h
+++ /dev/null
@@ -1,273 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SERVERS_AIDLCAMERA3DEVICE_H
-#define ANDROID_SERVERS_AIDLCAMERA3DEVICE_H
-
-#include "../Camera3Device.h"
-#include "AidlCamera3OutputUtils.h"
-#include <fmq/AidlMessageQueue.h>
-
-#include <aidl/android/hardware/camera/device/BnCameraDeviceCallback.h>
-#include <aidl/android/hardware/camera/device/ICameraDevice.h>
-#include <aidl/android/hardware/camera/device/ICameraInjectionSession.h>
-namespace android {
-
-using ::aidl::android::hardware::common::fmq::SynchronizedReadWrite;
-using ::android::AidlMessageQueue;
-
-/**
- * CameraDevice for AIDL HAL devices.
- */
-class AidlCamera3Device :
-            public Camera3Device {
-  public:
-
-    using AidlRequestMetadataQueue = AidlMessageQueue<int8_t, SynchronizedReadWrite>;
-    class AidlCameraDeviceCallbacks;
-    friend class AidlCameraDeviceCallbacks;
-    explicit AidlCamera3Device(const String8& id, bool overrideForPerfClass,
-            bool legacyClient = false);
-
-    virtual ~AidlCamera3Device() { }
-
-    static aidl::android::hardware::graphics::common::PixelFormat mapToAidlPixelFormat(
-            int frameworkFormat);
-    static aidl::android::hardware::graphics::common::Dataspace mapToAidlDataspace(
-            android_dataspace dataSpace);
-    static aidl::android::hardware::graphics::common::BufferUsage mapToAidlConsumerUsage(
-            uint64_t usage);
-    static aidl::android::hardware::camera::device::StreamRotation
-            mapToAidlStreamRotation(camera_stream_rotation_t rotation);
-
-    static status_t mapToAidlStreamConfigurationMode(
-            camera_stream_configuration_mode_t operationMode,
-            aidl::android::hardware::camera::device::StreamConfigurationMode *mode);
-
-    static int mapToFrameworkFormat(
-        aidl::android::hardware::graphics::common::PixelFormat pixelFormat);
-    static android_dataspace mapToFrameworkDataspace(
-            aidl::android::hardware::graphics::common::Dataspace);
-    static uint64_t mapConsumerToFrameworkUsage(
-            aidl::android::hardware::graphics::common::BufferUsage usage);
-    static uint64_t mapProducerToFrameworkUsage(
-            aidl::android::hardware::graphics::common::BufferUsage usage);
-
-    virtual status_t switchToOffline(const std::vector<int32_t>& /*streamsToKeep*/,
-            /*out*/ sp<CameraOfflineSessionBase>* /*session*/) override;
-
-    status_t initialize(sp<CameraProviderManager> manager, const String8& monitorTags) override;
-    class AidlHalInterface : public Camera3Device::HalInterface {
-     public:
-        AidlHalInterface(std::shared_ptr<
-                aidl::android::hardware::camera::device::ICameraDeviceSession> &session,
-                std::shared_ptr<AidlRequestMetadataQueue> queue,
-                bool useHalBufManager, bool supportOfflineProcessing);
-        AidlHalInterface(
-                std::shared_ptr<aidl::android::hardware::camera::device::ICameraDeviceSession>
-                    &deviceSession,
-                std::shared_ptr<
-                aidl::android::hardware::camera::device::ICameraInjectionSession> &injectionSession,
-                std::shared_ptr<AidlRequestMetadataQueue> queue,
-                bool useHalBufManager, bool supportOfflineProcessing);
-
-        virtual IPCTransport getTransportType() const override {return IPCTransport::AIDL; }
-
-
-        // Returns true if constructed with a valid device or session, and not yet cleared
-        virtual bool valid() override;
-
-        // Reset this HalInterface object (does not call close())
-        virtual void clear() override;
-
-        // Caller takes ownership of requestTemplate
-        virtual status_t constructDefaultRequestSettings(camera_request_template templateId,
-                /*out*/ camera_metadata_t **requestTemplate) override;
-
-        virtual status_t configureStreams(const camera_metadata_t *sessionParams,
-                /*inout*/ camera_stream_configuration_t *config,
-                const std::vector<uint32_t>& bufferSizes) override;
-        // The injection camera configures the streams to hal.
-        virtual status_t configureInjectedStreams(
-                const camera_metadata_t* sessionParams,
-                /*inout*/ camera_stream_configuration_t* config,
-                const std::vector<uint32_t>& bufferSizes,
-                const CameraMetadata& cameraCharacteristics) override;
-
-        // When the call succeeds, the ownership of acquire fences in requests is transferred to
-        // HalInterface. More specifically, the current implementation will send the fence to
-        // HAL process and close the FD in cameraserver process. When the call fails, the ownership
-        // of the acquire fence still belongs to the caller.
-        virtual status_t processBatchCaptureRequests(
-                std::vector<camera_capture_request_t*>& requests,
-                /*out*/uint32_t* numRequestProcessed) override;
-
-        // Calls into the HAL interface
-        virtual status_t flush() override;
-        virtual status_t dump(int fd) override;
-        virtual status_t close() override;
-        virtual void signalPipelineDrain(const std::vector<int>& streamIds) override;
-        virtual bool isReconfigurationRequired(CameraMetadata& oldSessionParams,
-                CameraMetadata& newSessionParams) override;
-
-        virtual status_t repeatingRequestEnd(uint32_t ,
-                const std::vector<int32_t> &) override;
-
-        status_t switchToOffline(
-        const std::vector<int32_t>& streamsToKeep,
-        /*out*/aidl::android::hardware::camera::device::CameraOfflineSessionInfo*
-                offlineSessionInfo,
-        /*out*/std::shared_ptr<aidl::android::hardware::camera::device::ICameraOfflineSession>*
-                offlineSession,
-        /*out*/camera3::BufferRecords* bufferRecords);
-
-     private:
-
-        // Always valid
-        std::shared_ptr<aidl::android::hardware::camera::device::ICameraDeviceSession>
-                mAidlSession = nullptr;
-        //Valid for injection sessions
-        std::shared_ptr<aidl::android::hardware::camera::device::ICameraInjectionSession>
-                mAidlInjectionSession = nullptr;
-
-        status_t wrapAsAidlRequest(camera_capture_request_t* request,
-                /*out*/aidl::android::hardware::camera::device::CaptureRequest* captureRequest,
-                /*out*/std::vector<native_handle_t*>* handlesCreated,
-                /*out*/std::vector<std::pair<int32_t, int32_t>>* inflightBuffers);
-
-        std::shared_ptr<AidlRequestMetadataQueue> mRequestMetadataQueue;
-    }; // class AidlHalInterface
-
-    /**
-     * Implementation of aidl::android::hardware::camera::device::ICameraDeviceCallback
-     */
-    ::ndk::ScopedAStatus processCaptureResult(
-            const std::vector<aidl::android::hardware::camera::device::CaptureResult>& results);
-    ::ndk::ScopedAStatus notify(
-            const std::vector<aidl::android::hardware::camera::device::NotifyMsg>& msgs);
-
-    ::ndk::ScopedAStatus requestStreamBuffers(
-            const std::vector<aidl::android::hardware::camera::device::BufferRequest>& bufReqs,
-            std::vector<aidl::android::hardware::camera::device::StreamBufferRet>* outBuffers,
-            aidl::android::hardware::camera::device::BufferRequestStatus* status);
-
-    ::ndk::ScopedAStatus returnStreamBuffers(
-            const std::vector<aidl::android::hardware::camera::device::StreamBuffer>& buffers);
-
-    class AidlRequestThread : public Camera3Device::RequestThread {
-      public:
-        AidlRequestThread(wp<Camera3Device> parent,
-                sp<camera3::StatusTracker> statusTracker,
-                sp<HalInterface> interface,
-                const Vector<int32_t>& sessionParamKeys,
-                bool useHalBufManager,
-                bool supportCameraMute);
-
-        status_t switchToOffline(
-                const std::vector<int32_t>& streamsToKeep,
-                /*out*/aidl::android::hardware::camera::device::CameraOfflineSessionInfo*
-                        offlineSessionInfo,
-                /*out*/std::shared_ptr<
-                        aidl::android::hardware::camera::device::ICameraOfflineSession>*
-                                offlineSession,
-                /*out*/camera3::BufferRecords* bufferRecords);
-    }; // class AidlRequestThread
-
-    class AidlCamera3DeviceInjectionMethods : public Camera3DeviceInjectionMethods {
-     public:
-        // Initialize the injection camera and generate an hal interface.
-        status_t injectionInitialize(
-                const String8& injectedCamId, sp<CameraProviderManager> manager,
-                const std::shared_ptr<
-                    aidl::android::hardware::camera::device::ICameraDeviceCallback>&
-                    callback);
-        AidlCamera3DeviceInjectionMethods(wp<Camera3Device> parent) :
-                Camera3DeviceInjectionMethods(parent) { };
-        ~AidlCamera3DeviceInjectionMethods() {}
-     private:
-        // Backup of the original camera hal result FMQ.
-        std::unique_ptr<AidlResultMetadataQueue> mBackupResultMetadataQueue;
-
-        // FMQ writes the result for the injection camera. Must be guarded by
-        // mProcessCaptureResultLock.
-        std::unique_ptr<AidlResultMetadataQueue> mInjectionResultMetadataQueue;
-
-        // Use injection camera hal interface to replace and backup original
-        // camera hal interface.
-        virtual status_t replaceHalInterface(sp<HalInterface> newHalInterface,
-                bool keepBackup) override;
-    };
-
-    // We need a separate class which inherits from AIDL ICameraDeviceCallbacks
-    // since we use the ndk backend for AIDL HAL interfaces. The ndk backend of
-    // ICameraDeviceCallbacks doesn't support sp<> (since it doesn't inherit
-    // from RefBase).
-    // As a result we can't write sp<Camera3Device> = new AidlCamera3Device(...).
-    // It supports std::shared_ptr instead. Other references to
-    // Camera3Device in cameraserver use sp<> widely, so to keep supporting
-    // that, we create a new class which will be managed through std::shared_ptr
-    // internally by AidlCamera3Device.
-    class AidlCameraDeviceCallbacks :
-            public aidl::android::hardware::camera::device::BnCameraDeviceCallback {
-      public:
-
-        AidlCameraDeviceCallbacks(wp<AidlCamera3Device> parent) : mParent(parent)  { }
-        ~AidlCameraDeviceCallbacks() { }
-        ::ndk::ScopedAStatus processCaptureResult(
-                const std::vector<
-                        aidl::android::hardware::camera::device::CaptureResult>& results) override;
-        ::ndk::ScopedAStatus notify(
-                const std::vector<
-                        aidl::android::hardware::camera::device::NotifyMsg>& msgs) override;
-
-        ::ndk::ScopedAStatus requestStreamBuffers(
-                const std::vector<
-                        aidl::android::hardware::camera::device::BufferRequest>& bufReqs,
-                std::vector<aidl::android::hardware::camera::device::StreamBufferRet>* outBuffers,
-                aidl::android::hardware::camera::device::BufferRequestStatus* status) override;
-
-        ::ndk::ScopedAStatus returnStreamBuffers(
-                const std::vector<
-                        aidl::android::hardware::camera::device::StreamBuffer>& buffers) override;
-        private:
-            wp<AidlCamera3Device> mParent = nullptr;
-    };
-
-  private:
-    virtual status_t injectionCameraInitialize(const String8 &injectCamId,
-            sp<CameraProviderManager> manager) override;
-
-    virtual sp<RequestThread> createNewRequestThread(wp<Camera3Device> parent,
-                sp<camera3::StatusTracker> statusTracker,
-                sp<HalInterface> interface,
-                const Vector<int32_t>& sessionParamKeys,
-                bool useHalBufManager,
-                bool supportCameraMute) override;
-
-    virtual sp<Camera3DeviceInjectionMethods>
-            createCamera3DeviceInjectionMethods(wp<Camera3Device>) override;
-
-    // FMQ to write result on. Must be guarded by mProcessCaptureResultLock.
-    std::unique_ptr<AidlResultMetadataQueue> mResultMetadataQueue = nullptr;
-
-    std::shared_ptr<AidlCameraDeviceCallbacks> mCallbacks = nullptr;
-
-
-}; // class AidlCamera3Device
-
-}; // namespace android
-
-#endif
diff --git a/services/camera/libcameraservice/device3/aidl/AidlCamera3OfflineSession.cpp b/services/camera/libcameraservice/device3/aidl/AidlCamera3OfflineSession.cpp
deleted file mode 100644
index 336719decd..0000000000
--- a/services/camera/libcameraservice/device3/aidl/AidlCamera3OfflineSession.cpp
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "AidlCamera3-OffLnSsn"
-#define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
-//#define LOG_NNDEBUG 0  // Per-frame verbose logging
-
-#ifdef LOG_NNDEBUG
-#define ALOGVV(...) ALOGV(__VA_ARGS__)
-#else
-#define ALOGVV(...) ((void)0)
-#endif
-
-#include <inttypes.h>
-
-#include <utils/Trace.h>
-
-#include <android/hardware/camera2/ICameraDeviceCallbacks.h>
-
-#include "device3/aidl/AidlCamera3OfflineSession.h"
-#include "device3/Camera3OutputStream.h"
-#include "device3/aidl/AidlCamera3OutputUtils.h"
-#include "device3/Camera3InputStream.h"
-#include "device3/Camera3SharedOutputStream.h"
-#include "utils/CameraTraces.h"
-
-using namespace android::camera3;
-using namespace aidl::android::hardware;
-
-namespace android {
-
-
-AidlCamera3OfflineSession::~AidlCamera3OfflineSession() {
-    ATRACE_CALL();
-    ALOGV("%s: Tearing down aidl offline session for camera id %s", __FUNCTION__, mId.string());
-    AidlCamera3OfflineSession::disconnectSession();
-}
-
-status_t AidlCamera3OfflineSession::initialize(wp<NotificationListener> listener) {
-    ATRACE_CALL();
-
-    if (mSession == nullptr) {
-        ALOGE("%s: AIDL session is null!", __FUNCTION__);
-        return DEAD_OBJECT;
-    }
-
-    {
-        std::lock_guard<std::mutex> lock(mLock);
-
-        mListener = listener;
-
-        // setup result FMQ
-        std::unique_ptr<AidlResultMetadataQueue>& resQueue = mResultMetadataQueue;
-        ::aidl::android::hardware::common::fmq::MQDescriptor<
-            int8_t, ::aidl::android::hardware::common::fmq::SynchronizedReadWrite> desc;
-        ::ndk::ScopedAStatus resultQueueRet = mSession->getCaptureResultMetadataQueue(&desc);
-        if (!resultQueueRet.isOk()) {
-            ALOGE("Transaction error when getting result metadata queue from camera session: %s",
-                    resultQueueRet.getMessage());
-            return DEAD_OBJECT;
-        }
-        resQueue = std::make_unique<AidlResultMetadataQueue>(desc);
-        if (!resQueue->isValid() || resQueue->availableToWrite() <= 0) {
-            ALOGE("HAL returns empty result metadata fmq, not use it");
-            resQueue = nullptr;
-            // Don't use resQueue onwards.
-        }
-
-        mStatus = STATUS_ACTIVE;
-    }
-
-    mSession->setCallback(mCallbacks);
-
-    return OK;
-}
-
-::ndk::ScopedAStatus AidlCamera3OfflineSession::AidlCameraDeviceCallbacks::processCaptureResult(
-        const std::vector<camera::device::CaptureResult>& results) {
-    sp<AidlCamera3OfflineSession> p = mParent.promote();
-    if (p == nullptr) {
-        ALOGE("%s Parent AidlCameraDevice not alive, can't process callbacks", __FUNCTION__);
-        return ::ndk::ScopedAStatus::ok();
-    }
-    return p->processCaptureResult(results);
-}
-
-::ndk::ScopedAStatus AidlCamera3OfflineSession::processCaptureResult(
-        const std::vector<camera::device::CaptureResult>& results) {
-    sp<NotificationListener> listener;
-    {
-        std::lock_guard<std::mutex> lock(mLock);
-        if (mStatus != STATUS_ACTIVE) {
-            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
-            return ::ndk::ScopedAStatus::ok();
-        }
-        listener = mListener.promote();
-    }
-
-    AidlCaptureOutputStates states {
-      {mId,
-        mOfflineReqsLock, mLastCompletedRegularFrameNumber,
-        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
-        mOfflineReqs, mOutputLock, mResultQueue, mResultSignal,
-        mNextShutterFrameNumber,
-        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
-        mNextResultFrameNumber,
-        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
-        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
-        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
-        mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
-        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this,
-        *this, mBufferRecords, /*legacyClient*/ false, mMinExpectedDuration}, mResultMetadataQueue
-    };
-
-    std::lock_guard<std::mutex> lock(mProcessCaptureResultLock);
-    for (const auto& result : results) {
-        processOneCaptureResultLocked(states, result, result.physicalCameraMetadata);
-    }
-    return ::ndk::ScopedAStatus::ok();
-}
-
-::ndk::ScopedAStatus AidlCamera3OfflineSession::AidlCameraDeviceCallbacks::notify(
-        const std::vector<camera::device::NotifyMsg>& msgs) {
-    sp<AidlCamera3OfflineSession> p = mParent.promote();
-    if (p == nullptr) {
-        ALOGE("%s Parent AidlCameraDevice not alive, can't process callbacks", __FUNCTION__);
-        return ::ndk::ScopedAStatus::ok();
-    }
-    return p->notify(msgs);
-}
-
-::ndk::ScopedAStatus AidlCamera3OfflineSession::notify(
-        const std::vector<camera::device::NotifyMsg>& msgs) {
-    sp<NotificationListener> listener;
-    {
-        std::lock_guard<std::mutex> lock(mLock);
-        if (mStatus != STATUS_ACTIVE) {
-            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
-            return ::ndk::ScopedAStatus::ok();
-        }
-        listener = mListener.promote();
-    }
-
-    AidlCaptureOutputStates states {
-      {mId,
-        mOfflineReqsLock, mLastCompletedRegularFrameNumber,
-        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
-        mOfflineReqs, mOutputLock, mResultQueue, mResultSignal,
-        mNextShutterFrameNumber,
-        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
-        mNextResultFrameNumber,
-        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
-        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
-        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
-        mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
-        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this,
-        *this, mBufferRecords, /*legacyClient*/ false, mMinExpectedDuration}, mResultMetadataQueue
-    };
-    for (const auto& msg : msgs) {
-        camera3::notify(states, msg);
-    }
-    return ::ndk::ScopedAStatus::ok();
-}
-
-::ndk::ScopedAStatus AidlCamera3OfflineSession::AidlCameraDeviceCallbacks::requestStreamBuffers(
-        const std::vector<::aidl::android::hardware::camera::device::BufferRequest>& bufReqs,
-        std::vector<::aidl::android::hardware::camera::device::StreamBufferRet>* buffers,
-        ::aidl::android::hardware::camera::device::BufferRequestStatus* status) {
-    sp<AidlCamera3OfflineSession> p = mParent.promote();
-    if (p == nullptr) {
-        ALOGE("%s Parent AidlCameraDevice not alive, can't process callbacks", __FUNCTION__);
-        return ::ndk::ScopedAStatus::ok();
-    }
-    return p->requestStreamBuffers(bufReqs, buffers, status);
-}
-
-::ndk::ScopedAStatus AidlCamera3OfflineSession::requestStreamBuffers(
-        const std::vector<::aidl::android::hardware::camera::device::BufferRequest>& bufReqs,
-        std::vector<::aidl::android::hardware::camera::device::StreamBufferRet>* buffers,
-        ::aidl::android::hardware::camera::device::BufferRequestStatus* status) {
-
-    {
-        std::lock_guard<std::mutex> lock(mLock);
-        if (mStatus != STATUS_ACTIVE) {
-            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
-            return ::ndk::ScopedAStatus::ok();
-        }
-    }
-
-    RequestBufferStates states {
-        mId, mRequestBufferInterfaceLock, mUseHalBufManager, mOutputStreams, mSessionStatsBuilder,
-        *this, mBufferRecords, *this};
-    camera3::requestStreamBuffers(states, bufReqs, buffers, status);
-    return ::ndk::ScopedAStatus::ok();
-}
-
-::ndk::ScopedAStatus AidlCamera3OfflineSession::AidlCameraDeviceCallbacks::returnStreamBuffers(
-        const std::vector<camera::device::StreamBuffer>& buffers) {
-    sp<AidlCamera3OfflineSession> p = mParent.promote();
-    if (p == nullptr) {
-        ALOGE("%s Parent AidlCameraDevice not alive, can't process callbacks", __FUNCTION__);
-        return ::ndk::ScopedAStatus::ok();
-    }
-    return p->returnStreamBuffers(buffers);
-}
-
-::ndk::ScopedAStatus AidlCamera3OfflineSession::returnStreamBuffers(
-        const std::vector<camera::device::StreamBuffer>& buffers) {
-    {
-        std::lock_guard<std::mutex> lock(mLock);
-        if (mStatus != STATUS_ACTIVE) {
-            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
-            return ::ndk::ScopedAStatus::ok();
-        }
-    }
-
-    ReturnBufferStates states {
-        mId, mUseHalBufManager, mOutputStreams, mSessionStatsBuilder,
-        mBufferRecords};
-
-    camera3::returnStreamBuffers(states, buffers);
-    return ::ndk::ScopedAStatus::ok();
-}
-
-void AidlCamera3OfflineSession::disconnectSession() {
-  std::lock_guard<std::mutex> lock(mLock);
-  if (mSession != nullptr) {
-      mSession->close();
-  }
-  mSession.reset();
-}
-
-}; // namespace android
diff --git a/services/camera/libcameraservice/device3/aidl/AidlCamera3OfflineSession.h b/services/camera/libcameraservice/device3/aidl/AidlCamera3OfflineSession.h
deleted file mode 100644
index 33de2c5bf2..0000000000
--- a/services/camera/libcameraservice/device3/aidl/AidlCamera3OfflineSession.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SERVERS_AIDL_CAMERA3OFFLINESESSION_H
-#define ANDROID_SERVERS_AIDL_CAMERA3OFFLINESESSION_H
-
-#include <memory>
-#include <mutex>
-
-#include <utils/String8.h>
-#include <utils/String16.h>
-
-#include "AidlCamera3OutputUtils.h"
-#include <aidl/android/hardware/camera/device/BnCameraDeviceCallback.h>
-#include <aidl/android/hardware/camera/device/ICameraOfflineSession.h>
-
-#include <fmq/AidlMessageQueue.h>
-
-#include "common/CameraOfflineSessionBase.h"
-
-#include "device3/Camera3BufferManager.h"
-#include "device3/Camera3OfflineSession.h"
-#include "utils/TagMonitor.h"
-#include <camera_metadata_hidden.h>
-
-namespace android {
-
-namespace camera3 {
-
-class Camera3Stream;
-class Camera3OutputStreamInterface;
-class Camera3StreamInterface;
-
-} // namespace camera3
-
-/**
- * AidlCamera3OfflineSession for offline session defined in AIDL ICameraOfflineSession
- */
-class AidlCamera3OfflineSession :
-            public Camera3OfflineSession {
-  public:
-
-    virtual ~AidlCamera3OfflineSession();
-
-    virtual status_t initialize(wp<NotificationListener> listener) override;
-
-    /**
-     * Implementation of aidl::android::hardware::camera::device::ICameraDeviceCallback
-     */
-    ::ndk::ScopedAStatus processCaptureResult(
-            const std::vector<aidl::android::hardware::camera::device::CaptureResult>& results);
-    ::ndk::ScopedAStatus notify(
-            const std::vector<aidl::android::hardware::camera::device::NotifyMsg>& msgs);
-    ::ndk::ScopedAStatus requestStreamBuffers(
-            const std::vector<aidl::android::hardware::camera::device::BufferRequest>& bufReqs,
-            std::vector<aidl::android::hardware::camera::device::StreamBufferRet>* outBuffers,
-            aidl::android::hardware::camera::device::BufferRequestStatus* status);
-
-    ::ndk::ScopedAStatus returnStreamBuffers(
-            const std::vector<aidl::android::hardware::camera::device::StreamBuffer>& buffers);
-
-    // See explanation for why we need a separate class for this in
-    // AidlCamera3Device::AidlCameraDeviceCallbacks in AidlCamera3Device.h
-    class AidlCameraDeviceCallbacks :
-            public aidl::android::hardware::camera::device::BnCameraDeviceCallback {
-      public:
-
-        AidlCameraDeviceCallbacks(wp<AidlCamera3OfflineSession> parent) : mParent(parent)  { }
-        ~AidlCameraDeviceCallbacks() {}
-        ::ndk::ScopedAStatus processCaptureResult(
-                const std::vector<
-                        aidl::android::hardware::camera::device::CaptureResult>& results) override;
-        ::ndk::ScopedAStatus notify(
-                const std::vector<
-                        aidl::android::hardware::camera::device::NotifyMsg>& msgs) override;
-
-        ::ndk::ScopedAStatus requestStreamBuffers(
-                const std::vector<
-                        aidl::android::hardware::camera::device::BufferRequest>& bufReqs,
-                std::vector<aidl::android::hardware::camera::device::StreamBufferRet>* out_buffers,
-                aidl::android::hardware::camera::device::BufferRequestStatus* _aidl_return
-                ) override;
-
-        ::ndk::ScopedAStatus returnStreamBuffers(
-                const std::vector<
-                        aidl::android::hardware::camera::device::StreamBuffer>& buffers) override;
-        private:
-            wp<AidlCamera3OfflineSession> mParent = nullptr;
-    };
-
-    // initialize by Camera3Device.
-    explicit AidlCamera3OfflineSession(const String8& id,
-            const sp<camera3::Camera3Stream>& inputStream,
-            const camera3::StreamSet& offlineStreamSet,
-            camera3::BufferRecords&& bufferRecords,
-            const camera3::InFlightRequestMap& offlineReqs,
-            const Camera3OfflineStates& offlineStates,
-            std::shared_ptr<aidl::android::hardware::camera::device::ICameraOfflineSession>
-                    offlineSession) :
-      Camera3OfflineSession(id, inputStream, offlineStreamSet, std::move(bufferRecords),
-              offlineReqs, offlineStates),
-      mSession(offlineSession) {
-        mCallbacks = ndk::SharedRefBase::make<AidlCameraDeviceCallbacks>(this);
-      };
-
-    /**
-     * End of CameraOfflineSessionBase interface
-     */
-
-  private:
-    std::shared_ptr<aidl::android::hardware::camera::device::ICameraOfflineSession> mSession;
-    // FMQ to write result on. Must be guarded by mProcessCaptureResultLock.
-    std::unique_ptr<AidlResultMetadataQueue> mResultMetadataQueue;
-
-    std::shared_ptr<AidlCameraDeviceCallbacks> mCallbacks;
-
-    virtual void disconnectSession() override;
-
-}; // class AidlCamera3OfflineSession
-
-}; // namespace android
-
-#endif
diff --git a/services/camera/libcameraservice/device3/aidl/AidlCamera3OutputUtils.cpp b/services/camera/libcameraservice/device3/aidl/AidlCamera3OutputUtils.cpp
deleted file mode 100644
index 02eebd24f3..0000000000
--- a/services/camera/libcameraservice/device3/aidl/AidlCamera3OutputUtils.cpp
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "AidlCamera3-OutputUtils"
-#define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
-//#define LOG_NNDEBUG 0  // Per-frame verbose logging
-
-#ifdef LOG_NNDEBUG
-#define ALOGVV(...) ALOGV(__VA_ARGS__)
-#else
-#define ALOGVV(...) ((void)0)
-#endif
-
-// Convenience macros for transitioning to the error state
-#define SET_ERR(fmt, ...) states.setErrIntf.setErrorState(   \
-    "%s: " fmt, __FUNCTION__,                         \
-    ##__VA_ARGS__)
-
-#include <inttypes.h>
-
-#include <utils/Log.h>
-#include <utils/SortedVector.h>
-#include <utils/Trace.h>
-
-#include <android/hardware/camera2/ICameraDeviceCallbacks.h>
-#include <aidlcommonsupport/NativeHandle.h>
-
-#include <camera/CameraUtils.h>
-#include <camera_metadata_hidden.h>
-
-#include "device3/aidl/AidlCamera3OutputUtils.h"
-#include "device3/Camera3OutputUtilsTemplated.h"
-
-#include "system/camera_metadata.h"
-
-using namespace android::camera3;
-using namespace android::hardware::camera;
-
-namespace android {
-namespace camera3 {
-
-void processOneCaptureResultLocked(
-        AidlCaptureOutputStates& states,
-        const aidl::android::hardware::camera::device::CaptureResult& result,
-        const std::vector<aidl::android::hardware::camera::device::PhysicalCameraMetadata>
-                &physicalCameraMetadata) {
-    processOneCaptureResultLockedT<AidlCaptureOutputStates,
-        aidl::android::hardware::camera::device::CaptureResult,
-        std::vector<aidl::android::hardware::camera::device::PhysicalCameraMetadata>,
-        std::vector<uint8_t>, AidlResultMetadataQueue,
-        aidl::android::hardware::camera::device::BufferStatus, int8_t>(states, result,
-                physicalCameraMetadata);
-}
-
-void notify(CaptureOutputStates& states,
-        const aidl::android::hardware::camera::device::NotifyMsg& msg) {
-
-    using ErrorCode = aidl::android::hardware::camera::device::ErrorCode;
-    using Tag = aidl::android::hardware::camera::device::NotifyMsg::Tag;
-
-    ATRACE_CALL();
-    camera_notify_msg m;
-
-    switch (msg.getTag()) {
-        case Tag::error:
-            m.type = CAMERA_MSG_ERROR;
-            m.message.error.frame_number = msg.get<Tag::error>().frameNumber;
-            if (msg.get<Tag::error>().errorStreamId >= 0) {
-                sp<Camera3StreamInterface> stream =
-                        states.outputStreams.get(msg.get<Tag::error>().errorStreamId);
-                if (stream == nullptr) {
-                    ALOGE("%s: Frame %d: Invalid error stream id %d", __FUNCTION__,
-                            m.message.error.frame_number, msg.get<Tag::error>().errorStreamId);
-                    return;
-                }
-                m.message.error.error_stream = stream->asHalStream();
-            } else {
-                m.message.error.error_stream = nullptr;
-            }
-            switch (msg.get<Tag::error>().errorCode) {
-                case ErrorCode::ERROR_DEVICE:
-                    m.message.error.error_code = CAMERA_MSG_ERROR_DEVICE;
-                    break;
-                case ErrorCode::ERROR_REQUEST:
-                    m.message.error.error_code = CAMERA_MSG_ERROR_REQUEST;
-                    break;
-                case ErrorCode::ERROR_RESULT:
-                    m.message.error.error_code = CAMERA_MSG_ERROR_RESULT;
-                    break;
-                case ErrorCode::ERROR_BUFFER:
-                    m.message.error.error_code = CAMERA_MSG_ERROR_BUFFER;
-                    break;
-            }
-            break;
-        case Tag::shutter:
-            m.type = CAMERA_MSG_SHUTTER;
-            m.message.shutter.frame_number = msg.get<Tag::shutter>().frameNumber;
-            m.message.shutter.timestamp = msg.get<Tag::shutter>().timestamp;
-            m.message.shutter.readout_timestamp = msg.get<Tag::shutter>().readoutTimestamp;
-            break;
-    }
-    notify(states, &m);
-}
-
-
-// The buffers requested through this call are not tied to any CaptureRequest in
-// particular. They may used by the hal for a particular frame's output buffer
-// or for its internal use as well. In the case that the hal does use any buffer
-// from the requested list here, for a particular frame's output buffer, the
-// buffer will be returned with the processCaptureResult call corresponding to
-// the frame. The other buffers will be returned through returnStreamBuffers.
-// The buffers returned via returnStreamBuffers will not have a valid
-// timestamp(0) and will be dropped by the bufferqueue.
-void requestStreamBuffers(RequestBufferStates& states,
-        const std::vector<aidl::android::hardware::camera::device::BufferRequest>& bufReqs,
-        std::vector<::aidl::android::hardware::camera::device::StreamBufferRet>* outBuffers,
-        ::aidl::android::hardware::camera::device::BufferRequestStatus* status) {
-    using aidl::android::hardware::camera::device::BufferStatus;
-    using aidl::android::hardware::camera::device::StreamBuffer;
-    using aidl::android::hardware::camera::device::BufferRequestStatus;
-    using aidl::android::hardware::camera::device::StreamBufferRet;
-    using aidl::android::hardware::camera::device::StreamBufferRequestError;
-    using Tag = aidl::android::hardware::camera::device::StreamBuffersVal::Tag;
-    if (outBuffers == nullptr || status == nullptr) {
-        ALOGE("%s outBuffers / buffer status nullptr", __FUNCTION__);
-        return;
-    }
-    std::lock_guard<std::mutex> lock(states.reqBufferLock);
-    std::vector<StreamBufferRet> bufRets;
-    outBuffers->clear();
-    if (!states.useHalBufManager) {
-        ALOGE("%s: Camera %s does not support HAL buffer management",
-                __FUNCTION__, states.cameraId.string());
-        *status = BufferRequestStatus::FAILED_ILLEGAL_ARGUMENTS;
-        return;
-    }
-
-    SortedVector<int32_t> streamIds;
-    ssize_t sz = streamIds.setCapacity(bufReqs.size());
-    if (sz < 0 || static_cast<size_t>(sz) != bufReqs.size()) {
-        ALOGE("%s: failed to allocate memory for %zu buffer requests",
-                __FUNCTION__, bufReqs.size());
-        *status = BufferRequestStatus::FAILED_ILLEGAL_ARGUMENTS;
-        return;
-    }
-
-    if (bufReqs.size() > states.outputStreams.size()) {
-        ALOGE("%s: too many buffer requests (%zu > # of output streams %zu)",
-                __FUNCTION__, bufReqs.size(), states.outputStreams.size());
-        *status = BufferRequestStatus::FAILED_ILLEGAL_ARGUMENTS;
-        return;
-    }
-
-    // Check for repeated streamId
-    for (const auto& bufReq : bufReqs) {
-        if (streamIds.indexOf(bufReq.streamId) != NAME_NOT_FOUND) {
-            ALOGE("%s: Stream %d appear multiple times in buffer requests",
-                    __FUNCTION__, bufReq.streamId);
-            *status = BufferRequestStatus::FAILED_ILLEGAL_ARGUMENTS;
-            return;
-        }
-        streamIds.add(bufReq.streamId);
-    }
-
-    if (!states.reqBufferIntf.startRequestBuffer()) {
-        ALOGE("%s: request buffer disallowed while camera service is configuring",
-                __FUNCTION__);
-        *status = BufferRequestStatus::FAILED_CONFIGURING;
-        return;
-    }
-
-    bufRets.resize(bufReqs.size());
-
-    bool allReqsSucceeds = true;
-    bool oneReqSucceeds = false;
-    for (size_t i = 0; i < bufReqs.size(); i++) {
-        const auto& bufReq = bufReqs[i];
-        auto& bufRet = bufRets[i];
-        int32_t streamId = bufReq.streamId;
-        sp<Camera3OutputStreamInterface> outputStream = states.outputStreams.get(streamId);
-        if (outputStream == nullptr) {
-            ALOGE("%s: Output stream id %d not found!", __FUNCTION__, streamId);
-            std::vector<StreamBufferRet> emptyBufRets;
-            *status = BufferRequestStatus::FAILED_CONFIGURING;
-            states.reqBufferIntf.endRequestBuffer();
-            return;
-        }
-
-        bufRet.streamId = streamId;
-        if (outputStream->isAbandoned()) {
-            bufRet.val.set<Tag::error>(StreamBufferRequestError::STREAM_DISCONNECTED);
-            allReqsSucceeds = false;
-            continue;
-        }
-
-        size_t handOutBufferCount = outputStream->getOutstandingBuffersCount();
-        uint32_t numBuffersRequested = bufReq.numBuffersRequested;
-        size_t totalHandout = handOutBufferCount + numBuffersRequested;
-        uint32_t maxBuffers = outputStream->asHalStream()->max_buffers;
-        if (totalHandout > maxBuffers) {
-            // Not able to allocate enough buffer. Exit early for this stream
-            ALOGE("%s: request too much buffers for stream %d: at HAL: %zu + requesting: %d"
-                    " > max: %d", __FUNCTION__, streamId, handOutBufferCount,
-                    numBuffersRequested, maxBuffers);
-            bufRet.val.set<Tag::error>(StreamBufferRequestError::MAX_BUFFER_EXCEEDED);
-            allReqsSucceeds = false;
-            continue;
-        }
-
-        std::vector<StreamBuffer> tmpRetBuffers(numBuffersRequested);
-        bool currentReqSucceeds = true;
-        std::vector<camera_stream_buffer_t> streamBuffers(numBuffersRequested);
-        std::vector<buffer_handle_t> newBuffers;
-        size_t numAllocatedBuffers = 0;
-        size_t numPushedInflightBuffers = 0;
-        for (size_t b = 0; b < numBuffersRequested; b++) {
-            camera_stream_buffer_t& sb = streamBuffers[b];
-            // Since this method can run concurrently with request thread
-            // We need to update the wait duration everytime we call getbuffer
-            nsecs_t waitDuration =  states.reqBufferIntf.getWaitDuration();
-            status_t res = outputStream->getBuffer(&sb, waitDuration);
-            if (res != OK) {
-                if (res == NO_INIT || res == DEAD_OBJECT) {
-                    ALOGV("%s: Can't get output buffer for stream %d: %s (%d)",
-                            __FUNCTION__, streamId, strerror(-res), res);
-                    bufRet.val.set<Tag::error>(StreamBufferRequestError::STREAM_DISCONNECTED);
-                    states.sessionStatsBuilder.stopCounter(streamId);
-                } else {
-                    ALOGE("%s: Can't get output buffer for stream %d: %s (%d)",
-                            __FUNCTION__, streamId, strerror(-res), res);
-                    if (res == TIMED_OUT || res == NO_MEMORY) {
-                        bufRet.val.set<Tag::error>(StreamBufferRequestError::NO_BUFFER_AVAILABLE);
-                    } else if (res == INVALID_OPERATION) {
-                        bufRet.val.set<Tag::error>(StreamBufferRequestError::MAX_BUFFER_EXCEEDED);
-                    } else {
-                        bufRet.val.set<Tag::error>(StreamBufferRequestError::UNKNOWN_ERROR);
-                    }
-                }
-                currentReqSucceeds = false;
-                break;
-            }
-            numAllocatedBuffers++;
-
-            buffer_handle_t *buffer = sb.buffer;
-            auto pair = states.bufferRecordsIntf.getBufferId(*buffer, streamId);
-            bool isNewBuffer = pair.first;
-            uint64_t bufferId = pair.second;
-            StreamBuffer& hBuf = tmpRetBuffers[b];
-
-            hBuf.streamId = streamId;
-            hBuf.bufferId = bufferId;
-
-            hBuf.buffer = (isNewBuffer) ? camera3::dupToAidlIfNotNull(*buffer) :
-                    aidl::android::hardware::common::NativeHandle();
-            hBuf.status = BufferStatus::OK;
-            hBuf.releaseFence =  aidl::android::hardware::common::NativeHandle();
-            if (isNewBuffer) {
-                newBuffers.push_back(*buffer);
-            }
-
-            native_handle_t *acquireFence = nullptr;
-            if (sb.acquire_fence != -1) {
-                acquireFence = native_handle_create(1,0);
-                acquireFence->data[0] = sb.acquire_fence;
-            }
-            //makeToAidl passes ownership to aidl NativeHandle made. Ownership
-            //is passed : see system/window.h : dequeueBuffer
-            hBuf.acquireFence = makeToAidlIfNotNull(acquireFence);
-            if (acquireFence != nullptr) {
-                native_handle_delete(acquireFence);
-            }
-            hBuf.releaseFence =  aidl::android::hardware::common::NativeHandle();
-
-            res = states.bufferRecordsIntf.pushInflightRequestBuffer(bufferId, buffer, streamId);
-            if (res != OK) {
-                ALOGE("%s: Can't get register request buffers for stream %d: %s (%d)",
-                        __FUNCTION__, streamId, strerror(-res), res);
-                bufRet.val.set<Tag::error>(StreamBufferRequestError::UNKNOWN_ERROR);
-                currentReqSucceeds = false;
-                break;
-            }
-            numPushedInflightBuffers++;
-        }
-        if (currentReqSucceeds) {
-            bufRet.val.set<Tag::buffers>(std::move(tmpRetBuffers));
-            oneReqSucceeds = true;
-        } else {
-            allReqsSucceeds = false;
-            for (size_t b = 0; b < numPushedInflightBuffers; b++) {
-                StreamBuffer& hBuf = tmpRetBuffers[b];
-                buffer_handle_t* buffer;
-                status_t res = states.bufferRecordsIntf.popInflightRequestBuffer(
-                        hBuf.bufferId, &buffer);
-                if (res != OK) {
-                    SET_ERR("%s: popInflightRequestBuffer failed for stream %d: %s (%d)",
-                            __FUNCTION__, streamId, strerror(-res), res);
-                }
-            }
-            for (size_t b = 0; b < numAllocatedBuffers; b++) {
-                camera_stream_buffer_t& sb = streamBuffers[b];
-                sb.acquire_fence = -1;
-                sb.status = CAMERA_BUFFER_STATUS_ERROR;
-            }
-            returnOutputBuffers(states.useHalBufManager, nullptr,
-                    streamBuffers.data(), numAllocatedBuffers, 0,
-                    0, false,
-                    0, states.sessionStatsBuilder);
-            for (auto buf : newBuffers) {
-                states.bufferRecordsIntf.removeOneBufferCache(streamId, buf);
-            }
-        }
-    }
-
-    *status = allReqsSucceeds ? BufferRequestStatus::OK :
-            oneReqSucceeds ? BufferRequestStatus::FAILED_PARTIAL :
-                             BufferRequestStatus::FAILED_UNKNOWN,
-    // Transfer ownership of buffer fds to outBuffers
-    *outBuffers = std::move(bufRets);
-
-    states.reqBufferIntf.endRequestBuffer();
-}
-
-void returnStreamBuffers(ReturnBufferStates& states,
-        const std::vector<aidl::android::hardware::camera::device::StreamBuffer>& buffers) {
-    returnStreamBuffersT(states, buffers);
-}
-
-} // camera3
-} // namespace android
diff --git a/services/camera/libcameraservice/device3/aidl/AidlCamera3OutputUtils.h b/services/camera/libcameraservice/device3/aidl/AidlCamera3OutputUtils.h
deleted file mode 100644
index e7956242d6..0000000000
--- a/services/camera/libcameraservice/device3/aidl/AidlCamera3OutputUtils.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SERVERS_AIDL_CAMERA3_OUTPUT_UTILS_H
-#define ANDROID_SERVERS_AIDL_CAMERA3_OUTPUT_UTILS_H
-
-#include <memory>
-#include <mutex>
-
-#include <cutils/native_handle.h>
-
-#include <aidlcommonsupport/NativeHandle.h>
-#include <fmq/AidlMessageQueue.h>
-
-#include <common/CameraDeviceBase.h>
-
-#include <aidl/android/hardware/camera/device/ICameraDevice.h>
-#include <aidl/android/hardware/camera/device/ICameraDeviceCallback.h>
-#include "device3/BufferUtils.h"
-#include "device3/InFlightRequest.h"
-#include "device3/Camera3Stream.h"
-#include "device3/Camera3OutputStreamInterface.h"
-#include "device3/Camera3OutputUtils.h"
-#include "utils/SessionStatsBuilder.h"
-#include "utils/TagMonitor.h"
-
-namespace android {
-
-using ::aidl::android::hardware::common::fmq::SynchronizedReadWrite;
-using ::android::AidlMessageQueue;
-
-using AidlResultMetadataQueue = AidlMessageQueue<int8_t, SynchronizedReadWrite>;
-namespace camera3 {
-    inline aidl::android::hardware::common::NativeHandle dupToAidlIfNotNull(
-            const native_handle_t *nh) {
-        if (nh == nullptr) {
-            return aidl::android::hardware::common::NativeHandle();
-        }
-        return dupToAidl(nh);
-    }
-
-    inline aidl::android::hardware::common::NativeHandle makeToAidlIfNotNull(
-            const native_handle_t *nh) {
-        if (nh == nullptr) {
-            return aidl::android::hardware::common::NativeHandle();
-        }
-        return makeToAidl(nh);
-    }
-
-    /**
-     * Helper methods shared between AidlCamera3Device/AidlCamera3OfflineSession for HAL callbacks
-     */
-
-    // Camera3Device/Camera3OfflineSession internal states used in notify/processCaptureResult
-    // callbacks
-    struct AidlCaptureOutputStates : public CaptureOutputStates {
-        std::unique_ptr<AidlResultMetadataQueue>& fmq;
-    };
-
-    // Handle one capture result. Assume callers hold the lock to serialize all
-    // processCaptureResult calls
-    void processOneCaptureResultLocked(
-            AidlCaptureOutputStates& states,
-            const aidl::android::hardware::camera::device::CaptureResult& result,
-            const std::vector<aidl::android::hardware::camera::device::PhysicalCameraMetadata>
-                    &physicalCameraMetadata);
-
-    void notify(CaptureOutputStates& states,
-        const aidl::android::hardware::camera::device::NotifyMsg& msg,
-        bool hasReadoutTime, uint64_t readoutTime);
-
-    void notify(CaptureOutputStates& states,
-        const aidl::android::hardware::camera::device::NotifyMsg& msg);
-
-    void requestStreamBuffers(RequestBufferStates& states,
-        const std::vector<aidl::android::hardware::camera::device::BufferRequest>& bufReqs,
-        std::vector<::aidl::android::hardware::camera::device::StreamBufferRet>* out_buffers,
-        ::aidl::android::hardware::camera::device::BufferRequestStatus* _aidl_return);
-
-    void returnStreamBuffers(ReturnBufferStates& states,
-        const std::vector<aidl::android::hardware::camera::device::StreamBuffer>& buffers);
-
-} // namespace camera3
-
-} // namespace android
-
-#endif
diff --git a/services/camera/libcameraservice/device3/hidl/HidlCamera3Device.cpp b/services/camera/libcameraservice/device3/hidl/HidlCamera3Device.cpp
deleted file mode 100644
index 4bb426c515..0000000000
--- a/services/camera/libcameraservice/device3/hidl/HidlCamera3Device.cpp
+++ /dev/null
@@ -1,1856 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "HidlCamera3-Device"
-#define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
-//#define LOG_NNDEBUG 0  // Per-frame verbose logging
-
-#ifdef LOG_NNDEBUG
-#define ALOGVV(...) ALOGV(__VA_ARGS__)
-#else
-#define ALOGVV(...) ((void)0)
-#endif
-
-// Convenience macro for transient errors
-#define CLOGE(fmt, ...) ALOGE("Camera %s: %s: " fmt, mId.string(), __FUNCTION__, \
-            ##__VA_ARGS__)
-
-// Convenience macros for transitioning to the error state
-#define SET_ERR(fmt, ...) setErrorState(   \
-    "%s: " fmt, __FUNCTION__,              \
-    ##__VA_ARGS__)
-#define SET_ERR_L(fmt, ...) setErrorStateLocked( \
-    "%s: " fmt, __FUNCTION__,                    \
-    ##__VA_ARGS__)
-
-
-#include <inttypes.h>
-
-#include <utility>
-
-#include <utils/Log.h>
-#include <utils/Trace.h>
-#include <utils/Timers.h>
-#include <cutils/properties.h>
-
-#include <android/hardware/camera/device/3.7/ICameraInjectionSession.h>
-#include <android/hardware/camera2/ICameraDeviceUser.h>
-
-#include "device3/hidl/HidlCamera3OutputUtils.h"
-#include "device3/hidl/HidlCamera3OfflineSession.h"
-#include "utils/SessionConfigurationUtilsHidl.h"
-#include "utils/TraceHFR.h"
-
-#include "../../common/hidl/HidlProviderInfo.h"
-#include "HidlCamera3Device.h"
-
-#include <algorithm>
-#include <tuple>
-
-using namespace android::camera3;
-using namespace android::hardware::camera;
-using namespace android::hardware::camera::device::V3_2;
-using android::hardware::camera::metadata::V3_6::CameraMetadataEnumAndroidSensorPixelMode;
-
-namespace android {
-
-hardware::graphics::common::V1_0::PixelFormat HidlCamera3Device::mapToPixelFormat(
-        int frameworkFormat) {
-    return (hardware::graphics::common::V1_0::PixelFormat) frameworkFormat;
-}
-
-DataspaceFlags HidlCamera3Device::mapToHidlDataspace(
-        android_dataspace dataSpace) {
-    return dataSpace;
-}
-
-BufferUsageFlags HidlCamera3Device::mapToConsumerUsage(
-        uint64_t usage) {
-    return usage;
-}
-
-StreamRotation HidlCamera3Device::mapToStreamRotation(camera_stream_rotation_t rotation) {
-    switch (rotation) {
-        case CAMERA_STREAM_ROTATION_0:
-            return StreamRotation::ROTATION_0;
-        case CAMERA_STREAM_ROTATION_90:
-            return StreamRotation::ROTATION_90;
-        case CAMERA_STREAM_ROTATION_180:
-            return StreamRotation::ROTATION_180;
-        case CAMERA_STREAM_ROTATION_270:
-            return StreamRotation::ROTATION_270;
-    }
-    ALOGE("%s: Unknown stream rotation %d", __FUNCTION__, rotation);
-    return StreamRotation::ROTATION_0;
-}
-
-status_t HidlCamera3Device::mapToStreamConfigurationMode(
-        camera_stream_configuration_mode_t operationMode, StreamConfigurationMode *mode) {
-    if (mode == nullptr) return BAD_VALUE;
-    if (operationMode < CAMERA_VENDOR_STREAM_CONFIGURATION_MODE_START) {
-        switch(operationMode) {
-            case CAMERA_STREAM_CONFIGURATION_NORMAL_MODE:
-                *mode = StreamConfigurationMode::NORMAL_MODE;
-                break;
-            case CAMERA_STREAM_CONFIGURATION_CONSTRAINED_HIGH_SPEED_MODE:
-                *mode = StreamConfigurationMode::CONSTRAINED_HIGH_SPEED_MODE;
-                break;
-            default:
-                ALOGE("%s: Unknown stream configuration mode %d", __FUNCTION__, operationMode);
-                return BAD_VALUE;
-        }
-    } else {
-        *mode = static_cast<StreamConfigurationMode>(operationMode);
-    }
-    return OK;
-}
-
-int HidlCamera3Device::mapToFrameworkFormat(
-        hardware::graphics::common::V1_0::PixelFormat pixelFormat) {
-    return static_cast<uint32_t>(pixelFormat);
-}
-
-android_dataspace HidlCamera3Device::mapToFrameworkDataspace(
-        DataspaceFlags dataSpace) {
-    return static_cast<android_dataspace>(dataSpace);
-}
-
-uint64_t HidlCamera3Device::mapConsumerToFrameworkUsage(
-        BufferUsageFlags usage) {
-    return usage;
-}
-
-uint64_t HidlCamera3Device::mapProducerToFrameworkUsage(
-        BufferUsageFlags usage) {
-    return usage;
-}
-
-status_t HidlCamera3Device::initialize(sp<CameraProviderManager> manager,
-        const String8& monitorTags) {
-    ATRACE_CALL();
-    Mutex::Autolock il(mInterfaceLock);
-    Mutex::Autolock l(mLock);
-
-    ALOGV("%s: Initializing HIDL device for camera %s", __FUNCTION__, mId.string());
-    if (mStatus != STATUS_UNINITIALIZED) {
-        CLOGE("Already initialized!");
-        return INVALID_OPERATION;
-    }
-    if (manager == nullptr) return INVALID_OPERATION;
-
-    sp<ICameraDeviceSession> session;
-    ATRACE_BEGIN("CameraHal::openSession");
-    status_t res = manager->openHidlSession(mId.string(), this,
-            /*out*/ &session);
-    ATRACE_END();
-    if (res != OK) {
-        SET_ERR_L("Could not open camera session: %s (%d)", strerror(-res), res);
-        return res;
-    }
-
-    res = manager->getCameraCharacteristics(mId.string(), mOverrideForPerfClass, &mDeviceInfo);
-    if (res != OK) {
-        SET_ERR_L("Could not retrieve camera characteristics: %s (%d)", strerror(-res), res);
-        session->close();
-        return res;
-    }
-    mSupportNativeZoomRatio = manager->supportNativeZoomRatio(mId.string());
-
-    std::vector<std::string> physicalCameraIds;
-    bool isLogical = manager->isLogicalCamera(mId.string(), &physicalCameraIds);
-    if (isLogical) {
-        for (auto& physicalId : physicalCameraIds) {
-            // Do not override characteristics for physical cameras
-            res = manager->getCameraCharacteristics(
-                    physicalId, /*overrideForPerfClass*/false, &mPhysicalDeviceInfoMap[physicalId]);
-            if (res != OK) {
-                SET_ERR_L("Could not retrieve camera %s characteristics: %s (%d)",
-                        physicalId.c_str(), strerror(-res), res);
-                session->close();
-                return res;
-            }
-
-            bool usePrecorrectArray =
-                    DistortionMapper::isDistortionSupported(mPhysicalDeviceInfoMap[physicalId]);
-            if (usePrecorrectArray) {
-                res = mDistortionMappers[physicalId].setupStaticInfo(
-                        mPhysicalDeviceInfoMap[physicalId]);
-                if (res != OK) {
-                    SET_ERR_L("Unable to read camera %s's calibration fields for distortion "
-                            "correction", physicalId.c_str());
-                    session->close();
-                    return res;
-                }
-            }
-
-            mZoomRatioMappers[physicalId] = ZoomRatioMapper(
-                    &mPhysicalDeviceInfoMap[physicalId],
-                    mSupportNativeZoomRatio, usePrecorrectArray);
-
-            if (SessionConfigurationUtils::isUltraHighResolutionSensor(
-                    mPhysicalDeviceInfoMap[physicalId])) {
-                mUHRCropAndMeteringRegionMappers[physicalId] =
-                        UHRCropAndMeteringRegionMapper(mPhysicalDeviceInfoMap[physicalId],
-                                usePrecorrectArray);
-            }
-        }
-    }
-
-    std::shared_ptr<RequestMetadataQueue> queue;
-    auto requestQueueRet = session->getCaptureRequestMetadataQueue(
-        [&queue](const auto& descriptor) {
-            queue = std::make_shared<RequestMetadataQueue>(descriptor);
-            if (!queue->isValid() || queue->availableToWrite() <= 0) {
-                ALOGE("HAL returns empty request metadata fmq, not use it");
-                queue = nullptr;
-                // don't use the queue onwards.
-            }
-        });
-    if (!requestQueueRet.isOk()) {
-        ALOGE("Transaction error when getting request metadata fmq: %s, not use it",
-                requestQueueRet.description().c_str());
-        return DEAD_OBJECT;
-    }
-
-    std::unique_ptr<ResultMetadataQueue>& resQueue = mResultMetadataQueue;
-    auto resultQueueRet = session->getCaptureResultMetadataQueue(
-        [&resQueue](const auto& descriptor) {
-            resQueue = std::make_unique<ResultMetadataQueue>(descriptor);
-            if (!resQueue->isValid() || resQueue->availableToWrite() <= 0) {
-                ALOGE("HAL returns empty result metadata fmq, not use it");
-                resQueue = nullptr;
-                // Don't use the resQueue onwards.
-            }
-        });
-    if (!resultQueueRet.isOk()) {
-        ALOGE("Transaction error when getting result metadata queue from camera session: %s",
-                resultQueueRet.description().c_str());
-        return DEAD_OBJECT;
-    }
-    IF_ALOGV() {
-        session->interfaceChain([](
-            ::android::hardware::hidl_vec<::android::hardware::hidl_string> interfaceChain) {
-                ALOGV("Session interface chain:");
-                for (const auto& iface : interfaceChain) {
-                    ALOGV("  %s", iface.c_str());
-                }
-            });
-    }
-
-    camera_metadata_entry bufMgrMode =
-            mDeviceInfo.find(ANDROID_INFO_SUPPORTED_BUFFER_MANAGEMENT_VERSION);
-    if (bufMgrMode.count > 0) {
-         mUseHalBufManager = (bufMgrMode.data.u8[0] ==
-            ANDROID_INFO_SUPPORTED_BUFFER_MANAGEMENT_VERSION_HIDL_DEVICE_3_5);
-    }
-
-    camera_metadata_entry_t capabilities = mDeviceInfo.find(ANDROID_REQUEST_AVAILABLE_CAPABILITIES);
-    for (size_t i = 0; i < capabilities.count; i++) {
-        uint8_t capability = capabilities.data.u8[i];
-        if (capability == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_OFFLINE_PROCESSING) {
-            mSupportOfflineProcessing = true;
-        }
-    }
-
-    mInterface = new HidlHalInterface(session, queue, mUseHalBufManager, mSupportOfflineProcessing);
-
-    std::string providerType;
-    mVendorTagId = manager->getProviderTagIdLocked(mId.string());
-    mTagMonitor.initialize(mVendorTagId);
-    if (!monitorTags.isEmpty()) {
-        mTagMonitor.parseTagsToMonitor(String8(monitorTags));
-    }
-
-    // Metadata tags needs fixup for monochrome camera device version less
-    // than 3.5.
-    hardware::hidl_version maxVersion{0,0};
-    IPCTransport transport = IPCTransport::HIDL;
-    res = manager->getHighestSupportedVersion(mId.string(), &maxVersion, &transport);
-    if (res != OK) {
-        ALOGE("%s: Error in getting camera device version id: %s (%d)",
-                __FUNCTION__, strerror(-res), res);
-        return res;
-    }
-    int deviceVersion = HARDWARE_DEVICE_API_VERSION(
-            maxVersion.get_major(), maxVersion.get_minor());
-
-    bool isMonochrome = false;
-    for (size_t i = 0; i < capabilities.count; i++) {
-        uint8_t capability = capabilities.data.u8[i];
-        if (capability == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME) {
-            isMonochrome = true;
-        }
-    }
-    mNeedFixupMonochromeTags = (isMonochrome && deviceVersion < CAMERA_DEVICE_API_VERSION_3_5);
-
-    return initializeCommonLocked();
-}
-
-hardware::Return<void> HidlCamera3Device::requestStreamBuffers(
-        const hardware::hidl_vec<hardware::camera::device::V3_5::BufferRequest>& bufReqs,
-        requestStreamBuffers_cb _hidl_cb) {
-    RequestBufferStates states {
-        mId, mRequestBufferInterfaceLock, mUseHalBufManager, mOutputStreams, mSessionStatsBuilder,
-        *this, *mInterface, *this};
-    camera3::requestStreamBuffers(states, bufReqs, _hidl_cb);
-    return hardware::Void();
-}
-
-hardware::Return<void> HidlCamera3Device::returnStreamBuffers(
-        const hardware::hidl_vec<hardware::camera::device::V3_2::StreamBuffer>& buffers) {
-    ReturnBufferStates states {
-        mId, mUseHalBufManager, mOutputStreams, mSessionStatsBuilder, *mInterface};
-    camera3::returnStreamBuffers(states, buffers);
-    return hardware::Void();
-}
-
-hardware::Return<void> HidlCamera3Device::processCaptureResult_3_4(
-        const hardware::hidl_vec<
-                hardware::camera::device::V3_4::CaptureResult>& results) {
-    // Ideally we should grab mLock, but that can lead to deadlock, and
-    // it's not super important to get up to date value of mStatus for this
-    // warning print, hence skipping the lock here
-    if (mStatus == STATUS_ERROR) {
-        // Per API contract, HAL should act as closed after device error
-        // But mStatus can be set to error by framework as well, so just log
-        // a warning here.
-        ALOGW("%s: received capture result in error state.", __FUNCTION__);
-    }
-
-    sp<NotificationListener> listener;
-    {
-        std::lock_guard<std::mutex> l(mOutputLock);
-        listener = mListener.promote();
-    }
-
-    if (mProcessCaptureResultLock.tryLock() != OK) {
-        // This should never happen; it indicates a wrong client implementation
-        // that doesn't follow the contract. But, we can be tolerant here.
-        ALOGE("%s: callback overlapped! waiting 1s...",
-                __FUNCTION__);
-        if (mProcessCaptureResultLock.timedLock(1000000000 /* 1s */) != OK) {
-            ALOGE("%s: cannot acquire lock in 1s, dropping results",
-                    __FUNCTION__);
-            // really don't know what to do, so bail out.
-            return hardware::Void();
-        }
-    }
-    HidlCaptureOutputStates states {
-       {
-        mId,
-        mInFlightLock, mLastCompletedRegularFrameNumber,
-        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
-        mInFlightMap, mOutputLock,  mResultQueue, mResultSignal,
-        mNextShutterFrameNumber,
-        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
-        mNextResultFrameNumber,
-        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
-        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
-        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
-        mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
-        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this, *this,
-        *mInterface, mLegacyClient, mMinExpectedDuration}, mResultMetadataQueue
-    };
-
-    //HidlCaptureOutputStates hidlStates {
-    //}
-
-    for (const auto& result : results) {
-        processOneCaptureResultLocked(states, result.v3_2, result.physicalCameraMetadata);
-    }
-    mProcessCaptureResultLock.unlock();
-    return hardware::Void();
-}
-
-// Only one processCaptureResult should be called at a time, so
-// the locks won't block. The locks are present here simply to enforce this.
-hardware::Return<void> HidlCamera3Device::processCaptureResult(
-        const hardware::hidl_vec<
-                hardware::camera::device::V3_2::CaptureResult>& results) {
-    hardware::hidl_vec<hardware::camera::device::V3_4::PhysicalCameraMetadata> noPhysMetadata;
-
-    // Ideally we should grab mLock, but that can lead to deadlock, and
-    // it's not super important to get up to date value of mStatus for this
-    // warning print, hence skipping the lock here
-    if (mStatus == STATUS_ERROR) {
-        // Per API contract, HAL should act as closed after device error
-        // But mStatus can be set to error by framework as well, so just log
-        // a warning here.
-        ALOGW("%s: received capture result in error state.", __FUNCTION__);
-    }
-
-    sp<NotificationListener> listener;
-    {
-        std::lock_guard<std::mutex> l(mOutputLock);
-        listener = mListener.promote();
-    }
-
-    if (mProcessCaptureResultLock.tryLock() != OK) {
-        // This should never happen; it indicates a wrong client implementation
-        // that doesn't follow the contract. But, we can be tolerant here.
-        ALOGE("%s: callback overlapped! waiting 1s...",
-                __FUNCTION__);
-        if (mProcessCaptureResultLock.timedLock(1000000000 /* 1s */) != OK) {
-            ALOGE("%s: cannot acquire lock in 1s, dropping results",
-                    __FUNCTION__);
-            // really don't know what to do, so bail out.
-            return hardware::Void();
-        }
-    }
-
-    HidlCaptureOutputStates states {
-      {mId,
-        mInFlightLock, mLastCompletedRegularFrameNumber,
-        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
-        mInFlightMap, mOutputLock,  mResultQueue, mResultSignal,
-        mNextShutterFrameNumber,
-        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
-        mNextResultFrameNumber,
-        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
-        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
-        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
-        mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
-        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this, *this,
-        *mInterface, mLegacyClient, mMinExpectedDuration}, mResultMetadataQueue
-    };
-
-    for (const auto& result : results) {
-        processOneCaptureResultLocked(states, result, noPhysMetadata);
-    }
-    mProcessCaptureResultLock.unlock();
-    return hardware::Void();
-}
-
-hardware::Return<void> HidlCamera3Device::notify(
-        const hardware::hidl_vec<hardware::camera::device::V3_2::NotifyMsg>& msgs) {
-    return notifyHelper<hardware::camera::device::V3_2::NotifyMsg>(msgs);
-}
-
-template<typename NotifyMsgType>
-hardware::Return<void> HidlCamera3Device::notifyHelper(
-        const hardware::hidl_vec<NotifyMsgType>& msgs) {
-    // Ideally we should grab mLock, but that can lead to deadlock, and
-    // it's not super important to get up to date value of mStatus for this
-    // warning print, hence skipping the lock here
-    if (mStatus == STATUS_ERROR) {
-        // Per API contract, HAL should act as closed after device error
-        // But mStatus can be set to error by framework as well, so just log
-        // a warning here.
-        ALOGW("%s: received notify message in error state.", __FUNCTION__);
-    }
-
-    sp<NotificationListener> listener;
-    {
-        std::lock_guard<std::mutex> l(mOutputLock);
-        listener = mListener.promote();
-    }
-
-    HidlCaptureOutputStates states {
-      {mId,
-        mInFlightLock, mLastCompletedRegularFrameNumber,
-        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
-        mInFlightMap, mOutputLock,  mResultQueue, mResultSignal,
-        mNextShutterFrameNumber,
-        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
-        mNextResultFrameNumber,
-        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
-        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
-        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
-        mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
-        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this, *this,
-        *mInterface, mLegacyClient, mMinExpectedDuration}, mResultMetadataQueue
-    };
-    for (const auto& msg : msgs) {
-        camera3::notify(states, msg);
-    }
-    return hardware::Void();
-}
-
-status_t HidlCamera3Device::switchToOffline(
-        const std::vector<int32_t>& streamsToKeep,
-        /*out*/ sp<CameraOfflineSessionBase>* session) {
-    ATRACE_CALL();
-    if (session == nullptr) {
-        ALOGE("%s: session must not be null", __FUNCTION__);
-        return BAD_VALUE;
-    }
-
-    Mutex::Autolock il(mInterfaceLock);
-
-    bool hasInputStream = mInputStream != nullptr;
-    int32_t inputStreamId = hasInputStream ? mInputStream->getId() : -1;
-    bool inputStreamSupportsOffline = hasInputStream ?
-            mInputStream->getOfflineProcessingSupport() : false;
-    auto outputStreamIds = mOutputStreams.getStreamIds();
-    auto streamIds = outputStreamIds;
-    if (hasInputStream) {
-        streamIds.push_back(mInputStream->getId());
-    }
-
-    // Check all streams in streamsToKeep supports offline mode
-    for (auto id : streamsToKeep) {
-        if (std::find(streamIds.begin(), streamIds.end(), id) == streamIds.end()) {
-            ALOGE("%s: Unknown stream ID %d", __FUNCTION__, id);
-            return BAD_VALUE;
-        } else if (id == inputStreamId) {
-            if (!inputStreamSupportsOffline) {
-                ALOGE("%s: input stream %d cannot be switched to offline",
-                        __FUNCTION__, id);
-                return BAD_VALUE;
-            }
-        } else {
-            sp<camera3::Camera3OutputStreamInterface> stream = mOutputStreams.get(id);
-            if (!stream->getOfflineProcessingSupport()) {
-                ALOGE("%s: output stream %d cannot be switched to offline",
-                        __FUNCTION__, id);
-                return BAD_VALUE;
-            }
-        }
-    }
-    // TODO: block surface sharing and surface group streams until we can support them
-
-    // Stop repeating request, wait until all remaining requests are submitted, then call into
-    // HAL switchToOffline
-    hardware::camera::device::V3_6::CameraOfflineSessionInfo offlineSessionInfo;
-    sp<hardware::camera::device::V3_6::ICameraOfflineSession> offlineSession;
-    camera3::BufferRecords bufferRecords;
-    status_t ret = static_cast<HidlRequestThread *>(mRequestThread.get())->switchToOffline(
-            streamsToKeep, &offlineSessionInfo, &offlineSession, &bufferRecords);
-
-    if (ret != OK) {
-        SET_ERR("Switch to offline failed: %s (%d)", strerror(-ret), ret);
-        return ret;
-    }
-
-    bool succ = mRequestBufferSM.onSwitchToOfflineSuccess();
-    if (!succ) {
-        SET_ERR("HAL must not be calling requestStreamBuffers call");
-        // TODO: block ALL callbacks from HAL till app configured new streams?
-        return UNKNOWN_ERROR;
-    }
-
-    // Verify offlineSessionInfo
-    std::vector<int32_t> offlineStreamIds;
-    offlineStreamIds.reserve(offlineSessionInfo.offlineStreams.size());
-    for (auto offlineStream : offlineSessionInfo.offlineStreams) {
-        // verify stream IDs
-        int32_t id = offlineStream.id;
-        if (std::find(streamIds.begin(), streamIds.end(), id) == streamIds.end()) {
-            SET_ERR("stream ID %d not found!", id);
-            return UNKNOWN_ERROR;
-        }
-
-        // When not using HAL buf manager, only allow streams requested by app to be preserved
-        if (!mUseHalBufManager) {
-            if (std::find(streamsToKeep.begin(), streamsToKeep.end(), id) == streamsToKeep.end()) {
-                SET_ERR("stream ID %d must not be switched to offline!", id);
-                return UNKNOWN_ERROR;
-            }
-        }
-
-        offlineStreamIds.push_back(id);
-        sp<Camera3StreamInterface> stream = (id == inputStreamId) ?
-                static_cast<sp<Camera3StreamInterface>>(mInputStream) :
-                static_cast<sp<Camera3StreamInterface>>(mOutputStreams.get(id));
-        // Verify number of outstanding buffers
-        if (stream->getOutstandingBuffersCount() != offlineStream.numOutstandingBuffers) {
-            SET_ERR("Offline stream %d # of remaining buffer mismatch: (%zu,%d) (service/HAL)",
-                    id, stream->getOutstandingBuffersCount(), offlineStream.numOutstandingBuffers);
-            return UNKNOWN_ERROR;
-        }
-    }
-
-    // Verify all streams to be deleted don't have any outstanding buffers
-    if (hasInputStream && std::find(offlineStreamIds.begin(), offlineStreamIds.end(),
-                inputStreamId) == offlineStreamIds.end()) {
-        if (mInputStream->hasOutstandingBuffers()) {
-            SET_ERR("Input stream %d still has %zu outstanding buffer!",
-                    inputStreamId, mInputStream->getOutstandingBuffersCount());
-            return UNKNOWN_ERROR;
-        }
-    }
-
-    for (const auto& outStreamId : outputStreamIds) {
-        if (std::find(offlineStreamIds.begin(), offlineStreamIds.end(),
-                outStreamId) == offlineStreamIds.end()) {
-            auto outStream = mOutputStreams.get(outStreamId);
-            if (outStream->hasOutstandingBuffers()) {
-                SET_ERR("Output stream %d still has %zu outstanding buffer!",
-                        outStreamId, outStream->getOutstandingBuffersCount());
-                return UNKNOWN_ERROR;
-            }
-        }
-    }
-
-    InFlightRequestMap offlineReqs;
-    // Verify inflight requests and their pending buffers
-    {
-        std::lock_guard<std::mutex> l(mInFlightLock);
-        for (auto offlineReq : offlineSessionInfo.offlineRequests) {
-            int idx = mInFlightMap.indexOfKey(offlineReq.frameNumber);
-            if (idx == NAME_NOT_FOUND) {
-                SET_ERR("Offline request frame number %d not found!", offlineReq.frameNumber);
-                return UNKNOWN_ERROR;
-            }
-
-            const auto& inflightReq = mInFlightMap.valueAt(idx);
-            // TODO: check specific stream IDs
-            size_t numBuffersLeft = static_cast<size_t>(inflightReq.numBuffersLeft);
-            if (numBuffersLeft != offlineReq.pendingStreams.size()) {
-                SET_ERR("Offline request # of remaining buffer mismatch: (%d,%d) (service/HAL)",
-                        inflightReq.numBuffersLeft, offlineReq.pendingStreams.size());
-                return UNKNOWN_ERROR;
-            }
-            offlineReqs.add(offlineReq.frameNumber, inflightReq);
-        }
-    }
-
-    // Create Camera3OfflineSession and transfer object ownership
-    //   (streams, inflight requests, buffer caches)
-    camera3::StreamSet offlineStreamSet;
-    sp<camera3::Camera3Stream> inputStream;
-    for (auto offlineStream : offlineSessionInfo.offlineStreams) {
-        int32_t id = offlineStream.id;
-        if (mInputStream != nullptr && id == mInputStream->getId()) {
-            inputStream = mInputStream;
-        } else {
-            offlineStreamSet.add(id, mOutputStreams.get(id));
-        }
-    }
-
-    // TODO: check if we need to lock before copying states
-    //       though technically no other thread should be talking to Camera3Device at this point
-    Camera3OfflineStates offlineStates(
-            mTagMonitor, mVendorTagId, mUseHalBufManager, mNeedFixupMonochromeTags,
-            mUsePartialResult, mNumPartialResults, mLastCompletedRegularFrameNumber,
-            mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
-            mNextResultFrameNumber, mNextReprocessResultFrameNumber,
-            mNextZslStillResultFrameNumber, mNextShutterFrameNumber,
-            mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
-            mDeviceInfo, mPhysicalDeviceInfoMap, mDistortionMappers,
-            mZoomRatioMappers, mRotateAndCropMappers);
-
-    *session = new HidlCamera3OfflineSession(mId, inputStream, offlineStreamSet,
-            std::move(bufferRecords), offlineReqs, offlineStates, offlineSession);
-
-    // Delete all streams that has been transferred to offline session
-    Mutex::Autolock l(mLock);
-    for (auto offlineStream : offlineSessionInfo.offlineStreams) {
-        int32_t id = offlineStream.id;
-        if (mInputStream != nullptr && id == mInputStream->getId()) {
-            mInputStream.clear();
-        } else {
-            mOutputStreams.remove(id);
-        }
-    }
-
-    // disconnect all other streams and switch to UNCONFIGURED state
-    if (mInputStream != nullptr) {
-        ret = mInputStream->disconnect();
-        if (ret != OK) {
-            SET_ERR_L("disconnect input stream failed!");
-            return UNKNOWN_ERROR;
-        }
-    }
-
-    for (auto streamId : mOutputStreams.getStreamIds()) {
-        sp<Camera3StreamInterface> stream = mOutputStreams.get(streamId);
-        ret = stream->disconnect();
-        if (ret != OK) {
-            SET_ERR_L("disconnect output stream %d failed!", streamId);
-            return UNKNOWN_ERROR;
-        }
-    }
-
-    mInputStream.clear();
-    mOutputStreams.clear();
-    mNeedConfig = true;
-    internalUpdateStatusLocked(STATUS_UNCONFIGURED);
-    mOperatingMode = NO_MODE;
-    mIsConstrainedHighSpeedConfiguration = false;
-    mRequestThread->clearPreviousRequest();
-
-    return OK;
-    // TO be done by CameraDeviceClient/Camera3OfflineSession
-    // register the offline client to camera service
-    // Setup result passthing threads etc
-    // Initialize offline session so HAL can start sending callback to it (result Fmq)
-    // TODO: check how many onIdle callback will be sent
-    // Java side to make sure the CameraCaptureSession is properly closed
-}
-
-sp<Camera3Device::RequestThread> HidlCamera3Device::createNewRequestThread(
-                wp<Camera3Device> parent, sp<camera3::StatusTracker> statusTracker,
-                sp<Camera3Device::HalInterface> interface,
-                const Vector<int32_t>& sessionParamKeys,
-                bool useHalBufManager,
-                bool supportCameraMute) {
-        return new HidlRequestThread(parent, statusTracker, interface, sessionParamKeys,
-                useHalBufManager, supportCameraMute);
-};
-
-sp<Camera3Device::Camera3DeviceInjectionMethods>
-HidlCamera3Device::createCamera3DeviceInjectionMethods(wp<Camera3Device> parent) {
-    return new HidlCamera3DeviceInjectionMethods(parent);
-}
-
-status_t HidlCamera3Device::injectionCameraInitialize(const String8 &injectedCamId,
-            sp<CameraProviderManager> manager) {
-        return (static_cast<HidlCamera3DeviceInjectionMethods *>(
-                mInjectionMethods.get()))->injectionInitialize(injectedCamId, manager, this);
-};
-
-
-HidlCamera3Device::HidlHalInterface::HidlHalInterface(
-            sp<device::V3_2::ICameraDeviceSession> &session,
-            std::shared_ptr<RequestMetadataQueue> queue,
-            bool useHalBufManager, bool supportOfflineProcessing) :
-        HalInterface(useHalBufManager, supportOfflineProcessing),
-        mHidlSession(session),
-        mRequestMetadataQueue(queue) {
-    // Check with hardware service manager if we can downcast these interfaces
-    // Somewhat expensive, so cache the results at startup
-    auto castResult_3_7 = device::V3_7::ICameraDeviceSession::castFrom(mHidlSession);
-    if (castResult_3_7.isOk()) {
-        mHidlSession_3_7 = castResult_3_7;
-    }
-    auto castResult_3_6 = device::V3_6::ICameraDeviceSession::castFrom(mHidlSession);
-    if (castResult_3_6.isOk()) {
-        mHidlSession_3_6 = castResult_3_6;
-    }
-    auto castResult_3_5 = device::V3_5::ICameraDeviceSession::castFrom(mHidlSession);
-    if (castResult_3_5.isOk()) {
-        mHidlSession_3_5 = castResult_3_5;
-    }
-    auto castResult_3_4 = device::V3_4::ICameraDeviceSession::castFrom(mHidlSession);
-    if (castResult_3_4.isOk()) {
-        mHidlSession_3_4 = castResult_3_4;
-    }
-    auto castResult_3_3 = device::V3_3::ICameraDeviceSession::castFrom(mHidlSession);
-    if (castResult_3_3.isOk()) {
-        mHidlSession_3_3 = castResult_3_3;
-    }
-}
-
-bool HidlCamera3Device::HidlHalInterface::valid() {
-    return (mHidlSession != nullptr);
-}
-
-void HidlCamera3Device::HidlHalInterface::clear() {
-    mHidlSession_3_7.clear();
-    mHidlSession_3_6.clear();
-    mHidlSession_3_5.clear();
-    mHidlSession_3_4.clear();
-    mHidlSession_3_3.clear();
-    mHidlSession.clear();
-}
-
-status_t HidlCamera3Device::HidlHalInterface::constructDefaultRequestSettings(
-        camera_request_template_t templateId,
-        /*out*/ camera_metadata_t **requestTemplate) {
-    ATRACE_NAME("CameraHidlHal::constructDefaultRequestSettings");
-    if (!valid()) return INVALID_OPERATION;
-    status_t res = OK;
-
-    common::V1_0::Status status;
-
-    auto requestCallback = [&status, &requestTemplate]
-            (common::V1_0::Status s, const device::V3_2::CameraMetadata& request) {
-            status = s;
-            if (status == common::V1_0::Status::OK) {
-                const camera_metadata *r =
-                        reinterpret_cast<const camera_metadata_t*>(request.data());
-                size_t expectedSize = request.size();
-                int ret = validate_camera_metadata_structure(r, &expectedSize);
-                if (ret == OK || ret == CAMERA_METADATA_VALIDATION_SHIFTED) {
-                    *requestTemplate = clone_camera_metadata(r);
-                    if (*requestTemplate == nullptr) {
-                        ALOGE("%s: Unable to clone camera metadata received from HAL",
-                                __FUNCTION__);
-                        status = common::V1_0::Status::INTERNAL_ERROR;
-                    }
-                } else {
-                    ALOGE("%s: Malformed camera metadata received from HAL", __FUNCTION__);
-                    status = common::V1_0::Status::INTERNAL_ERROR;
-                }
-            }
-        };
-    hardware::Return<void> err;
-    RequestTemplate id;
-    switch (templateId) {
-        case CAMERA_TEMPLATE_PREVIEW:
-            id = RequestTemplate::PREVIEW;
-            break;
-        case CAMERA_TEMPLATE_STILL_CAPTURE:
-            id = RequestTemplate::STILL_CAPTURE;
-            break;
-        case CAMERA_TEMPLATE_VIDEO_RECORD:
-            id = RequestTemplate::VIDEO_RECORD;
-            break;
-        case CAMERA_TEMPLATE_VIDEO_SNAPSHOT:
-            id = RequestTemplate::VIDEO_SNAPSHOT;
-            break;
-        case CAMERA_TEMPLATE_ZERO_SHUTTER_LAG:
-            id = RequestTemplate::ZERO_SHUTTER_LAG;
-            break;
-        case CAMERA_TEMPLATE_MANUAL:
-            id = RequestTemplate::MANUAL;
-            break;
-        default:
-            // Unknown template ID, or this HAL is too old to support it
-            return BAD_VALUE;
-    }
-    err = mHidlSession->constructDefaultRequestSettings(id, requestCallback);
-
-    if (!err.isOk()) {
-        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
-        res = DEAD_OBJECT;
-    } else {
-        res = HidlProviderInfo::mapToStatusT(status);
-    }
-
-    return res;
-}
-
-bool HidlCamera3Device::HidlHalInterface::isReconfigurationRequired(
-        CameraMetadata& oldSessionParams, CameraMetadata& newSessionParams) {
-    // We do reconfiguration by default;
-    bool ret = true;
-    if ((mHidlSession_3_5 != nullptr) && mIsReconfigurationQuerySupported) {
-        android::hardware::hidl_vec<uint8_t> oldParams, newParams;
-        camera_metadata_t* oldSessioMeta = const_cast<camera_metadata_t*>(
-                oldSessionParams.getAndLock());
-        camera_metadata_t* newSessioMeta = const_cast<camera_metadata_t*>(
-                newSessionParams.getAndLock());
-        oldParams.setToExternal(reinterpret_cast<uint8_t*>(oldSessioMeta),
-                get_camera_metadata_size(oldSessioMeta));
-        newParams.setToExternal(reinterpret_cast<uint8_t*>(newSessioMeta),
-                get_camera_metadata_size(newSessioMeta));
-        hardware::camera::common::V1_0::Status callStatus;
-        bool required;
-        auto hidlCb = [&callStatus, &required] (hardware::camera::common::V1_0::Status s,
-                bool requiredFlag) {
-            callStatus = s;
-            required = requiredFlag;
-        };
-        auto err = mHidlSession_3_5->isReconfigurationRequired(oldParams, newParams, hidlCb);
-        oldSessionParams.unlock(oldSessioMeta);
-        newSessionParams.unlock(newSessioMeta);
-        if (err.isOk()) {
-            switch (callStatus) {
-                case hardware::camera::common::V1_0::Status::OK:
-                    ret = required;
-                    break;
-                case hardware::camera::common::V1_0::Status::METHOD_NOT_SUPPORTED:
-                    mIsReconfigurationQuerySupported = false;
-                    ret = true;
-                    break;
-                default:
-                    ALOGV("%s: Reconfiguration query failed: %d", __FUNCTION__, callStatus);
-                    ret = true;
-            }
-        } else {
-            ALOGE("%s: Unexpected binder error: %s", __FUNCTION__, err.description().c_str());
-            ret = true;
-        }
-    }
-
-    return ret;
-}
-
-status_t HidlCamera3Device::HidlHalInterface::configureStreams(
-        const camera_metadata_t *sessionParams,
-        camera_stream_configuration *config, const std::vector<uint32_t>& bufferSizes) {
-    ATRACE_NAME("CameraHal::configureStreams");
-    if (!valid()) return INVALID_OPERATION;
-    status_t res = OK;
-
-    if (config->input_is_multi_resolution && mHidlSession_3_7 == nullptr) {
-        ALOGE("%s: Camera device doesn't support multi-resolution input stream", __FUNCTION__);
-        return BAD_VALUE;
-    }
-
-    // Convert stream config to HIDL
-    std::set<int> activeStreams;
-    device::V3_2::StreamConfiguration requestedConfiguration3_2;
-    device::V3_4::StreamConfiguration requestedConfiguration3_4;
-    device::V3_7::StreamConfiguration requestedConfiguration3_7;
-    requestedConfiguration3_2.streams.resize(config->num_streams);
-    requestedConfiguration3_4.streams.resize(config->num_streams);
-    requestedConfiguration3_7.streams.resize(config->num_streams);
-    for (size_t i = 0; i < config->num_streams; i++) {
-        device::V3_2::Stream &dst3_2 = requestedConfiguration3_2.streams[i];
-        device::V3_4::Stream &dst3_4 = requestedConfiguration3_4.streams[i];
-        device::V3_7::Stream &dst3_7 = requestedConfiguration3_7.streams[i];
-        camera3::camera_stream_t *src = config->streams[i];
-
-        Camera3Stream* cam3stream = Camera3Stream::cast(src);
-        cam3stream->setBufferFreedListener(this);
-        int streamId = cam3stream->getId();
-        StreamType streamType;
-        switch (src->stream_type) {
-            case CAMERA_STREAM_OUTPUT:
-                streamType = StreamType::OUTPUT;
-                break;
-            case CAMERA_STREAM_INPUT:
-                streamType = StreamType::INPUT;
-                break;
-            default:
-                ALOGE("%s: Stream %d: Unsupported stream type %d",
-                        __FUNCTION__, streamId, config->streams[i]->stream_type);
-                return BAD_VALUE;
-        }
-        dst3_2.id = streamId;
-        dst3_2.streamType = streamType;
-        dst3_2.width = src->width;
-        dst3_2.height = src->height;
-        dst3_2.usage = mapToConsumerUsage(cam3stream->getUsage());
-        dst3_2.rotation = mapToStreamRotation((camera_stream_rotation_t) src->rotation);
-        // For HidlSession version 3.5 or newer, the format and dataSpace sent
-        // to HAL are original, not the overridden ones.
-        if (mHidlSession_3_5 != nullptr) {
-            dst3_2.format = mapToPixelFormat(cam3stream->isFormatOverridden() ?
-                    cam3stream->getOriginalFormat() : src->format);
-            dst3_2.dataSpace = mapToHidlDataspace(cam3stream->isDataSpaceOverridden() ?
-                    cam3stream->getOriginalDataSpace() : src->data_space);
-        } else {
-            dst3_2.format = mapToPixelFormat(src->format);
-            dst3_2.dataSpace = mapToHidlDataspace(src->data_space);
-        }
-        dst3_4.v3_2 = dst3_2;
-        dst3_4.bufferSize = bufferSizes[i];
-        if (src->physical_camera_id != nullptr) {
-            dst3_4.physicalCameraId = src->physical_camera_id;
-        }
-        dst3_7.v3_4 = dst3_4;
-        dst3_7.groupId = cam3stream->getHalStreamGroupId();
-        dst3_7.sensorPixelModesUsed.resize(src->sensor_pixel_modes_used.size());
-        size_t j = 0;
-        for (int mode : src->sensor_pixel_modes_used) {
-            dst3_7.sensorPixelModesUsed[j++] =
-                    static_cast<CameraMetadataEnumAndroidSensorPixelMode>(mode);
-        }
-        if (src->dynamic_range_profile !=
-                    ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD) {
-            ALOGE("%s: Camera device doesn't support non-standard dynamic range profiles: %" PRIx64,
-                    __FUNCTION__, src->dynamic_range_profile);
-            return BAD_VALUE;
-        }
-        if (src->use_case != ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT) {
-            ALOGE("%s: Camera device doesn't support non-default stream use case %" PRId64 "!",
-                    __FUNCTION__, src->use_case);
-            return BAD_VALUE;
-        }
-        activeStreams.insert(streamId);
-        // Create Buffer ID map if necessary
-        mBufferRecords.tryCreateBufferCache(streamId);
-    }
-    // remove BufferIdMap for deleted streams
-    mBufferRecords.removeInactiveBufferCaches(activeStreams);
-
-    StreamConfigurationMode operationMode;
-    res = mapToStreamConfigurationMode(
-            (camera_stream_configuration_mode_t) config->operation_mode,
-            /*out*/ &operationMode);
-    if (res != OK) {
-        return res;
-    }
-    requestedConfiguration3_2.operationMode = operationMode;
-    requestedConfiguration3_4.operationMode = operationMode;
-    requestedConfiguration3_7.operationMode = operationMode;
-    size_t sessionParamSize = get_camera_metadata_size(sessionParams);
-    requestedConfiguration3_4.sessionParams.setToExternal(
-            reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(sessionParams)),
-            sessionParamSize);
-    requestedConfiguration3_7.sessionParams.setToExternal(
-            reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(sessionParams)),
-            sessionParamSize);
-
-    // Invoke configureStreams
-    device::V3_3::HalStreamConfiguration finalConfiguration;
-    device::V3_4::HalStreamConfiguration finalConfiguration3_4;
-    device::V3_6::HalStreamConfiguration finalConfiguration3_6;
-    common::V1_0::Status status;
-
-    auto configStream34Cb = [&status, &finalConfiguration3_4]
-            (common::V1_0::Status s, const device::V3_4::HalStreamConfiguration& halConfiguration) {
-                finalConfiguration3_4 = halConfiguration;
-                status = s;
-            };
-
-    auto configStream36Cb = [&status, &finalConfiguration3_6]
-            (common::V1_0::Status s, const device::V3_6::HalStreamConfiguration& halConfiguration) {
-                finalConfiguration3_6 = halConfiguration;
-                status = s;
-            };
-
-    auto postprocConfigStream34 = [&finalConfiguration, &finalConfiguration3_4]
-            (hardware::Return<void>& err) -> status_t {
-                if (!err.isOk()) {
-                    ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
-                    return DEAD_OBJECT;
-                }
-                finalConfiguration.streams.resize(finalConfiguration3_4.streams.size());
-                for (size_t i = 0; i < finalConfiguration3_4.streams.size(); i++) {
-                    finalConfiguration.streams[i] = finalConfiguration3_4.streams[i].v3_3;
-                }
-                return OK;
-            };
-
-    auto postprocConfigStream36 = [&finalConfiguration, &finalConfiguration3_6]
-            (hardware::Return<void>& err) -> status_t {
-                if (!err.isOk()) {
-                    ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
-                    return DEAD_OBJECT;
-                }
-                finalConfiguration.streams.resize(finalConfiguration3_6.streams.size());
-                for (size_t i = 0; i < finalConfiguration3_6.streams.size(); i++) {
-                    finalConfiguration.streams[i] = finalConfiguration3_6.streams[i].v3_4.v3_3;
-                }
-                return OK;
-            };
-
-    if (mHidlSession_3_7 != nullptr) {
-        ALOGV("%s: v3.7 device found", __FUNCTION__);
-        requestedConfiguration3_7.streamConfigCounter = mNextStreamConfigCounter++;
-        requestedConfiguration3_7.multiResolutionInputImage = config->input_is_multi_resolution;
-        auto err = mHidlSession_3_7->configureStreams_3_7(
-                requestedConfiguration3_7, configStream36Cb);
-        res = postprocConfigStream36(err);
-        if (res != OK) {
-            return res;
-        }
-    } else if (mHidlSession_3_6 != nullptr) {
-        ALOGV("%s: v3.6 device found", __FUNCTION__);
-        device::V3_5::StreamConfiguration requestedConfiguration3_5;
-        requestedConfiguration3_5.v3_4 = requestedConfiguration3_4;
-        requestedConfiguration3_5.streamConfigCounter = mNextStreamConfigCounter++;
-        auto err = mHidlSession_3_6->configureStreams_3_6(
-                requestedConfiguration3_5, configStream36Cb);
-        res = postprocConfigStream36(err);
-        if (res != OK) {
-            return res;
-        }
-    } else if (mHidlSession_3_5 != nullptr) {
-        ALOGV("%s: v3.5 device found", __FUNCTION__);
-        device::V3_5::StreamConfiguration requestedConfiguration3_5;
-        requestedConfiguration3_5.v3_4 = requestedConfiguration3_4;
-        requestedConfiguration3_5.streamConfigCounter = mNextStreamConfigCounter++;
-        auto err = mHidlSession_3_5->configureStreams_3_5(
-                requestedConfiguration3_5, configStream34Cb);
-        res = postprocConfigStream34(err);
-        if (res != OK) {
-            return res;
-        }
-    } else if (mHidlSession_3_4 != nullptr) {
-        // We do; use v3.4 for the call
-        ALOGV("%s: v3.4 device found", __FUNCTION__);
-        auto err = mHidlSession_3_4->configureStreams_3_4(
-                requestedConfiguration3_4, configStream34Cb);
-        res = postprocConfigStream34(err);
-        if (res != OK) {
-            return res;
-        }
-    } else if (mHidlSession_3_3 != nullptr) {
-        // We do; use v3.3 for the call
-        ALOGV("%s: v3.3 device found", __FUNCTION__);
-        auto err = mHidlSession_3_3->configureStreams_3_3(requestedConfiguration3_2,
-            [&status, &finalConfiguration]
-            (common::V1_0::Status s, const device::V3_3::HalStreamConfiguration& halConfiguration) {
-                finalConfiguration = halConfiguration;
-                status = s;
-            });
-        if (!err.isOk()) {
-            ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
-            return DEAD_OBJECT;
-        }
-    } else {
-        // We don't; use v3.2 call and construct a v3.3 HalStreamConfiguration
-        ALOGV("%s: v3.2 device found", __FUNCTION__);
-        HalStreamConfiguration finalConfiguration_3_2;
-        auto err = mHidlSession->configureStreams(requestedConfiguration3_2,
-                [&status, &finalConfiguration_3_2]
-                (common::V1_0::Status s, const HalStreamConfiguration& halConfiguration) {
-                    finalConfiguration_3_2 = halConfiguration;
-                    status = s;
-                });
-        if (!err.isOk()) {
-            ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
-            return DEAD_OBJECT;
-        }
-        finalConfiguration.streams.resize(finalConfiguration_3_2.streams.size());
-        for (size_t i = 0; i < finalConfiguration_3_2.streams.size(); i++) {
-            finalConfiguration.streams[i].v3_2 = finalConfiguration_3_2.streams[i];
-            finalConfiguration.streams[i].overrideDataSpace =
-                    requestedConfiguration3_2.streams[i].dataSpace;
-        }
-    }
-
-    if (status != common::V1_0::Status::OK ) {
-        return HidlProviderInfo::mapToStatusT(status);
-    }
-
-    // And convert output stream configuration from HIDL
-
-    for (size_t i = 0; i < config->num_streams; i++) {
-        camera3::camera_stream_t *dst = config->streams[i];
-        int streamId = Camera3Stream::cast(dst)->getId();
-
-        // Start scan at i, with the assumption that the stream order matches
-        size_t realIdx = i;
-        bool found = false;
-        size_t halStreamCount = finalConfiguration.streams.size();
-        for (size_t idx = 0; idx < halStreamCount; idx++) {
-            if (finalConfiguration.streams[realIdx].v3_2.id == streamId) {
-                found = true;
-                break;
-            }
-            realIdx = (realIdx >= halStreamCount - 1) ? 0 : realIdx + 1;
-        }
-        if (!found) {
-            ALOGE("%s: Stream %d not found in stream configuration response from HAL",
-                    __FUNCTION__, streamId);
-            return INVALID_OPERATION;
-        }
-        device::V3_3::HalStream &src = finalConfiguration.streams[realIdx];
-        device::V3_6::HalStream &src_36 = finalConfiguration3_6.streams[realIdx];
-
-        Camera3Stream* dstStream = Camera3Stream::cast(dst);
-        int overrideFormat = mapToFrameworkFormat(src.v3_2.overrideFormat);
-        android_dataspace overrideDataSpace = mapToFrameworkDataspace(src.overrideDataSpace);
-
-        if (mHidlSession_3_6 != nullptr) {
-            dstStream->setOfflineProcessingSupport(src_36.supportOffline);
-        }
-
-        if (dstStream->getOriginalFormat() != HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED) {
-            dstStream->setFormatOverride(false);
-            dstStream->setDataSpaceOverride(false);
-            if (dst->format != overrideFormat) {
-                ALOGE("%s: Stream %d: Format override not allowed for format 0x%x", __FUNCTION__,
-                        streamId, dst->format);
-            }
-            if (dst->data_space != overrideDataSpace) {
-                ALOGE("%s: Stream %d: DataSpace override not allowed for format 0x%x", __FUNCTION__,
-                        streamId, dst->format);
-            }
-        } else {
-            bool needFormatOverride =
-                    requestedConfiguration3_2.streams[i].format != src.v3_2.overrideFormat;
-            bool needDataspaceOverride =
-                    requestedConfiguration3_2.streams[i].dataSpace != src.overrideDataSpace;
-            // Override allowed with IMPLEMENTATION_DEFINED
-            dstStream->setFormatOverride(needFormatOverride);
-            dstStream->setDataSpaceOverride(needDataspaceOverride);
-            dst->format = overrideFormat;
-            dst->data_space = overrideDataSpace;
-        }
-
-        if (dst->stream_type == CAMERA_STREAM_INPUT) {
-            if (src.v3_2.producerUsage != 0) {
-                ALOGE("%s: Stream %d: INPUT streams must have 0 for producer usage",
-                        __FUNCTION__, streamId);
-                return INVALID_OPERATION;
-            }
-            dstStream->setUsage(
-                    mapConsumerToFrameworkUsage(src.v3_2.consumerUsage));
-        } else {
-            // OUTPUT
-            if (src.v3_2.consumerUsage != 0) {
-                ALOGE("%s: Stream %d: OUTPUT streams must have 0 for consumer usage",
-                        __FUNCTION__, streamId);
-                return INVALID_OPERATION;
-            }
-            dstStream->setUsage(
-                    mapProducerToFrameworkUsage(src.v3_2.producerUsage));
-        }
-        dst->max_buffers = src.v3_2.maxBuffers;
-    }
-
-    return res;
-}
-
-status_t HidlCamera3Device::HidlHalInterface::configureInjectedStreams(
-        const camera_metadata_t* sessionParams, camera_stream_configuration* config,
-        const std::vector<uint32_t>& bufferSizes,
-        const CameraMetadata& cameraCharacteristics) {
-    ATRACE_NAME("InjectionCameraHal::configureStreams");
-    if (!valid()) return INVALID_OPERATION;
-    status_t res = OK;
-
-    if (config->input_is_multi_resolution) {
-        ALOGE("%s: Injection camera device doesn't support multi-resolution input "
-                "stream", __FUNCTION__);
-        return BAD_VALUE;
-    }
-
-    // Convert stream config to HIDL
-    std::set<int> activeStreams;
-    device::V3_2::StreamConfiguration requestedConfiguration3_2;
-    device::V3_4::StreamConfiguration requestedConfiguration3_4;
-    device::V3_7::StreamConfiguration requestedConfiguration3_7;
-    requestedConfiguration3_2.streams.resize(config->num_streams);
-    requestedConfiguration3_4.streams.resize(config->num_streams);
-    requestedConfiguration3_7.streams.resize(config->num_streams);
-    for (size_t i = 0; i < config->num_streams; i++) {
-        device::V3_2::Stream& dst3_2 = requestedConfiguration3_2.streams[i];
-        device::V3_4::Stream& dst3_4 = requestedConfiguration3_4.streams[i];
-        device::V3_7::Stream& dst3_7 = requestedConfiguration3_7.streams[i];
-        camera3::camera_stream_t* src = config->streams[i];
-
-        Camera3Stream* cam3stream = Camera3Stream::cast(src);
-        cam3stream->setBufferFreedListener(this);
-        int streamId = cam3stream->getId();
-        StreamType streamType;
-        switch (src->stream_type) {
-            case CAMERA_STREAM_OUTPUT:
-                streamType = StreamType::OUTPUT;
-                break;
-            case CAMERA_STREAM_INPUT:
-                streamType = StreamType::INPUT;
-                break;
-            default:
-                ALOGE("%s: Stream %d: Unsupported stream type %d", __FUNCTION__,
-                        streamId, config->streams[i]->stream_type);
-            return BAD_VALUE;
-        }
-        dst3_2.id = streamId;
-        dst3_2.streamType = streamType;
-        dst3_2.width = src->width;
-        dst3_2.height = src->height;
-        dst3_2.usage = mapToConsumerUsage(cam3stream->getUsage());
-        dst3_2.rotation =
-                mapToStreamRotation((camera_stream_rotation_t)src->rotation);
-        // For HidlSession version 3.5 or newer, the format and dataSpace sent
-        // to HAL are original, not the overridden ones.
-        if (mHidlSession_3_5 != nullptr) {
-            dst3_2.format = mapToPixelFormat(cam3stream->isFormatOverridden()
-                                            ? cam3stream->getOriginalFormat()
-                                            : src->format);
-            dst3_2.dataSpace =
-                    mapToHidlDataspace(cam3stream->isDataSpaceOverridden()
-                                    ? cam3stream->getOriginalDataSpace()
-                                    : src->data_space);
-        } else {
-            dst3_2.format = mapToPixelFormat(src->format);
-            dst3_2.dataSpace = mapToHidlDataspace(src->data_space);
-        }
-        dst3_4.v3_2 = dst3_2;
-        dst3_4.bufferSize = bufferSizes[i];
-        if (src->physical_camera_id != nullptr) {
-            dst3_4.physicalCameraId = src->physical_camera_id;
-        }
-        dst3_7.v3_4 = dst3_4;
-        dst3_7.groupId = cam3stream->getHalStreamGroupId();
-        dst3_7.sensorPixelModesUsed.resize(src->sensor_pixel_modes_used.size());
-        size_t j = 0;
-        for (int mode : src->sensor_pixel_modes_used) {
-            dst3_7.sensorPixelModesUsed[j++] =
-                    static_cast<CameraMetadataEnumAndroidSensorPixelMode>(mode);
-        }
-        activeStreams.insert(streamId);
-        // Create Buffer ID map if necessary
-        mBufferRecords.tryCreateBufferCache(streamId);
-    }
-    // remove BufferIdMap for deleted streams
-    mBufferRecords.removeInactiveBufferCaches(activeStreams);
-
-    StreamConfigurationMode operationMode;
-    res = mapToStreamConfigurationMode(
-            (camera_stream_configuration_mode_t)config->operation_mode,
-            /*out*/ &operationMode);
-    if (res != OK) {
-        return res;
-    }
-    requestedConfiguration3_7.operationMode = operationMode;
-    size_t sessionParamSize = get_camera_metadata_size(sessionParams);
-    requestedConfiguration3_7.operationMode = operationMode;
-    requestedConfiguration3_7.sessionParams.setToExternal(
-            reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(sessionParams)),
-            sessionParamSize);
-
-    // See which version of HAL we have
-    if (mHidlSession_3_7 != nullptr) {
-        requestedConfiguration3_7.streamConfigCounter = mNextStreamConfigCounter++;
-        requestedConfiguration3_7.multiResolutionInputImage =
-                config->input_is_multi_resolution;
-
-        const camera_metadata_t* rawMetadata = cameraCharacteristics.getAndLock();
-        ::android::hardware::camera::device::V3_2::CameraMetadata hidlChars = {};
-        hidlChars.setToExternal(
-                reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(rawMetadata)),
-                get_camera_metadata_size(rawMetadata));
-        cameraCharacteristics.unlock(rawMetadata);
-
-        sp<hardware::camera::device::V3_7::ICameraInjectionSession>
-                hidlInjectionSession_3_7;
-        auto castInjectionResult_3_7 =
-                device::V3_7::ICameraInjectionSession::castFrom(mHidlSession_3_7);
-        if (castInjectionResult_3_7.isOk()) {
-            hidlInjectionSession_3_7 = castInjectionResult_3_7;
-        } else {
-            ALOGE("%s: Transaction error: %s", __FUNCTION__,
-                    castInjectionResult_3_7.description().c_str());
-            return DEAD_OBJECT;
-        }
-
-        auto err = hidlInjectionSession_3_7->configureInjectionStreams(
-                requestedConfiguration3_7, hidlChars);
-        if (!err.isOk()) {
-            ALOGE("%s: Transaction error: %s", __FUNCTION__,
-                    err.description().c_str());
-            return DEAD_OBJECT;
-        }
-    } else {
-        ALOGE("%s: mHidlSession_3_7 does not exist, the lowest version of injection "
-                "session is 3.7", __FUNCTION__);
-        return DEAD_OBJECT;
-    }
-
-    return res;
-}
-
-status_t HidlCamera3Device::HidlHalInterface::wrapAsHidlRequest(camera_capture_request_t* request,
-        /*out*/device::V3_2::CaptureRequest* captureRequest,
-        /*out*/std::vector<native_handle_t*>* handlesCreated,
-        /*out*/std::vector<std::pair<int32_t, int32_t>>* inflightBuffers) {
-    ATRACE_CALL();
-    if (captureRequest == nullptr || handlesCreated == nullptr || inflightBuffers == nullptr) {
-        ALOGE("%s: captureRequest (%p), handlesCreated (%p), and inflightBuffers(%p) "
-                "must not be null", __FUNCTION__, captureRequest, handlesCreated, inflightBuffers);
-        return BAD_VALUE;
-    }
-
-    captureRequest->frameNumber = request->frame_number;
-
-    captureRequest->fmqSettingsSize = 0;
-
-    {
-        if (request->input_buffer != nullptr) {
-            int32_t streamId = Camera3Stream::cast(request->input_buffer->stream)->getId();
-            buffer_handle_t buf = *(request->input_buffer->buffer);
-            auto pair = getBufferId(buf, streamId);
-            bool isNewBuffer = pair.first;
-            uint64_t bufferId = pair.second;
-            captureRequest->inputBuffer.streamId = streamId;
-            captureRequest->inputBuffer.bufferId = bufferId;
-            captureRequest->inputBuffer.buffer = (isNewBuffer) ? buf : nullptr;
-            captureRequest->inputBuffer.status = BufferStatus::OK;
-            native_handle_t *acquireFence = nullptr;
-            if (request->input_buffer->acquire_fence != -1) {
-                acquireFence = native_handle_create(1,0);
-                acquireFence->data[0] = request->input_buffer->acquire_fence;
-                handlesCreated->push_back(acquireFence);
-            }
-            captureRequest->inputBuffer.acquireFence = acquireFence;
-            captureRequest->inputBuffer.releaseFence = nullptr;
-
-            mBufferRecords.pushInflightBuffer(captureRequest->frameNumber, streamId,
-                    request->input_buffer->buffer);
-            inflightBuffers->push_back(std::make_pair(captureRequest->frameNumber, streamId));
-        } else {
-            captureRequest->inputBuffer.streamId = -1;
-            captureRequest->inputBuffer.bufferId = BUFFER_ID_NO_BUFFER;
-        }
-
-        captureRequest->outputBuffers.resize(request->num_output_buffers);
-        for (size_t i = 0; i < request->num_output_buffers; i++) {
-            const camera_stream_buffer_t *src = request->output_buffers + i;
-            StreamBuffer &dst = captureRequest->outputBuffers[i];
-            int32_t streamId = Camera3Stream::cast(src->stream)->getId();
-            if (src->buffer != nullptr) {
-                buffer_handle_t buf = *(src->buffer);
-                auto pair = getBufferId(buf, streamId);
-                bool isNewBuffer = pair.first;
-                dst.bufferId = pair.second;
-                dst.buffer = isNewBuffer ? buf : nullptr;
-                native_handle_t *acquireFence = nullptr;
-                if (src->acquire_fence != -1) {
-                    acquireFence = native_handle_create(1,0);
-                    acquireFence->data[0] = src->acquire_fence;
-                    handlesCreated->push_back(acquireFence);
-                }
-                dst.acquireFence = acquireFence;
-            } else if (mUseHalBufManager) {
-                // HAL buffer management path
-                dst.bufferId = BUFFER_ID_NO_BUFFER;
-                dst.buffer = nullptr;
-                dst.acquireFence = nullptr;
-            } else {
-                ALOGE("%s: cannot send a null buffer in capture request!", __FUNCTION__);
-                return BAD_VALUE;
-            }
-            dst.streamId = streamId;
-            dst.status = BufferStatus::OK;
-            dst.releaseFence = nullptr;
-
-            // Output buffers are empty when using HAL buffer manager
-            if (!mUseHalBufManager) {
-                mBufferRecords.pushInflightBuffer(
-                        captureRequest->frameNumber, streamId, src->buffer);
-                inflightBuffers->push_back(std::make_pair(captureRequest->frameNumber, streamId));
-            }
-        }
-    }
-    return OK;
-}
-
-status_t HidlCamera3Device::HidlHalInterface::flush() {
-    ATRACE_NAME("CameraHal::flush");
-    if (!valid()) return INVALID_OPERATION;
-    status_t res = OK;
-
-    auto err = mHidlSession->flush();
-    if (!err.isOk()) {
-        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
-        res = DEAD_OBJECT;
-    } else {
-        res = HidlProviderInfo::mapToStatusT(err);
-    }
-
-    return res;
-}
-
-status_t HidlCamera3Device::HidlHalInterface::dump(int /*fd*/) {
-    ATRACE_NAME("CameraHal::dump");
-    if (!valid()) return INVALID_OPERATION;
-
-    // Handled by CameraProviderManager::dump
-
-    return OK;
-}
-
-status_t HidlCamera3Device::HidlHalInterface::repeatingRequestEnd(uint32_t /*frameNumber*/,
-        const std::vector<int32_t> &/*streamIds*/) {
-    ATRACE_NAME("CameraHal::repeatingRequestEnd");
-    return INVALID_OPERATION;
-}
-
-status_t HidlCamera3Device::HidlHalInterface::close() {
-    ATRACE_NAME("CameraHal::close()");
-    if (!valid()) return INVALID_OPERATION;
-    status_t res = OK;
-
-    auto err = mHidlSession->close();
-    // Interface will be dead shortly anyway, so don't log errors
-    if (!err.isOk()) {
-        res = DEAD_OBJECT;
-    }
-
-    return res;
-}
-
-void HidlCamera3Device::HidlHalInterface::signalPipelineDrain(const std::vector<int>& streamIds) {
-    ATRACE_NAME("CameraHal::signalPipelineDrain");
-    if (!valid() || mHidlSession_3_5 == nullptr) {
-        ALOGE("%s called on invalid camera!", __FUNCTION__);
-        return;
-    }
-
-    auto err = mHidlSession_3_5->signalStreamFlush(streamIds, mNextStreamConfigCounter - 1);
-    if (!err.isOk()) {
-        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
-        return;
-    }
-}
-
-status_t HidlCamera3Device::HidlHalInterface::processBatchCaptureRequests(
-        std::vector<camera_capture_request_t*>& requests,/*out*/uint32_t* numRequestProcessed) {
-    ATRACE_NAME("CameraHal::processBatchCaptureRequests");
-    if (!valid()) return INVALID_OPERATION;
-
-    sp<device::V3_4::ICameraDeviceSession> hidlSession_3_4;
-    sp<device::V3_7::ICameraDeviceSession> hidlSession_3_7;
-    auto castResult_3_7 = device::V3_7::ICameraDeviceSession::castFrom(mHidlSession);
-    if (castResult_3_7.isOk()) {
-        hidlSession_3_7 = castResult_3_7;
-    }
-    auto castResult_3_4 = device::V3_4::ICameraDeviceSession::castFrom(mHidlSession);
-    if (castResult_3_4.isOk()) {
-        hidlSession_3_4 = castResult_3_4;
-    }
-
-    hardware::hidl_vec<device::V3_2::CaptureRequest> captureRequests;
-    hardware::hidl_vec<device::V3_4::CaptureRequest> captureRequests_3_4;
-    hardware::hidl_vec<device::V3_7::CaptureRequest> captureRequests_3_7;
-    size_t batchSize = requests.size();
-    if (hidlSession_3_7 != nullptr) {
-        captureRequests_3_7.resize(batchSize);
-    } else if (hidlSession_3_4 != nullptr) {
-        captureRequests_3_4.resize(batchSize);
-    } else {
-        captureRequests.resize(batchSize);
-    }
-    std::vector<native_handle_t*> handlesCreated;
-    std::vector<std::pair<int32_t, int32_t>> inflightBuffers;
-
-    status_t res = OK;
-    for (size_t i = 0; i < batchSize; i++) {
-        if (hidlSession_3_7 != nullptr) {
-            res = wrapAsHidlRequest(requests[i], /*out*/&captureRequests_3_7[i].v3_4.v3_2,
-                    /*out*/&handlesCreated, /*out*/&inflightBuffers);
-        } else if (hidlSession_3_4 != nullptr) {
-            res = wrapAsHidlRequest(requests[i], /*out*/&captureRequests_3_4[i].v3_2,
-                    /*out*/&handlesCreated, /*out*/&inflightBuffers);
-        } else {
-            res = wrapAsHidlRequest(requests[i], /*out*/&captureRequests[i],
-                    /*out*/&handlesCreated, /*out*/&inflightBuffers);
-        }
-        if (res != OK) {
-            mBufferRecords.popInflightBuffers(inflightBuffers);
-            cleanupNativeHandles(&handlesCreated);
-            return res;
-        }
-    }
-
-    std::vector<device::V3_2::BufferCache> cachesToRemove;
-    {
-        std::lock_guard<std::mutex> lock(mFreedBuffersLock);
-        for (auto& pair : mFreedBuffers) {
-            // The stream might have been removed since onBufferFreed
-            if (mBufferRecords.isStreamCached(pair.first)) {
-                cachesToRemove.push_back({pair.first, pair.second});
-            }
-        }
-        mFreedBuffers.clear();
-    }
-
-    common::V1_0::Status status = common::V1_0::Status::INTERNAL_ERROR;
-    *numRequestProcessed = 0;
-
-    // Write metadata to FMQ.
-    for (size_t i = 0; i < batchSize; i++) {
-        camera_capture_request_t* request = requests[i];
-        device::V3_2::CaptureRequest* captureRequest;
-        if (hidlSession_3_7 != nullptr) {
-            captureRequest = &captureRequests_3_7[i].v3_4.v3_2;
-        } else if (hidlSession_3_4 != nullptr) {
-            captureRequest = &captureRequests_3_4[i].v3_2;
-        } else {
-            captureRequest = &captureRequests[i];
-        }
-
-        if (request->settings != nullptr) {
-            size_t settingsSize = get_camera_metadata_size(request->settings);
-            if (mRequestMetadataQueue != nullptr && mRequestMetadataQueue->write(
-                    reinterpret_cast<const uint8_t*>(request->settings), settingsSize)) {
-                captureRequest->settings.resize(0);
-                captureRequest->fmqSettingsSize = settingsSize;
-            } else {
-                if (mRequestMetadataQueue != nullptr) {
-                    ALOGW("%s: couldn't utilize fmq, fallback to hwbinder", __FUNCTION__);
-                }
-                captureRequest->settings.setToExternal(
-                        reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(
-                                request->settings)),
-                        get_camera_metadata_size(request->settings));
-                captureRequest->fmqSettingsSize = 0u;
-            }
-        } else {
-            // A null request settings maps to a size-0 CameraMetadata
-            captureRequest->settings.resize(0);
-            captureRequest->fmqSettingsSize = 0u;
-        }
-
-        // hidl session 3.7 specific handling.
-        if (hidlSession_3_7 != nullptr) {
-            captureRequests_3_7[i].inputWidth = request->input_width;
-            captureRequests_3_7[i].inputHeight = request->input_height;
-        }
-
-        // hidl session 3.7 and 3.4 specific handling.
-        if (hidlSession_3_7 != nullptr || hidlSession_3_4 != nullptr) {
-            hardware::hidl_vec<device::V3_4::PhysicalCameraSetting>& physicalCameraSettings =
-                    (hidlSession_3_7 != nullptr) ?
-                    captureRequests_3_7[i].v3_4.physicalCameraSettings :
-                    captureRequests_3_4[i].physicalCameraSettings;
-            physicalCameraSettings.resize(request->num_physcam_settings);
-            for (size_t j = 0; j < request->num_physcam_settings; j++) {
-                if (request->physcam_settings != nullptr) {
-                    size_t settingsSize = get_camera_metadata_size(request->physcam_settings[j]);
-                    if (mRequestMetadataQueue != nullptr && mRequestMetadataQueue->write(
-                                reinterpret_cast<const uint8_t*>(request->physcam_settings[j]),
-                                settingsSize)) {
-                        physicalCameraSettings[j].settings.resize(0);
-                        physicalCameraSettings[j].fmqSettingsSize = settingsSize;
-                    } else {
-                        if (mRequestMetadataQueue != nullptr) {
-                            ALOGW("%s: couldn't utilize fmq, fallback to hwbinder", __FUNCTION__);
-                        }
-                        physicalCameraSettings[j].settings.setToExternal(
-                                reinterpret_cast<uint8_t*>(const_cast<camera_metadata_t*>(
-                                        request->physcam_settings[j])),
-                                get_camera_metadata_size(request->physcam_settings[j]));
-                        physicalCameraSettings[j].fmqSettingsSize = 0u;
-                    }
-                } else {
-                    physicalCameraSettings[j].fmqSettingsSize = 0u;
-                    physicalCameraSettings[j].settings.resize(0);
-                }
-                physicalCameraSettings[j].physicalCameraId = request->physcam_id[j];
-            }
-        }
-    }
-
-    hardware::details::return_status err;
-    auto resultCallback =
-        [&status, &numRequestProcessed] (auto s, uint32_t n) {
-                status = s;
-                *numRequestProcessed = n;
-        };
-    if (hidlSession_3_7 != nullptr) {
-        err = hidlSession_3_7->processCaptureRequest_3_7(captureRequests_3_7, cachesToRemove,
-                                                         resultCallback);
-    } else if (hidlSession_3_4 != nullptr) {
-        err = hidlSession_3_4->processCaptureRequest_3_4(captureRequests_3_4, cachesToRemove,
-                                                         resultCallback);
-    } else {
-        err = mHidlSession->processCaptureRequest(captureRequests, cachesToRemove,
-                                                  resultCallback);
-    }
-    if (!err.isOk()) {
-        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
-        status = common::V1_0::Status::CAMERA_DISCONNECTED;
-    }
-
-    if (status == common::V1_0::Status::OK && *numRequestProcessed != batchSize) {
-        ALOGE("%s: processCaptureRequest returns OK but processed %d/%zu requests",
-                __FUNCTION__, *numRequestProcessed, batchSize);
-        status = common::V1_0::Status::INTERNAL_ERROR;
-    }
-
-    res = HidlProviderInfo::mapToStatusT(status);
-    if (res == OK) {
-        if (mHidlSession->isRemote()) {
-            // Only close acquire fence FDs when the HIDL transaction succeeds (so the FDs have been
-            // sent to camera HAL processes)
-            cleanupNativeHandles(&handlesCreated, /*closeFd*/true);
-        } else {
-            // In passthrough mode the FDs are now owned by HAL
-            cleanupNativeHandles(&handlesCreated);
-        }
-    } else {
-        mBufferRecords.popInflightBuffers(inflightBuffers);
-        cleanupNativeHandles(&handlesCreated);
-    }
-    return res;
-}
-
-status_t HidlCamera3Device::HidlHalInterface::switchToOffline(
-        const std::vector<int32_t>& streamsToKeep,
-        /*out*/hardware::camera::device::V3_6::CameraOfflineSessionInfo* offlineSessionInfo,
-        /*out*/sp<hardware::camera::device::V3_6::ICameraOfflineSession>* offlineSession,
-        /*out*/camera3::BufferRecords* bufferRecords) {
-    ATRACE_NAME("CameraHal::switchToOffline");
-    if (!valid() || mHidlSession_3_6 == nullptr) {
-        ALOGE("%s called on invalid camera!", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-
-    if (offlineSessionInfo == nullptr || offlineSession == nullptr || bufferRecords == nullptr) {
-        ALOGE("%s: output arguments must not be null!", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-
-    common::V1_0::Status status = common::V1_0::Status::INTERNAL_ERROR;
-    auto resultCallback =
-        [&status, &offlineSessionInfo, &offlineSession] (auto s, auto info, auto session) {
-                status = s;
-                *offlineSessionInfo = info;
-                *offlineSession = session;
-        };
-    auto err = mHidlSession_3_6->switchToOffline(streamsToKeep, resultCallback);
-
-    if (!err.isOk()) {
-        ALOGE("%s: Transaction error: %s", __FUNCTION__, err.description().c_str());
-        return DEAD_OBJECT;
-    }
-
-    status_t ret = HidlProviderInfo::mapToStatusT(status);
-    if (ret != OK) {
-        return ret;
-    }
-
-    return verifyBufferCaches(offlineSessionInfo, bufferRecords);
-}
-
-HidlCamera3Device::HidlRequestThread::HidlRequestThread(wp<Camera3Device> parent,
-                sp<camera3::StatusTracker> statusTracker,
-                sp<HalInterface> interface,
-                const Vector<int32_t>& sessionParamKeys,
-                bool useHalBufManager,
-                bool supportCameraMute) :
-          RequestThread(parent, statusTracker, interface, sessionParamKeys, useHalBufManager,
-                  supportCameraMute) {}
-
-status_t HidlCamera3Device::HidlRequestThread::switchToOffline(
-        const std::vector<int32_t>& streamsToKeep,
-        /*out*/hardware::camera::device::V3_6::CameraOfflineSessionInfo* offlineSessionInfo,
-        /*out*/sp<hardware::camera::device::V3_6::ICameraOfflineSession>* offlineSession,
-        /*out*/camera3::BufferRecords* bufferRecords) {
-    Mutex::Autolock l(mRequestLock);
-    clearRepeatingRequestsLocked(/*lastFrameNumber*/nullptr);
-
-    // Wait until request thread is fully stopped
-    // TBD: check if request thread is being paused by other APIs (shouldn't be)
-
-    // We could also check for mRepeatingRequests.empty(), but the API interface
-    // is serialized by Camera3Device::mInterfaceLock so no one should be able to submit any
-    // new requests during the call; hence skip that check.
-    bool queueEmpty = mNextRequests.empty() && mRequestQueue.empty();
-    while (!queueEmpty) {
-        status_t res = mRequestSubmittedSignal.waitRelative(mRequestLock, kRequestSubmitTimeout);
-        if (res == TIMED_OUT) {
-            ALOGE("%s: request thread failed to submit one request within timeout!", __FUNCTION__);
-            return res;
-        } else if (res != OK) {
-            ALOGE("%s: request thread failed to submit a request: %s (%d)!",
-                    __FUNCTION__, strerror(-res), res);
-            return res;
-        }
-        queueEmpty = mNextRequests.empty() && mRequestQueue.empty();
-    }
-    return (static_cast<HidlHalInterface *>(mInterface.get()))->switchToOffline(
-            streamsToKeep, offlineSessionInfo, offlineSession, bufferRecords);
-}
-
-status_t HidlCamera3Device::HidlCamera3DeviceInjectionMethods::injectionInitialize(
-        const String8& injectedCamId, sp<CameraProviderManager> manager,
-        const sp<android::hardware::camera::device::V3_2::ICameraDeviceCallback>&
-                callback) {
-    ATRACE_CALL();
-    Mutex::Autolock lock(mInjectionLock);
-
-    if (manager == nullptr) {
-        ALOGE("%s: manager does not exist!", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-
-    sp<Camera3Device> parent = mParent.promote();
-    if (parent == nullptr) {
-        ALOGE("%s: parent does not exist!", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-
-    mInjectedCamId = injectedCamId;
-    sp<ICameraDeviceSession> session;
-    ATRACE_BEGIN("Injection CameraHal::openSession");
-    status_t res = manager->openHidlSession(injectedCamId.string(), callback,
-                                          /*out*/ &session);
-    ATRACE_END();
-    if (res != OK) {
-        ALOGE("Injection camera could not open camera session: %s (%d)",
-                strerror(-res), res);
-        return res;
-    }
-
-    std::shared_ptr<RequestMetadataQueue> queue;
-    auto requestQueueRet =
-        session->getCaptureRequestMetadataQueue([&queue](const auto& descriptor) {
-            queue = std::make_shared<RequestMetadataQueue>(descriptor);
-            if (!queue->isValid() || queue->availableToWrite() <= 0) {
-                ALOGE("Injection camera HAL returns empty request metadata fmq, not "
-                        "use it");
-                queue = nullptr;
-                // don't use the queue onwards.
-            }
-        });
-    if (!requestQueueRet.isOk()) {
-        ALOGE("Injection camera transaction error when getting request metadata fmq: "
-                "%s, not use it", requestQueueRet.description().c_str());
-        return DEAD_OBJECT;
-    }
-
-    std::unique_ptr<ResultMetadataQueue>& resQueue = mInjectionResultMetadataQueue;
-    auto resultQueueRet = session->getCaptureResultMetadataQueue(
-        [&resQueue](const auto& descriptor) {
-            resQueue = std::make_unique<ResultMetadataQueue>(descriptor);
-            if (!resQueue->isValid() || resQueue->availableToWrite() <= 0) {
-                ALOGE("Injection camera HAL returns empty result metadata fmq, not use "
-                        "it");
-                resQueue = nullptr;
-                // Don't use the resQueue onwards.
-            }
-        });
-    if (!resultQueueRet.isOk()) {
-        ALOGE("Injection camera transaction error when getting result metadata queue "
-                "from camera session: %s", resultQueueRet.description().c_str());
-        return DEAD_OBJECT;
-    }
-    IF_ALOGV() {
-        session->interfaceChain(
-                [](::android::hardware::hidl_vec<::android::hardware::hidl_string>
-                        interfaceChain) {
-                        ALOGV("Injection camera session interface chain:");
-                        for (const auto& iface : interfaceChain) {
-                            ALOGV("  %s", iface.c_str());
-                        }
-                });
-    }
-
-    ALOGV("%s: Injection camera interface = new HalInterface()", __FUNCTION__);
-
-    mInjectedCamHalInterface =
-            new HidlHalInterface(session, queue, parent->mUseHalBufManager,
-                       parent->mSupportOfflineProcessing);
-    if (mInjectedCamHalInterface == nullptr) {
-        ALOGE("%s: mInjectedCamHalInterface does not exist!", __FUNCTION__);
-        return DEAD_OBJECT;
-    }
-
-    return OK;
-}
-
-status_t HidlCamera3Device::HidlCamera3DeviceInjectionMethods::replaceHalInterface(
-        sp<HalInterface> newHalInterface, bool keepBackup) {
-    Mutex::Autolock lock(mInjectionLock);
-    if (newHalInterface.get() == nullptr) {
-        ALOGE("%s: The newHalInterface does not exist, to stop replacing.",
-                __FUNCTION__);
-        return DEAD_OBJECT;
-    }
-
-    sp<Camera3Device> parent = mParent.promote();
-    if (parent == nullptr) {
-        ALOGE("%s: parent does not exist!", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-    if (newHalInterface->getTransportType() != IPCTransport::HIDL) {
-        ALOGE("%s Replacing HIDL HalInterface with another transport unsupported", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-
-    HidlCamera3Device *hidlParent = static_cast<HidlCamera3Device *>(parent.get());
-    if (keepBackup) {
-        if (mBackupHalInterface == nullptr) {
-            mBackupHalInterface = parent->mInterface;
-        }
-        if (mBackupResultMetadataQueue == nullptr) {
-            mBackupResultMetadataQueue = std::move(hidlParent->mResultMetadataQueue);
-            hidlParent->mResultMetadataQueue = std::move(mInjectionResultMetadataQueue);
-        }
-    } else {
-        mBackupHalInterface = nullptr;
-        hidlParent->mResultMetadataQueue = std::move(mBackupResultMetadataQueue);
-        mBackupResultMetadataQueue = nullptr;
-    }
-    parent->mInterface = newHalInterface;
-
-    return OK;
-}
-
-}; // namespace android
diff --git a/services/camera/libcameraservice/device3/hidl/HidlCamera3Device.h b/services/camera/libcameraservice/device3/hidl/HidlCamera3Device.h
deleted file mode 100644
index 2e98fe068c..0000000000
--- a/services/camera/libcameraservice/device3/hidl/HidlCamera3Device.h
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SERVERS_HIDLCAMERA3DEVICE_H
-#define ANDROID_SERVERS_HIDLCAMERA3DEVICE_H
-
-#include "../Camera3Device.h"
-#include "HidlCamera3OutputUtils.h"
-
-namespace android {
-
-
-/**
- * CameraDevice for HIDL HAL devices with version CAMERA_DEVICE_API_VERSION_3_0 or higher.
- */
-class HidlCamera3Device :
-            virtual public hardware::camera::device::V3_5::ICameraDeviceCallback,
-            public Camera3Device {
-  public:
-
-   explicit HidlCamera3Device(const String8& id, bool overrideForPerfClass,
-          bool legacyClient = false) : Camera3Device(id, overrideForPerfClass, legacyClient) { }
-
-    virtual ~HidlCamera3Device() {}
-
-   /**
-     * Helper functions to map between framework and HIDL values
-     */
-    static hardware::graphics::common::V1_0::PixelFormat mapToPixelFormat(int frameworkFormat);
-    static hardware::camera::device::V3_2::DataspaceFlags mapToHidlDataspace(
-            android_dataspace dataSpace);
-    static hardware::camera::device::V3_2::BufferUsageFlags mapToConsumerUsage(uint64_t usage);
-    static hardware::camera::device::V3_2::StreamRotation mapToStreamRotation(
-            camera_stream_rotation_t rotation);
-    // Returns a negative error code if the passed-in operation mode is not valid.
-    static status_t mapToStreamConfigurationMode(camera_stream_configuration_mode_t operationMode,
-            /*out*/ hardware::camera::device::V3_2::StreamConfigurationMode *mode);
-    static int mapToFrameworkFormat(hardware::graphics::common::V1_0::PixelFormat pixelFormat);
-    static android_dataspace mapToFrameworkDataspace(
-            hardware::camera::device::V3_2::DataspaceFlags);
-    static uint64_t mapConsumerToFrameworkUsage(
-            hardware::camera::device::V3_2::BufferUsageFlags usage);
-    static uint64_t mapProducerToFrameworkUsage(
-            hardware::camera::device::V3_2::BufferUsageFlags usage);
-
-    status_t initialize(sp<CameraProviderManager> manager, const String8& monitorTags) override;
-
-    /**
-     * Implementation of android::hardware::camera::device::V3_5::ICameraDeviceCallback
-     */
-
-    hardware::Return<void> processCaptureResult_3_4(
-            const hardware::hidl_vec<
-                    hardware::camera::device::V3_4::CaptureResult>& results) override;
-    hardware::Return<void> processCaptureResult(
-            const hardware::hidl_vec<
-                    hardware::camera::device::V3_2::CaptureResult>& results) override;
-    hardware::Return<void> notify(
-            const hardware::hidl_vec<
-                    hardware::camera::device::V3_2::NotifyMsg>& msgs) override;
-
-    hardware::Return<void> requestStreamBuffers(
-            const hardware::hidl_vec<
-                    hardware::camera::device::V3_5::BufferRequest>& bufReqs,
-            requestStreamBuffers_cb _hidl_cb) override;
-
-    hardware::Return<void> returnStreamBuffers(
-            const hardware::hidl_vec<
-                    hardware::camera::device::V3_2::StreamBuffer>& buffers) override;
-
-    // Handle one notify message
-    void notify(const hardware::camera::device::V3_2::NotifyMsg& msg);
-
-    status_t switchToOffline(const std::vector<int32_t>& streamsToKeep,
-            /*out*/ sp<CameraOfflineSessionBase>* session) override;
-
-    using RequestMetadataQueue = hardware::MessageQueue<uint8_t, hardware::kSynchronizedReadWrite>;
-
-    class HidlHalInterface : public Camera3Device::HalInterface {
-     public:
-        HidlHalInterface(sp<hardware::camera::device::V3_2::ICameraDeviceSession> &session,
-                     std::shared_ptr<RequestMetadataQueue> queue,
-                     bool useHalBufManager, bool supportOfflineProcessing);
-
-        virtual IPCTransport getTransportType() const override { return IPCTransport::HIDL; }
-        // Returns true if constructed with a valid device or session, and not yet cleared
-        virtual bool valid() override;
-
-        // Reset this HalInterface object (does not call close())
-        virtual void clear() override;
-
-        // Calls into the HAL interface
-
-        // Caller takes ownership of requestTemplate
-        virtual status_t constructDefaultRequestSettings(camera_request_template templateId,
-                /*out*/ camera_metadata_t **requestTemplate) override;
-
-        virtual status_t configureStreams(const camera_metadata_t *sessionParams,
-                /*inout*/ camera_stream_configuration_t *config,
-                const std::vector<uint32_t>& bufferSizes) override;
-
-        // The injection camera configures the streams to hal.
-        virtual status_t configureInjectedStreams(
-                const camera_metadata_t* sessionParams,
-                /*inout*/ camera_stream_configuration_t* config,
-                const std::vector<uint32_t>& bufferSizes,
-                const CameraMetadata& cameraCharacteristics) override;
-
-        // When the call succeeds, the ownership of acquire fences in requests is transferred to
-        // HalInterface. More specifically, the current implementation will send the fence to
-        // HAL process and close the FD in cameraserver process. When the call fails, the ownership
-        // of the acquire fence still belongs to the caller.
-        virtual status_t processBatchCaptureRequests(
-                std::vector<camera_capture_request_t*>& requests,
-                /*out*/uint32_t* numRequestProcessed) override;
-        virtual status_t flush() override;
-        virtual status_t dump(int fd) override;
-        virtual status_t close() override;
-
-        virtual void signalPipelineDrain(const std::vector<int>& streamIds) override;
-        virtual bool isReconfigurationRequired(CameraMetadata& oldSessionParams,
-                CameraMetadata& newSessionParams) override;
-
-        virtual status_t repeatingRequestEnd(uint32_t frameNumber,
-                const std::vector<int32_t> &streamIds) override;
-
-        status_t switchToOffline(
-        const std::vector<int32_t>& streamsToKeep,
-        /*out*/hardware::camera::device::V3_6::CameraOfflineSessionInfo* offlineSessionInfo,
-        /*out*/sp<hardware::camera::device::V3_6::ICameraOfflineSession>* offlineSession,
-        /*out*/camera3::BufferRecords* bufferRecords);
-
-     private:
-
-        // Always valid
-        sp<hardware::camera::device::V3_2::ICameraDeviceSession> mHidlSession;
-        // Valid if ICameraDeviceSession is @3.3 or newer
-        sp<hardware::camera::device::V3_3::ICameraDeviceSession> mHidlSession_3_3;
-        // Valid if ICameraDeviceSession is @3.4 or newer
-        sp<hardware::camera::device::V3_4::ICameraDeviceSession> mHidlSession_3_4;
-        // Valid if ICameraDeviceSession is @3.5 or newer
-        sp<hardware::camera::device::V3_5::ICameraDeviceSession> mHidlSession_3_5;
-        // Valid if ICameraDeviceSession is @3.6 or newer
-        sp<hardware::camera::device::V3_6::ICameraDeviceSession> mHidlSession_3_6;
-        // Valid if ICameraDeviceSession is @3.7 or newer
-        sp<hardware::camera::device::V3_7::ICameraDeviceSession> mHidlSession_3_7;
-
-        std::shared_ptr<RequestMetadataQueue> mRequestMetadataQueue;
-
-        // The output HIDL request still depends on input camera_capture_request_t
-        // Do not free input camera_capture_request_t before output HIDL request
-        status_t wrapAsHidlRequest(camera_capture_request_t* in,
-                /*out*/hardware::camera::device::V3_2::CaptureRequest* out,
-                /*out*/std::vector<native_handle_t*>* handlesCreated,
-                /*out*/std::vector<std::pair<int32_t, int32_t>>* inflightBuffers);
-    }; // class HidlHalInterface
-
-    class HidlRequestThread : public Camera3Device::RequestThread {
-      public:
-        HidlRequestThread(wp<Camera3Device> parent,
-                sp<camera3::StatusTracker> statusTracker,
-                sp<HalInterface> interface,
-                const Vector<int32_t>& sessionParamKeys,
-                bool useHalBufManager,
-                bool supportCameraMute);
-
-        status_t switchToOffline(
-                const std::vector<int32_t>& streamsToKeep,
-                /*out*/hardware::camera::device::V3_6::CameraOfflineSessionInfo* offlineSessionInfo,
-                /*out*/sp<hardware::camera::device::V3_6::ICameraOfflineSession>* offlineSession,
-                /*out*/camera3::BufferRecords* bufferRecords);
-    }; // class HidlRequestThread
-
-    class HidlCamera3DeviceInjectionMethods : public Camera3DeviceInjectionMethods {
-     public:
-        // Initialize the injection camera and generate an hal interface.
-        status_t injectionInitialize(
-                const String8& injectedCamId, sp<CameraProviderManager> manager,
-                const sp<
-                    android::hardware::camera::device::V3_2 ::ICameraDeviceCallback>&
-                    callback);
-        HidlCamera3DeviceInjectionMethods(wp<Camera3Device> parent) :
-                Camera3DeviceInjectionMethods(parent) { };
-        ~HidlCamera3DeviceInjectionMethods() {}
-     private:
-        // Backup of the original camera hal result FMQ.
-        std::unique_ptr<ResultMetadataQueue> mBackupResultMetadataQueue;
-
-        // FMQ writes the result for the injection camera. Must be guarded by
-        // mProcessCaptureResultLock.
-        std::unique_ptr<ResultMetadataQueue> mInjectionResultMetadataQueue;
-
-        // Use injection camera hal interface to replace and backup original
-        // camera hal interface.
-        virtual status_t replaceHalInterface(sp<HalInterface> newHalInterface,
-                bool keepBackup) override;
-    };
-
-  private:
-    template<typename NotifyMsgType>
-    hardware::Return<void> notifyHelper(
-            const hardware::hidl_vec<NotifyMsgType>& msgs);
-
-    virtual status_t injectionCameraInitialize(const String8 &injectCamId,
-            sp<CameraProviderManager> manager) override;
-
-    virtual sp<RequestThread> createNewRequestThread(wp<Camera3Device> parent,
-                sp<camera3::StatusTracker> statusTracker,
-                sp<HalInterface> interface,
-                const Vector<int32_t>& sessionParamKeys,
-                bool useHalBufManager,
-                bool supportCameraMute) override;
-
-    virtual sp<Camera3DeviceInjectionMethods>
-            createCamera3DeviceInjectionMethods(wp<Camera3Device>) override;
-
-    // FMQ to write result on. Must be guarded by mProcessCaptureResultLock.
-    std::unique_ptr<ResultMetadataQueue> mResultMetadataQueue;
-
-}; // class HidlCamera3Device
-
-}; // namespace android
-
-#endif
diff --git a/services/camera/libcameraservice/device3/hidl/HidlCamera3OfflineSession.cpp b/services/camera/libcameraservice/device3/hidl/HidlCamera3OfflineSession.cpp
deleted file mode 100644
index 5c97f0eb82..0000000000
--- a/services/camera/libcameraservice/device3/hidl/HidlCamera3OfflineSession.cpp
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "Hidl-Camera3-OffLnSsn"
-#define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
-
-#include <inttypes.h>
-
-#include <utils/Trace.h>
-
-#include <android/hardware/camera2/ICameraDeviceCallbacks.h>
-
-#include "device3/hidl/HidlCamera3OfflineSession.h"
-#include "device3/Camera3OutputStream.h"
-#include "device3/hidl/HidlCamera3OutputUtils.h"
-#include "device3/Camera3InputStream.h"
-#include "device3/Camera3SharedOutputStream.h"
-#include "utils/CameraTraces.h"
-
-using namespace android::camera3;
-using namespace android::hardware::camera;
-
-namespace android {
-
-HidlCamera3OfflineSession::~HidlCamera3OfflineSession() {
-    ATRACE_CALL();
-    ALOGV("%s: Tearing down hidl offline session for camera id %s", __FUNCTION__, mId.string());
-    HidlCamera3OfflineSession::disconnectSession();
-}
-
-status_t HidlCamera3OfflineSession::initialize(wp<NotificationListener> listener) {
-    ATRACE_CALL();
-
-    if (mSession == nullptr) {
-        ALOGE("%s: HIDL session is null!", __FUNCTION__);
-        return DEAD_OBJECT;
-    }
-
-    {
-        std::lock_guard<std::mutex> lock(mLock);
-
-        mListener = listener;
-
-        // setup result FMQ
-        std::unique_ptr<ResultMetadataQueue>& resQueue = mResultMetadataQueue;
-        auto resultQueueRet = mSession->getCaptureResultMetadataQueue(
-            [&resQueue](const auto& descriptor) {
-                resQueue = std::make_unique<ResultMetadataQueue>(descriptor);
-                if (!resQueue->isValid() || resQueue->availableToWrite() <= 0) {
-                    ALOGE("HAL returns empty result metadata fmq, not use it");
-                    resQueue = nullptr;
-                    // Don't use resQueue onwards.
-                }
-            });
-        if (!resultQueueRet.isOk()) {
-            ALOGE("Transaction error when getting result metadata queue from camera session: %s",
-                    resultQueueRet.description().c_str());
-            return DEAD_OBJECT;
-        }
-        mStatus = STATUS_ACTIVE;
-    }
-
-    mSession->setCallback(this);
-
-    return OK;
-}
-
-hardware::Return<void> HidlCamera3OfflineSession::processCaptureResult_3_4(
-        const hardware::hidl_vec<
-                hardware::camera::device::V3_4::CaptureResult>& results) {
-    sp<NotificationListener> listener;
-    {
-        std::lock_guard<std::mutex> lock(mLock);
-        if (mStatus != STATUS_ACTIVE) {
-            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
-            return hardware::Void();
-        }
-        listener = mListener.promote();
-    }
-
-    HidlCaptureOutputStates states {
-      {mId,
-        mOfflineReqsLock, mLastCompletedRegularFrameNumber,
-        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
-        mOfflineReqs, mOutputLock, mResultQueue, mResultSignal,
-        mNextShutterFrameNumber,
-        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
-        mNextResultFrameNumber,
-        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
-        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
-        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
-        mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
-        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this, *this,
-        mBufferRecords, /*legacyClient*/ false, mMinExpectedDuration}, mResultMetadataQueue
-    };
-
-    std::lock_guard<std::mutex> lock(mProcessCaptureResultLock);
-    for (const auto& result : results) {
-        processOneCaptureResultLocked(states, result.v3_2, result.physicalCameraMetadata);
-    }
-    return hardware::Void();
-}
-
-hardware::Return<void> HidlCamera3OfflineSession::processCaptureResult(
-        const hardware::hidl_vec<
-                hardware::camera::device::V3_2::CaptureResult>& results) {
-    // TODO: changed impl to call into processCaptureResult_3_4 instead?
-    //       might need to figure how to reduce copy though.
-    sp<NotificationListener> listener;
-    {
-        std::lock_guard<std::mutex> lock(mLock);
-        if (mStatus != STATUS_ACTIVE) {
-            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
-            return hardware::Void();
-        }
-        listener = mListener.promote();
-    }
-
-    hardware::hidl_vec<hardware::camera::device::V3_4::PhysicalCameraMetadata> noPhysMetadata;
-
-    HidlCaptureOutputStates states {
-      {mId,
-        mOfflineReqsLock, mLastCompletedRegularFrameNumber,
-        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
-        mOfflineReqs, mOutputLock, mResultQueue, mResultSignal,
-        mNextShutterFrameNumber,
-        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
-        mNextResultFrameNumber,
-        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
-        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
-        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
-        mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
-        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this, *this,
-        mBufferRecords, /*legacyClient*/ false, mMinExpectedDuration}, mResultMetadataQueue
-    };
-
-    std::lock_guard<std::mutex> lock(mProcessCaptureResultLock);
-    for (const auto& result : results) {
-        processOneCaptureResultLocked(states, result, noPhysMetadata);
-    }
-    return hardware::Void();
-}
-
-hardware::Return<void> HidlCamera3OfflineSession::notify(
-        const hardware::hidl_vec<hardware::camera::device::V3_2::NotifyMsg>& msgs) {
-    sp<NotificationListener> listener;
-    {
-        std::lock_guard<std::mutex> lock(mLock);
-        if (mStatus != STATUS_ACTIVE) {
-            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
-            return hardware::Void();
-        }
-        listener = mListener.promote();
-    }
-
-    HidlCaptureOutputStates states {
-      {mId,
-        mOfflineReqsLock, mLastCompletedRegularFrameNumber,
-        mLastCompletedReprocessFrameNumber, mLastCompletedZslFrameNumber,
-        mOfflineReqs, mOutputLock, mResultQueue, mResultSignal,
-        mNextShutterFrameNumber,
-        mNextReprocessShutterFrameNumber, mNextZslStillShutterFrameNumber,
-        mNextResultFrameNumber,
-        mNextReprocessResultFrameNumber, mNextZslStillResultFrameNumber,
-        mUseHalBufManager, mUsePartialResult, mNeedFixupMonochromeTags,
-        mNumPartialResults, mVendorTagId, mDeviceInfo, mPhysicalDeviceInfoMap,
-        mDistortionMappers, mZoomRatioMappers, mRotateAndCropMappers,
-        mTagMonitor, mInputStream, mOutputStreams, mSessionStatsBuilder, listener, *this, *this,
-        mBufferRecords, /*legacyClient*/ false, mMinExpectedDuration}, mResultMetadataQueue
-    };
-    for (const auto& msg : msgs) {
-        camera3::notify(states, msg);
-    }
-    return hardware::Void();
-}
-
-hardware::Return<void> HidlCamera3OfflineSession::requestStreamBuffers(
-        const hardware::hidl_vec<hardware::camera::device::V3_5::BufferRequest>& bufReqs,
-        requestStreamBuffers_cb _hidl_cb) {
-    {
-        std::lock_guard<std::mutex> lock(mLock);
-        if (mStatus != STATUS_ACTIVE) {
-            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
-            return hardware::Void();
-        }
-    }
-
-    RequestBufferStates states {
-        mId, mRequestBufferInterfaceLock, mUseHalBufManager, mOutputStreams, mSessionStatsBuilder,
-        *this, mBufferRecords, *this};
-    camera3::requestStreamBuffers(states, bufReqs, _hidl_cb);
-    return hardware::Void();
-}
-
-hardware::Return<void> HidlCamera3OfflineSession::returnStreamBuffers(
-        const hardware::hidl_vec<hardware::camera::device::V3_2::StreamBuffer>& buffers) {
-    {
-        std::lock_guard<std::mutex> lock(mLock);
-        if (mStatus != STATUS_ACTIVE) {
-            ALOGE("%s called in wrong state %d", __FUNCTION__, mStatus);
-            return hardware::Void();
-        }
-    }
-
-    ReturnBufferStates states {
-        mId, mUseHalBufManager, mOutputStreams, mSessionStatsBuilder, mBufferRecords};
-
-    camera3::returnStreamBuffers(states, buffers);
-    return hardware::Void();
-}
-
-void HidlCamera3OfflineSession::disconnectSession() {
-  // TODO: Make sure this locking is correct.
-  std::lock_guard<std::mutex> lock(mLock);
-  if (mSession != nullptr) {
-      mSession->close();
-  }
-  mSession.clear();
-}
-
-}; // namespace android
diff --git a/services/camera/libcameraservice/device3/hidl/HidlCamera3OfflineSession.h b/services/camera/libcameraservice/device3/hidl/HidlCamera3OfflineSession.h
deleted file mode 100644
index 597cc5d2b7..0000000000
--- a/services/camera/libcameraservice/device3/hidl/HidlCamera3OfflineSession.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SERVERS_HIDL_CAMERA3OFFLINESESSION_H
-#define ANDROID_SERVERS_HIDL_CAMERA3OFFLINESESSION_H
-
-#include <memory>
-#include <mutex>
-
-#include <utils/String8.h>
-#include <utils/String16.h>
-
-#include <android/hardware/camera/device/3.6/ICameraOfflineSession.h>
-
-#include <fmq/MessageQueue.h>
-
-#include "HidlCamera3OutputUtils.h"
-#include "common/CameraOfflineSessionBase.h"
-
-#include "device3/Camera3BufferManager.h"
-#include "device3/Camera3OfflineSession.h"
-#include "device3/InFlightRequest.h"
-
-namespace android {
-
-namespace camera3 {
-
-class Camera3Stream;
-class Camera3OutputStreamInterface;
-class Camera3StreamInterface;
-
-} // namespace camera3
-
-/**
- * HidlCamera3OfflineSession for offline session defined in HIDL ICameraOfflineSession@3.6 or higher
- */
-class HidlCamera3OfflineSession :
-            public Camera3OfflineSession,
-            virtual public hardware::camera::device::V3_5::ICameraDeviceCallback {
-  public:
-
-    // initialize by Camera3Device.
-    explicit HidlCamera3OfflineSession(const String8& id,
-            const sp<camera3::Camera3Stream>& inputStream,
-            const camera3::StreamSet& offlineStreamSet,
-            camera3::BufferRecords&& bufferRecords,
-            const camera3::InFlightRequestMap& offlineReqs,
-            const Camera3OfflineStates& offlineStates,
-            sp<hardware::camera::device::V3_6::ICameraOfflineSession> offlineSession) :
-      Camera3OfflineSession(id, inputStream, offlineStreamSet, std::move(bufferRecords),
-              offlineReqs, offlineStates),
-      mSession(offlineSession) {};
-
-    virtual ~HidlCamera3OfflineSession();
-
-    virtual status_t initialize(wp<NotificationListener> listener) override;
-
-    /**
-     * HIDL ICameraDeviceCallback interface
-     * Implementation of android::hardware::camera::device::V3_5::ICameraDeviceCallback
-     */
-
-    hardware::Return<void> processCaptureResult_3_4(
-            const hardware::hidl_vec<
-                    hardware::camera::device::V3_4::CaptureResult>& results) override;
-    hardware::Return<void> processCaptureResult(
-            const hardware::hidl_vec<
-                    hardware::camera::device::V3_2::CaptureResult>& results) override;
-    hardware::Return<void> notify(
-            const hardware::hidl_vec<
-                    hardware::camera::device::V3_2::NotifyMsg>& msgs) override;
-
-    hardware::Return<void> requestStreamBuffers(
-            const hardware::hidl_vec<
-                    hardware::camera::device::V3_5::BufferRequest>& bufReqs,
-            requestStreamBuffers_cb _hidl_cb) override;
-
-    hardware::Return<void> returnStreamBuffers(
-            const hardware::hidl_vec<
-                    hardware::camera::device::V3_2::StreamBuffer>& buffers) override;
-
-    /**
-     * End of CameraOfflineSessionBase interface
-     */
-
-  private:
-    sp<hardware::camera::device::V3_6::ICameraOfflineSession> mSession;
-    // FMQ to write result on. Must be guarded by mProcessCaptureResultLock.
-    std::unique_ptr<ResultMetadataQueue> mResultMetadataQueue;
-
-    virtual void disconnectSession() override;
-}; // class Camera3OfflineSession
-
-}; // namespace android
-
-#endif
diff --git a/services/camera/libcameraservice/device3/hidl/HidlCamera3OutputUtils.cpp b/services/camera/libcameraservice/device3/hidl/HidlCamera3OutputUtils.cpp
deleted file mode 100644
index 8b0cd65e62..0000000000
--- a/services/camera/libcameraservice/device3/hidl/HidlCamera3OutputUtils.cpp
+++ /dev/null
@@ -1,261 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "HidlCamera3-OutputUtils"
-#define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
-// Convenience macros for transitioning to the error state
-#define SET_ERR(fmt, ...) states.setErrIntf.setErrorState(   \
-    "%s: " fmt, __FUNCTION__,                         \
-    ##__VA_ARGS__)
-
-#include <inttypes.h>
-
-#include <utils/Log.h>
-#include <utils/SortedVector.h>
-#include <utils/Trace.h>
-
-#include <android/hardware/camera2/ICameraDeviceCallbacks.h>
-
-#include <android/hardware/camera/device/3.4/ICameraDeviceCallback.h>
-#include <android/hardware/camera/device/3.5/ICameraDeviceCallback.h>
-#include <android/hardware/camera/device/3.5/ICameraDeviceSession.h>
-
-#include <camera/CameraUtils.h>
-#include <camera_metadata_hidden.h>
-
-#include "device3/hidl/HidlCamera3OutputUtils.h"
-#include "device3/aidl/AidlCamera3OutputUtils.h"
-#include "device3/Camera3Device.h"
-#include "device3/Camera3OutputUtilsTemplated.h"
-
-#include "system/camera_metadata.h"
-
-using namespace android::camera3;
-using namespace android::hardware::camera;
-
-namespace android {
-namespace camera3 {
-
-void processOneCaptureResultLocked(
-        HidlCaptureOutputStates& states,
-        const hardware::camera::device::V3_2::CaptureResult& result,
-        const hardware::hidl_vec<
-                hardware::camera::device::V3_4::PhysicalCameraMetadata> &physicalCameraMetadata) {
-    processOneCaptureResultLockedT<HidlCaptureOutputStates,
-        hardware::camera::device::V3_2::CaptureResult,
-        hardware::hidl_vec<hardware::camera::device::V3_4::PhysicalCameraMetadata>,
-        hardware::hidl_vec<uint8_t>, ResultMetadataQueue,
-        hardware::camera::device::V3_2::BufferStatus>(states, result, physicalCameraMetadata);
-}
-
-void notify(CaptureOutputStates& states,
-        const hardware::camera::device::V3_2::NotifyMsg& msg) {
-
-    using android::hardware::camera::device::V3_2::MsgType;
-    using android::hardware::camera::device::V3_2::ErrorCode;
-
-    ATRACE_CALL();
-    camera_notify_msg m;
-    switch (msg.type) {
-        case MsgType::ERROR:
-            m.type = CAMERA_MSG_ERROR;
-            m.message.error.frame_number = msg.msg.error.frameNumber;
-            if (msg.msg.error.errorStreamId >= 0) {
-                sp<Camera3StreamInterface> stream =
-                        states.outputStreams.get(msg.msg.error.errorStreamId);
-                if (stream == nullptr) {
-                    ALOGE("%s: Frame %d: Invalid error stream id %d", __FUNCTION__,
-                            m.message.error.frame_number, msg.msg.error.errorStreamId);
-                    return;
-                }
-                m.message.error.error_stream = stream->asHalStream();
-            } else {
-                m.message.error.error_stream = nullptr;
-            }
-            switch (msg.msg.error.errorCode) {
-                case ErrorCode::ERROR_DEVICE:
-                    m.message.error.error_code = CAMERA_MSG_ERROR_DEVICE;
-                    break;
-                case ErrorCode::ERROR_REQUEST:
-                    m.message.error.error_code = CAMERA_MSG_ERROR_REQUEST;
-                    break;
-                case ErrorCode::ERROR_RESULT:
-                    m.message.error.error_code = CAMERA_MSG_ERROR_RESULT;
-                    break;
-                case ErrorCode::ERROR_BUFFER:
-                    m.message.error.error_code = CAMERA_MSG_ERROR_BUFFER;
-                    break;
-            }
-            break;
-        case MsgType::SHUTTER:
-            m.type = CAMERA_MSG_SHUTTER;
-            m.message.shutter.frame_number = msg.msg.shutter.frameNumber;
-            m.message.shutter.timestamp = msg.msg.shutter.timestamp;
-            m.message.shutter.readout_timestamp = 0LL;
-            break;
-    }
-    notify(states, &m);
-}
-
-static void convertToAidl(
-        const hardware::hidl_vec<hardware::camera::device::V3_5::BufferRequest>& hidlBufReqs,
-        std::vector<aidl::android::hardware::camera::device::BufferRequest> &aidlBufReqs) {
-    size_t i = 0;
-    aidlBufReqs.resize(hidlBufReqs.size());
-    for (const auto &hidlBufReq : hidlBufReqs) {
-        aidlBufReqs[i].streamId = hidlBufReq.streamId;
-        aidlBufReqs[i].numBuffersRequested = hidlBufReq.numBuffersRequested;
-        i++;
-    }
-}
-
-static hardware::camera::device::V3_5::StreamBufferRequestError
-convertToHidl(aidl::android::hardware::camera::device::StreamBufferRequestError aError) {
-    using AError = aidl::android::hardware::camera::device::StreamBufferRequestError;
-    using HError = hardware::camera::device::V3_5::StreamBufferRequestError;
-
-    switch(aError) {
-        case AError::NO_BUFFER_AVAILABLE:
-            return HError::NO_BUFFER_AVAILABLE;
-        case AError::MAX_BUFFER_EXCEEDED:
-            return HError::MAX_BUFFER_EXCEEDED;
-        case AError::STREAM_DISCONNECTED:
-            return HError::STREAM_DISCONNECTED;
-        default:
-            return HError::UNKNOWN_ERROR;
-    }
-}
-
-static hardware::camera::device::V3_5::BufferRequestStatus
-convertToHidl(const aidl::android::hardware::camera::device::BufferRequestStatus &aBufStatus) {
-    using AStatus = aidl::android::hardware::camera::device::BufferRequestStatus;
-    using HStatus = hardware::camera::device::V3_5::BufferRequestStatus;
-    switch (aBufStatus) {
-        case AStatus::OK:
-            return HStatus::OK;
-        case AStatus::FAILED_PARTIAL:
-            return HStatus::FAILED_PARTIAL;
-        case AStatus::FAILED_CONFIGURING:
-            return HStatus::FAILED_CONFIGURING;
-        case AStatus::FAILED_ILLEGAL_ARGUMENTS:
-            return HStatus::FAILED_ILLEGAL_ARGUMENTS;
-        case AStatus::FAILED_UNKNOWN:
-            return HStatus::FAILED_UNKNOWN;
-    }
-    return HStatus::FAILED_UNKNOWN;
-}
-
-static hardware::camera::device::V3_2::BufferStatus
-convertToHidl(const aidl::android::hardware::camera::device::BufferStatus &aBufStatus) {
-    using AStatus = aidl::android::hardware::camera::device::BufferStatus;
-    using HStatus = hardware::camera::device::V3_2::BufferStatus;
-    switch (aBufStatus) {
-        case AStatus::OK:
-            return HStatus::OK;
-        case AStatus::ERROR:
-            return HStatus::ERROR;
-    }
-    return HStatus::ERROR;
-}
-
-static native_handle_t *convertToHidl(const aidl::android::hardware::common::NativeHandle &ah,
-        std::vector<native_handle_t *> &handlesCreated) {
-    if (isHandleNull(ah)) {
-        return nullptr;
-    }
-    native_handle_t *nh = makeFromAidl(ah);
-    handlesCreated.emplace_back(nh);
-    return nh;
-}
-
-static void convertToHidl(
-        const std::vector<aidl::android::hardware::camera::device::StreamBuffer> &aBuffers,
-        hardware::camera::device::V3_5::StreamBuffersVal &hBuffersVal,
-        std::vector<native_handle_t *> &handlesCreated) {
-    using HStreamBuffer = hardware::camera::device::V3_2::StreamBuffer;
-    hardware::hidl_vec<HStreamBuffer> tmpBuffers(aBuffers.size());
-    size_t i = 0;
-    for (const auto &aBuf : aBuffers) {
-        tmpBuffers[i].status = convertToHidl(aBuf.status);
-        tmpBuffers[i].streamId = aBuf.streamId;
-        tmpBuffers[i].bufferId = aBuf.bufferId;
-        tmpBuffers[i].buffer = convertToHidl(aBuf.buffer, handlesCreated);
-        tmpBuffers[i].acquireFence = convertToHidl(aBuf.acquireFence, handlesCreated);
-        tmpBuffers[i].releaseFence = convertToHidl(aBuf.releaseFence, handlesCreated);
-        i++;
-    }
-    hBuffersVal.buffers(std::move(tmpBuffers));
-}
-
-static void convertToHidl(
-        const std::vector<aidl::android::hardware::camera::device::StreamBufferRet> &aidlBufRets,
-        hardware::hidl_vec<hardware::camera::device::V3_5::StreamBufferRet> &hidlBufRets,
-        std::vector<native_handle_t *> &handlesCreated) {
-    size_t i = 0;
-    using Tag = aidl::android::hardware::camera::device::StreamBuffersVal::Tag;
-    hidlBufRets.resize(aidlBufRets.size());
-    for (const auto &aidlBufRet : aidlBufRets) {
-        auto &hidlBufRet = hidlBufRets[i];
-        hidlBufRet.streamId = aidlBufRet.streamId;
-        switch(aidlBufRet.val.getTag()) {
-          case Tag::error:
-              hidlBufRet.val.error(convertToHidl(aidlBufRet.val.get<Tag::error>()));
-              break;
-          case Tag::buffers:
-              convertToHidl(aidlBufRet.val.get<Tag::buffers>(), hidlBufRet.val, handlesCreated);
-              break;
-        }
-        i++;
-    }
-}
-
-// The buffers requested through this call are not tied to any CaptureRequest in
-// particular. They may used by the hal for a particular frame's output buffer
-// or for its internal use as well. In the case that the hal does use any buffer
-// from the requested list here, for a particular frame's output buffer, the
-// buffer will be returned with the processCaptureResult call corresponding to
-// the frame. The other buffers will be returned through returnStreamBuffers.
-// The buffers returned via returnStreamBuffers will not have a valid
-// timestamp(0) and will be dropped by the bufferqueue.
-void requestStreamBuffers(RequestBufferStates& states,
-        const hardware::hidl_vec<hardware::camera::device::V3_5::BufferRequest>& bufReqs,
-        hardware::camera::device::V3_5::ICameraDeviceCallback::requestStreamBuffers_cb _hidl_cb) {
-   using android::hardware::camera::device::V3_2::BufferStatus;
-    using android::hardware::camera::device::V3_2::StreamBuffer;
-    using android::hardware::camera::device::V3_5::BufferRequestStatus;
-    using android::hardware::camera::device::V3_5::StreamBufferRet;
-    using android::hardware::camera::device::V3_5::StreamBufferRequestError;
-    std::vector<aidl::android::hardware::camera::device::BufferRequest> aidlBufReqs;
-    hardware::hidl_vec<hardware::camera::device::V3_5::StreamBufferRet> hidlBufRets;
-    convertToAidl(bufReqs, aidlBufReqs);
-    std::vector<::aidl::android::hardware::camera::device::StreamBufferRet> aidlBufRets;
-    ::aidl::android::hardware::camera::device::BufferRequestStatus aidlBufRetStatus;
-
-    requestStreamBuffers(states, aidlBufReqs, &aidlBufRets, &aidlBufRetStatus);
-    std::vector<native_handle_t *> handlesCreated;
-    convertToHidl(aidlBufRets, hidlBufRets, handlesCreated);
-    _hidl_cb(convertToHidl(aidlBufRetStatus), hidlBufRets);
-    Camera3Device::cleanupNativeHandles(&handlesCreated);
-}
-
-void returnStreamBuffers(ReturnBufferStates& states,
-        const hardware::hidl_vec<hardware::camera::device::V3_2::StreamBuffer>& buffers) {
-    returnStreamBuffersT(states, buffers);
-}
-
-} // camera3
-} // namespace android
diff --git a/services/camera/libcameraservice/device3/hidl/HidlCamera3OutputUtils.h b/services/camera/libcameraservice/device3/hidl/HidlCamera3OutputUtils.h
deleted file mode 100644
index 5e6cba6453..0000000000
--- a/services/camera/libcameraservice/device3/hidl/HidlCamera3OutputUtils.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SERVERS_HIDL_CAMERA3_OUTPUT_UTILS_H
-#define ANDROID_SERVERS_HIDL_CAMERA3_OUTPUT_UTILS_H
-
-#include <memory>
-#include <mutex>
-
-#include <cutils/native_handle.h>
-
-#include <fmq/MessageQueue.h>
-
-#include <common/CameraDeviceBase.h>
-
-#include <android/hardware/camera/device/3.5/ICameraDeviceCallback.h>
-
-#include "device3/BufferUtils.h"
-#include "device3/InFlightRequest.h"
-#include "device3/Camera3Stream.h"
-#include "device3/Camera3OutputUtils.h"
-
-namespace android {
-
-using ResultMetadataQueue = hardware::MessageQueue<uint8_t, hardware::kSynchronizedReadWrite>;
-
-namespace camera3 {
-
-    /**
-     * Helper methods shared between HidlCamera3Device/HidlCamera3OfflineSession for HAL callbacks
-     */
-    // Camera3Device/Camera3OfflineSession internal states used in notify/processCaptureResult
-    // callbacks
-    struct HidlCaptureOutputStates : public CaptureOutputStates {
-        std::unique_ptr<ResultMetadataQueue>& fmq;
-    };
-
-    // Handle one capture result. Assume callers hold the lock to serialize all
-    // processCaptureResult calls
-    void processOneCaptureResultLocked(
-            HidlCaptureOutputStates& states,
-            const hardware::camera::device::V3_2::CaptureResult& result,
-            const hardware::hidl_vec<
-                    hardware::camera::device::V3_4::PhysicalCameraMetadata>
-                            &physicalCameraMetadata);
-
-    // Handle one notify message
-    void notify(CaptureOutputStates& states,
-            const hardware::camera::device::V3_2::NotifyMsg& msg);
-    void requestStreamBuffers(RequestBufferStates& states,
-            const hardware::hidl_vec<hardware::camera::device::V3_5::BufferRequest>& bufReqs,
-            hardware::camera::device::V3_5::ICameraDeviceCallback::requestStreamBuffers_cb
-                    _hidl_cb);
-    void returnStreamBuffers(ReturnBufferStates& states,
-            const hardware::hidl_vec<hardware::camera::device::V3_2::StreamBuffer>& buffers);
-
-} // namespace camera3
-
-} // namespace android
-
-#endif
diff --git a/services/camera/libcameraservice/hidl/AidlCameraServiceListener.cpp b/services/camera/libcameraservice/hidl/AidlCameraServiceListener.cpp
index add9121432..ddc114ad45 100644
--- a/services/camera/libcameraservice/hidl/AidlCameraServiceListener.cpp
+++ b/services/camera/libcameraservice/hidl/AidlCameraServiceListener.cpp
@@ -70,11 +70,6 @@ binder::Status H2BCameraServiceListener::onPhysicalCameraStatusChanged(
   return binder::Status::ok();
 }
 
-::android::binder::Status H2BCameraServiceListener::onTorchStrengthLevelChanged(
-    const ::android::String16&, int32_t) {
-  return binder::Status::ok();
-}
-
 } // implementation
 } // V2_0
 } // common
diff --git a/services/camera/libcameraservice/hidl/AidlCameraServiceListener.h b/services/camera/libcameraservice/hidl/AidlCameraServiceListener.h
index 7ef413f18e..71480357fd 100644
--- a/services/camera/libcameraservice/hidl/AidlCameraServiceListener.h
+++ b/services/camera/libcameraservice/hidl/AidlCameraServiceListener.h
@@ -54,8 +54,6 @@ struct H2BCameraServiceListener :
 
     virtual ::android::binder::Status onTorchStatusChanged(
             int32_t status, const ::android::String16& cameraId) override;
-    virtual ::android::binder::Status onTorchStrengthLevelChanged(
-            const ::android::String16& cameraId, int32_t newStrengthLevel) override;
     virtual binder::Status onCameraAccessPrioritiesChanged() {
         // TODO: no implementation yet.
         return binder::Status::ok();
diff --git a/services/camera/libcameraservice/libcameraservice_fuzzer/Android.bp b/services/camera/libcameraservice/libcameraservice_fuzzer/Android.bp
index e43b91fbd9..4f080fe283 100644
--- a/services/camera/libcameraservice/libcameraservice_fuzzer/Android.bp
+++ b/services/camera/libcameraservice/libcameraservice_fuzzer/Android.bp
@@ -52,7 +52,6 @@ cc_fuzz {
         "android.hardware.camera.provider@2.5",
         "android.hardware.camera.provider@2.6",
         "android.hardware.camera.provider@2.7",
-        "android.hardware.camera.provider-V1-ndk",
         "android.hardware.camera.device@1.0",
         "android.hardware.camera.device@3.2",
         "android.hardware.camera.device@3.3",
diff --git a/services/camera/libcameraservice/libcameraservice_fuzzer/camera_service_fuzzer.cpp b/services/camera/libcameraservice/libcameraservice_fuzzer/camera_service_fuzzer.cpp
index 97d7bf48d4..e46bf74750 100644
--- a/services/camera/libcameraservice/libcameraservice_fuzzer/camera_service_fuzzer.cpp
+++ b/services/camera/libcameraservice/libcameraservice_fuzzer/camera_service_fuzzer.cpp
@@ -466,12 +466,6 @@ public:
         // No op
         return binder::Status::ok();
     }
-
-    virtual binder::Status onTorchStrengthLevelChanged(const String16& /*cameraId*/,
-            int32_t /*torchStrength*/) {
-        // No op
-        return binder::Status::ok();
-    }
 };
 
 class TestCameraDeviceCallbacks : public hardware::camera2::BnCameraDeviceCallbacks {
diff --git a/services/camera/libcameraservice/tests/Android.bp b/services/camera/libcameraservice/tests/Android.bp
index 3616572184..fbe1f41b84 100644
--- a/services/camera/libcameraservice/tests/Android.bp
+++ b/services/camera/libcameraservice/tests/Android.bp
@@ -44,7 +44,6 @@ cc_test {
         "android.hardware.camera.provider@2.5",
         "android.hardware.camera.provider@2.6",
         "android.hardware.camera.provider@2.7",
-        "android.hardware.camera.provider-V1-ndk",
         "android.hardware.camera.device@1.0",
         "android.hardware.camera.device@3.2",
         "android.hardware.camera.device@3.4",
@@ -83,35 +82,25 @@ cc_test_host {
     include_dirs: [
         "frameworks/av/camera/include",
         "frameworks/av/camera/include/camera",
-        "frameworks/native/libs/binder/include_activitymanager"
     ],
 
     shared_libs: [
-        "libactivity_manager_procstate_aidl-cpp",
         "libbase",
         "libbinder",
         "libcamera_metadata",
-        "libdynamic_depth",
         "libexif",
-        "libjpeg",
         "liblog",
         "libutils",
     ],
 
     static_libs: [
         "libcamera_client_host",
-        "libcameraservice_device_independent",
+        "libcameraservice_host",
         "libgmock",
     ],
 
     srcs: [
-        "ClientManagerTest.cpp",
-        "DepthProcessorTest.cpp",
-        "DistortionMapperTest.cpp",
         "ExifUtilsTest.cpp",
-        "NV12Compressor.cpp",
-        "RotateAndCropMapperTest.cpp",
-        "ZoomRatioTest.cpp",
     ],
 
     cflags: [
@@ -122,4 +111,4 @@ cc_test_host {
 
     test_suites: ["device-tests"],
 
-}
+}
\ No newline at end of file
diff --git a/services/camera/libcameraservice/tests/CameraProviderManagerTest.cpp b/services/camera/libcameraservice/tests/CameraProviderManagerTest.cpp
index e9f6979573..a74fd9d863 100644
--- a/services/camera/libcameraservice/tests/CameraProviderManagerTest.cpp
+++ b/services/camera/libcameraservice/tests/CameraProviderManagerTest.cpp
@@ -212,7 +212,7 @@ struct TestICameraProvider : virtual public provider::V2_5::ICameraProvider {
  * Simple test version of the interaction proxy, to use to inject onRegistered calls to the
  * CameraProviderManager
  */
-struct TestInteractionProxy : public CameraProviderManager::HidlServiceInteractionProxy {
+struct TestInteractionProxy : public CameraProviderManager::ServiceInteractionProxy {
     sp<hidl::manager::V1_0::IServiceNotification> mManagerNotificationInterface;
     sp<TestICameraProvider> mTestCameraProvider;
 
@@ -269,13 +269,11 @@ struct TestStatusListener : public CameraProviderManager::StatusListener {
     ~TestStatusListener() {}
 
     void onDeviceStatusChanged(const String8 &,
-            CameraDeviceStatus) override {}
+            hardware::camera::common::V1_0::CameraDeviceStatus) override {}
     void onDeviceStatusChanged(const String8 &, const String8 &,
-            CameraDeviceStatus) override {}
+            hardware::camera::common::V1_0::CameraDeviceStatus) override {}
     void onTorchStatusChanged(const String8 &,
-            TorchModeStatus) override {}
-    void onTorchStatusChanged(const String8 &,
-            TorchModeStatus, SystemCameraKind) override {}
+            hardware::camera::common::V1_0::TorchModeStatus) override {}
     void onNewProviderRegistered() override {}
 };
 
diff --git a/services/camera/libcameraservice/tests/NV12Compressor.h b/services/camera/libcameraservice/tests/NV12Compressor.h
index a9598713ec..ee22d5e282 100644
--- a/services/camera/libcameraservice/tests/NV12Compressor.h
+++ b/services/camera/libcameraservice/tests/NV12Compressor.h
@@ -19,7 +19,6 @@
 
 #include <setjmp.h>
 #include <stdlib.h>
-#include <stdio.h>
 extern "C" {
 #include <jpeglib.h>
 #include <jerror.h>
diff --git a/services/camera/libcameraservice/tests/PreviewSchedulerTest.cpp b/services/camera/libcameraservice/tests/PreviewSchedulerTest.cpp
new file mode 100644
index 0000000000..6586b74840
--- /dev/null
+++ b/services/camera/libcameraservice/tests/PreviewSchedulerTest.cpp
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "PreviewSchedulerTest"
+
+#include <chrono>
+#include <thread>
+#include <utility>
+
+#include <gtest/gtest.h>
+#include <utils/Errors.h>
+#include <utils/Log.h>
+#include <utils/Mutex.h>
+
+#include <gui/BufferItemConsumer.h>
+#include <gui/BufferQueue.h>
+#include <gui/IGraphicBufferProducer.h>
+#include <gui/IGraphicBufferConsumer.h>
+#include <gui/Surface.h>
+
+#include "../device3/Camera3OutputStream.h"
+#include "../device3/PreviewFrameScheduler.h"
+
+using namespace android;
+using namespace android::camera3;
+
+// Consumer buffer available listener
+class SimpleListener : public BufferItemConsumer::FrameAvailableListener {
+public:
+    SimpleListener(size_t frameCount): mFrameCount(frameCount) {}
+
+    void waitForFrames() {
+        Mutex::Autolock lock(mMutex);
+        while (mFrameCount > 0) {
+            mCondition.wait(mMutex);
+        }
+    }
+
+    void onFrameAvailable(const BufferItem& /*item*/) override {
+        Mutex::Autolock lock(mMutex);
+        if (mFrameCount > 0) {
+            mFrameCount--;
+            mCondition.signal();
+        }
+    }
+
+    void reset(size_t frameCount) {
+        Mutex::Autolock lock(mMutex);
+        mFrameCount = frameCount;
+    }
+private:
+    size_t mFrameCount;
+    Mutex mMutex;
+    Condition mCondition;
+};
+
+// Test the PreviewFrameScheduler functionatliy of re-timing buffers
+TEST(PreviewSchedulerTest, BasicPreviewSchedulerTest) {
+    const int ID = 0;
+    const int FORMAT = HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED;
+    const uint32_t WIDTH = 640;
+    const uint32_t HEIGHT = 480;
+    const int32_t TRANSFORM = 0;
+    const nsecs_t T_OFFSET = 0;
+    const android_dataspace DATASPACE = HAL_DATASPACE_UNKNOWN;
+    const camera_stream_rotation_t ROTATION = CAMERA_STREAM_ROTATION_0;
+    const String8 PHY_ID;
+    const std::unordered_set<int32_t> PIX_MODES;
+    const int BUFFER_COUNT = 4;
+    const int TOTAL_BUFFER_COUNT = BUFFER_COUNT * 2;
+
+    // Create buffer queue
+    sp<IGraphicBufferProducer> producer;
+    sp<IGraphicBufferConsumer> consumer;
+    BufferQueue::createBufferQueue(&producer, &consumer);
+    ASSERT_NE(producer, nullptr);
+    ASSERT_NE(consumer, nullptr);
+    ASSERT_EQ(NO_ERROR, consumer->setDefaultBufferSize(WIDTH, HEIGHT));
+
+    // Set up consumer
+    sp<BufferItemConsumer> bufferConsumer = new BufferItemConsumer(consumer,
+            GRALLOC_USAGE_HW_COMPOSER, BUFFER_COUNT);
+    ASSERT_NE(bufferConsumer, nullptr);
+    sp<SimpleListener> consumerListener = new SimpleListener(BUFFER_COUNT);
+    bufferConsumer->setFrameAvailableListener(consumerListener);
+
+    // Set up producer
+    sp<Surface> surface = new Surface(producer);
+    sp<StubProducerListener> listener = new StubProducerListener();
+    ASSERT_EQ(NO_ERROR, surface->connect(NATIVE_WINDOW_API_CPU, listener));
+    sp<ANativeWindow> anw(surface);
+    ASSERT_EQ(NO_ERROR, native_window_set_buffer_count(anw.get(), TOTAL_BUFFER_COUNT));
+
+    // Create Camera3OutputStream and PreviewFrameScheduler
+    sp<Camera3OutputStream> stream = new Camera3OutputStream(ID, surface, WIDTH, HEIGHT,
+            FORMAT, DATASPACE, ROTATION, T_OFFSET, PHY_ID, PIX_MODES);
+    ASSERT_NE(stream, nullptr);
+    std::unique_ptr<PreviewFrameScheduler> scheduler =
+            std::make_unique<PreviewFrameScheduler>(*stream, surface);
+    ASSERT_NE(scheduler, nullptr);
+
+    // The pair of nsecs_t: camera timestamp delta (negative means in the past) and frame interval
+    const std::pair<nsecs_t, nsecs_t> inputTimestamps[][BUFFER_COUNT] = {
+        // 30fps, no interval
+        {{-100000000LL, 0}, {-66666667LL, 0},
+          {-33333333LL, 0}, {0, 0}},
+        // 30fps, 33ms interval
+        {{-100000000LL, 33333333LL}, {-66666667LL, 33333333LL},
+          {-33333333LL, 33333333LL}, {0, 0}},
+        // 30fps, variable interval
+        {{-100000000LL, 16666667LL}, {-66666667LL, 33333333LL},
+          {-33333333LL, 50000000LL}, {0, 0}},
+        // 60fps, 16.7ms interval
+        {{-50000000LL, 16666667LL}, {-33333333LL, 16666667LL},
+          {-16666667LL, 16666667LL}, {0, 0}},
+        // 60fps, variable interval
+        {{-50000000LL, 8666667LL}, {-33333333LL, 19666667LL},
+          {-16666667LL, 20666667LL}, {0, 0}},
+    };
+
+    const nsecs_t USE_AS_IS = -1; // Use the producer set timestamp
+    const nsecs_t USE_OVERRIDE = -2; // Use the scheduler overridden timestamp
+    const nsecs_t expectedTimestamps[][BUFFER_COUNT] = {
+        // 30fps, no interval: first 2 frames as is, and last 2 frames are
+        // overridden.
+        {USE_AS_IS, USE_AS_IS, USE_OVERRIDE, USE_OVERRIDE},
+        // 30fps, 33ms interval: all frames are overridden
+        {USE_OVERRIDE, USE_OVERRIDE, USE_OVERRIDE, USE_OVERRIDE},
+        // 30fps, variable interval: all frames are overridden
+        {USE_OVERRIDE, USE_OVERRIDE, USE_OVERRIDE, USE_OVERRIDE},
+        // 60fps, 16.7ms interval: all frames are overridden
+        {USE_OVERRIDE, USE_OVERRIDE, USE_OVERRIDE, USE_OVERRIDE},
+        // 60fps, variable interval: all frames are overridden
+        {USE_OVERRIDE, USE_OVERRIDE, USE_OVERRIDE, USE_OVERRIDE},
+    };
+
+    // Go through different use cases, and check the buffer timestamp
+    size_t iterations = sizeof(inputTimestamps)/sizeof(inputTimestamps[0]);
+    for (size_t i = 0; i < iterations; i++) {
+        // Space out different test sets to reset the frame scheduler
+        nsecs_t timeBase = systemTime() - s2ns(1) * (iterations - i);
+        nsecs_t lastQueueTime = 0;
+        nsecs_t duration = 0;
+        for (size_t j = 0; j < BUFFER_COUNT; j++) {
+            ANativeWindowBuffer* buffer = nullptr;
+            int fenceFd;
+            ASSERT_EQ(NO_ERROR, anw->dequeueBuffer(anw.get(), &buffer, &fenceFd));
+
+            // Sleep to space out queuePreviewBuffer
+            nsecs_t currentTime = systemTime();
+            if (duration > 0 && duration > currentTime - lastQueueTime) {
+                std::this_thread::sleep_for(
+                        std::chrono::nanoseconds(duration + lastQueueTime - currentTime));
+            }
+            nsecs_t timestamp = timeBase + inputTimestamps[i][j].first;
+            ASSERT_EQ(NO_ERROR,
+                    scheduler->queuePreviewBuffer(timestamp, TRANSFORM, buffer, fenceFd));
+
+            lastQueueTime = systemTime();
+            duration = inputTimestamps[i][j].second;
+        }
+
+        // Collect output timestamps, making sure they are either set by
+        // producer, or set by the scheduler.
+        consumerListener->waitForFrames();
+        nsecs_t outputTimestamps[BUFFER_COUNT];
+        for (size_t j = 0; j < BUFFER_COUNT; j++) {
+            BufferItem bufferItem;
+            ASSERT_EQ(NO_ERROR, bufferConsumer->acquireBuffer(&bufferItem, 0/*presentWhen*/));
+
+            outputTimestamps[j] = bufferItem.mTimestamp;
+            ALOGV("%s: [%zu][%zu]: input: %" PRId64 ", output: %" PRId64, __FUNCTION__,
+                  i, j, timeBase + inputTimestamps[i][j].first, bufferItem.mTimestamp);
+            if (expectedTimestamps[i][j] == USE_OVERRIDE) {
+                ASSERT_GT(bufferItem.mTimestamp, inputTimestamps[i][j].first);
+            } else if (expectedTimestamps[i][j] == USE_AS_IS) {
+                ASSERT_EQ(bufferItem.mTimestamp, timeBase + inputTimestamps[i][j].first);
+            }
+
+            ASSERT_EQ(NO_ERROR, bufferConsumer->releaseBuffer(bufferItem));
+        }
+
+        // Check the output timestamp intervals are aligned with input intervals
+        const nsecs_t SHIFT_THRESHOLD = ms2ns(2);
+        for (size_t j = 0; j < BUFFER_COUNT - 1; j ++) {
+            if (expectedTimestamps[i][j] == USE_OVERRIDE &&
+                    expectedTimestamps[i][j+1] == USE_OVERRIDE) {
+                nsecs_t interval_shift = outputTimestamps[j+1] - outputTimestamps[j] -
+                        (inputTimestamps[i][j+1].first - inputTimestamps[i][j].first);
+                ASSERT_LE(std::abs(interval_shift), SHIFT_THRESHOLD);
+            }
+        }
+
+        consumerListener->reset(BUFFER_COUNT);
+    }
+
+    // Disconnect the surface
+    ASSERT_EQ(NO_ERROR, surface->disconnect(NATIVE_WINDOW_API_CPU));
+}
diff --git a/services/camera/libcameraservice/utils/CameraServiceProxyWrapper.cpp b/services/camera/libcameraservice/utils/CameraServiceProxyWrapper.cpp
index 69175cc8d5..808191e1fa 100644
--- a/services/camera/libcameraservice/utils/CameraServiceProxyWrapper.cpp
+++ b/services/camera/libcameraservice/utils/CameraServiceProxyWrapper.cpp
@@ -66,11 +66,10 @@ void CameraServiceProxyWrapper::CameraSessionStatsWrapper::onStreamConfigured(
     }
 }
 
-void CameraServiceProxyWrapper::CameraSessionStatsWrapper::onActive(float maxPreviewFps) {
+void CameraServiceProxyWrapper::CameraSessionStatsWrapper::onActive() {
     Mutex::Autolock l(mLock);
 
     mSessionStats.mNewCameraState = CameraSessionStats::CAMERA_STATE_ACTIVE;
-    mSessionStats.mMaxPreviewFps = maxPreviewFps;
     updateProxyDeviceState(mSessionStats);
 
     // Reset mCreationDuration to -1 to distinguish between 1st session
@@ -80,7 +79,6 @@ void CameraServiceProxyWrapper::CameraSessionStatsWrapper::onActive(float maxPre
 
 void CameraServiceProxyWrapper::CameraSessionStatsWrapper::onIdle(
         int64_t requestCount, int64_t resultErrorCount, bool deviceError,
-        const std::string& userTag, int32_t videoStabilizationMode,
         const std::vector<hardware::CameraStreamStats>& streamStats) {
     Mutex::Autolock l(mLock);
 
@@ -88,8 +86,6 @@ void CameraServiceProxyWrapper::CameraSessionStatsWrapper::onIdle(
     mSessionStats.mRequestCount = requestCount;
     mSessionStats.mResultErrorCount = resultErrorCount;
     mSessionStats.mDeviceError = deviceError;
-    mSessionStats.mUserTag = String16(userTag.c_str());
-    mSessionStats.mVideoStabilizationMode = videoStabilizationMode;
     mSessionStats.mStreamStats = streamStats;
     updateProxyDeviceState(mSessionStats);
 
@@ -162,7 +158,7 @@ void CameraServiceProxyWrapper::logStreamConfigured(const String8& id,
     sessionStats->onStreamConfigured(operatingMode, internalConfig, latencyMs);
 }
 
-void CameraServiceProxyWrapper::logActive(const String8& id, float maxPreviewFps) {
+void CameraServiceProxyWrapper::logActive(const String8& id) {
     std::shared_ptr<CameraSessionStatsWrapper> sessionStats;
     {
         Mutex::Autolock l(mLock);
@@ -175,12 +171,11 @@ void CameraServiceProxyWrapper::logActive(const String8& id, float maxPreviewFps
     }
 
     ALOGV("%s: id %s", __FUNCTION__, id.c_str());
-    sessionStats->onActive(maxPreviewFps);
+    sessionStats->onActive();
 }
 
 void CameraServiceProxyWrapper::logIdle(const String8& id,
         int64_t requestCount, int64_t resultErrorCount, bool deviceError,
-        const std::string& userTag, int32_t videoStabilizationMode,
         const std::vector<hardware::CameraStreamStats>& streamStats) {
     std::shared_ptr<CameraSessionStatsWrapper> sessionStats;
     {
@@ -194,9 +189,8 @@ void CameraServiceProxyWrapper::logIdle(const String8& id,
         return;
     }
 
-    ALOGV("%s: id %s, requestCount %" PRId64 ", resultErrorCount %" PRId64 ", deviceError %d"
-            ", userTag %s, videoStabilizationMode %d", __FUNCTION__, id.c_str(), requestCount,
-            resultErrorCount, deviceError, userTag.c_str(), videoStabilizationMode);
+    ALOGV("%s: id %s, requestCount %" PRId64 ", resultErrorCount %" PRId64 ", deviceError %d",
+            __FUNCTION__, id.c_str(), requestCount, resultErrorCount, deviceError);
     for (size_t i = 0; i < streamStats.size(); i++) {
         ALOGV("%s: streamStats[%zu]: w %d h %d, requestedCount %" PRId64 ", dropCount %"
                 PRId64 ", startTimeMs %d" ,
@@ -205,8 +199,7 @@ void CameraServiceProxyWrapper::logIdle(const String8& id,
                 streamStats[i].mStartLatencyMs);
     }
 
-    sessionStats->onIdle(requestCount, resultErrorCount, deviceError, userTag,
-            videoStabilizationMode, streamStats);
+    sessionStats->onIdle(requestCount, resultErrorCount, deviceError, streamStats);
 }
 
 void CameraServiceProxyWrapper::logOpen(const String8& id, int facing,
diff --git a/services/camera/libcameraservice/utils/CameraServiceProxyWrapper.h b/services/camera/libcameraservice/utils/CameraServiceProxyWrapper.h
index e34a8f0cbd..b1d7b6c717 100644
--- a/services/camera/libcameraservice/utils/CameraServiceProxyWrapper.h
+++ b/services/camera/libcameraservice/utils/CameraServiceProxyWrapper.h
@@ -48,9 +48,8 @@ private:
         void onOpen();
         void onClose(int32_t latencyMs);
         void onStreamConfigured(int operatingMode, bool internalReconfig, int32_t latencyMs);
-        void onActive(float maxPreviewFps);
+        void onActive();
         void onIdle(int64_t requestCount, int64_t resultErrorCount, bool deviceError,
-                const std::string& userTag, int32_t videoStabilizationMode,
                 const std::vector<hardware::CameraStreamStats>& streamStats);
     };
 
@@ -82,12 +81,11 @@ public:
             int32_t latencyMs);
 
     // Session state becomes active
-    static void logActive(const String8& id, float maxPreviewFps);
+    static void logActive(const String8& id);
 
     // Session state becomes idle
     static void logIdle(const String8& id,
             int64_t requestCount, int64_t resultErrorCount, bool deviceError,
-            const std::string& userTag, int32_t videoStabilizationMode,
             const std::vector<hardware::CameraStreamStats>& streamStats);
 
     // Ping camera service proxy for user update
diff --git a/services/camera/libcameraservice/utils/ClientManager.h b/services/camera/libcameraservice/utils/ClientManager.h
index 074c84dc34..d164885116 100644
--- a/services/camera/libcameraservice/utils/ClientManager.h
+++ b/services/camera/libcameraservice/utils/ClientManager.h
@@ -527,7 +527,12 @@ ClientManager<KEY, VALUE, LISTENER>::wouldEvictLocked(
         if (!returnIncompatibleClients) {
             // Find evicted clients
 
-            if (conflicting && owner == curOwner) {
+            if (conflicting && curPriority < priority) {
+                // Pre-existing conflicting client with higher priority exists
+                evictList.clear();
+                evictList.push_back(client);
+                return evictList;
+            } else if (conflicting && owner == curOwner) {
                 // Pre-existing conflicting client with the same client owner exists
                 // Open the same device twice -> most recent open wins
                 // Otherwise let the existing client wins to avoid behaviors difference
@@ -541,11 +546,6 @@ ClientManager<KEY, VALUE, LISTENER>::wouldEvictLocked(
                     evictList.push_back(client);
                     return evictList;
                 }
-            } else if (conflicting && curPriority < priority) {
-                // Pre-existing conflicting client with higher priority exists
-                evictList.clear();
-                evictList.push_back(client);
-                return evictList;
             } else if (conflicting || ((totalCost > mMaxCost && curCost > 0) &&
                     (curPriority >= priority) &&
                     !(highestPriorityOwner == owner && owner == curOwner))) {
diff --git a/services/camera/libcameraservice/utils/IPCTransport.h b/services/camera/libcameraservice/utils/IPCTransport.h
deleted file mode 100644
index b8e80acc61..0000000000
--- a/services/camera/libcameraservice/utils/IPCTransport.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_SERVERS_IPC_H_
-#define ANDROID_SERVERS_IPC_H_
-
-enum class IPCTransport : uint32_t {
-  HIDL = 0,
-  AIDL = 1,
-  INVALID = 2
-};
-
-#endif
diff --git a/services/camera/libcameraservice/utils/SessionConfigurationUtils.cpp b/services/camera/libcameraservice/utils/SessionConfigurationUtils.cpp
index 2eb2d55e10..a239c81828 100644
--- a/services/camera/libcameraservice/utils/SessionConfigurationUtils.cpp
+++ b/services/camera/libcameraservice/utils/SessionConfigurationUtils.cpp
@@ -13,27 +13,71 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 #include <cutils/properties.h>
 
 #include "SessionConfigurationUtils.h"
 #include "../api2/DepthCompositeStream.h"
 #include "../api2/HeicCompositeStream.h"
 #include "common/CameraDeviceBase.h"
-#include "common/HalConversionsTemplated.h"
 #include "../CameraService.h"
-#include "device3/aidl/AidlCamera3Device.h"
-#include "device3/hidl/HidlCamera3Device.h"
+#include "device3/Camera3Device.h"
 #include "device3/Camera3OutputStream.h"
-#include "system/graphics-base-v1.1.h"
 
 using android::camera3::OutputStreamInfo;
 using android::camera3::OutputStreamInfo;
 using android::hardware::camera2::ICameraDeviceUser;
+using android::hardware::camera::metadata::V3_6::CameraMetadataEnumAndroidSensorPixelMode;
 
 namespace android {
 namespace camera3 {
 
+int32_t SessionConfigurationUtils::PERF_CLASS_LEVEL =
+        property_get_int32("ro.odm.build.media_performance_class", 0);
+
+bool SessionConfigurationUtils::IS_PERF_CLASS = (PERF_CLASS_LEVEL == SDK_VERSION_S);
+
+camera3::Size SessionConfigurationUtils::getMaxJpegResolution(const CameraMetadata &metadata,
+        bool ultraHighResolution) {
+    int32_t maxJpegWidth = 0, maxJpegHeight = 0;
+    const int STREAM_CONFIGURATION_SIZE = 4;
+    const int STREAM_FORMAT_OFFSET = 0;
+    const int STREAM_WIDTH_OFFSET = 1;
+    const int STREAM_HEIGHT_OFFSET = 2;
+    const int STREAM_IS_INPUT_OFFSET = 3;
+
+    int32_t scalerSizesTag = ultraHighResolution ?
+            ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION :
+                    ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS;
+    camera_metadata_ro_entry_t availableStreamConfigs =
+            metadata.find(scalerSizesTag);
+    if (availableStreamConfigs.count == 0 ||
+            availableStreamConfigs.count % STREAM_CONFIGURATION_SIZE != 0) {
+        return camera3::Size(0, 0);
+    }
+
+    // Get max jpeg size (area-wise).
+    for (size_t i= 0; i < availableStreamConfigs.count; i+= STREAM_CONFIGURATION_SIZE) {
+        int32_t format = availableStreamConfigs.data.i32[i + STREAM_FORMAT_OFFSET];
+        int32_t width = availableStreamConfigs.data.i32[i + STREAM_WIDTH_OFFSET];
+        int32_t height = availableStreamConfigs.data.i32[i + STREAM_HEIGHT_OFFSET];
+        int32_t isInput = availableStreamConfigs.data.i32[i + STREAM_IS_INPUT_OFFSET];
+        if (isInput == ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT
+                && format == HAL_PIXEL_FORMAT_BLOB &&
+                (width * height > maxJpegWidth * maxJpegHeight)) {
+            maxJpegWidth = width;
+            maxJpegHeight = height;
+        }
+    }
+
+    return camera3::Size(maxJpegWidth, maxJpegHeight);
+}
+
+size_t SessionConfigurationUtils::getUHRMaxJpegBufferSize(camera3::Size uhrMaxJpegSize,
+        camera3::Size defaultMaxJpegSize, size_t defaultMaxJpegBufferSize) {
+    return (uhrMaxJpegSize.width * uhrMaxJpegSize.height) /
+            (defaultMaxJpegSize.width * defaultMaxJpegSize.height) * defaultMaxJpegBufferSize;
+}
+
 void StreamConfiguration::getStreamConfigurations(
         const CameraMetadata &staticInfo, int configuration,
         std::unordered_map<int, std::vector<StreamConfiguration>> *scm) {
@@ -82,57 +126,65 @@ void StreamConfiguration::getStreamConfigurations(
     getStreamConfigurations(staticInfo, heicKey, scm);
 }
 
-namespace SessionConfigurationUtils {
-
-int32_t PERF_CLASS_LEVEL =
-        property_get_int32("ro.odm.build.media_performance_class", 0);
-
-bool IS_PERF_CLASS = (PERF_CLASS_LEVEL >= SDK_VERSION_S);
-
-camera3::Size getMaxJpegResolution(const CameraMetadata &metadata,
-        bool ultraHighResolution) {
-    int32_t maxJpegWidth = 0, maxJpegHeight = 0;
-    const int STREAM_CONFIGURATION_SIZE = 4;
-    const int STREAM_FORMAT_OFFSET = 0;
-    const int STREAM_WIDTH_OFFSET = 1;
-    const int STREAM_HEIGHT_OFFSET = 2;
-    const int STREAM_IS_INPUT_OFFSET = 3;
-
-    int32_t scalerSizesTag = ultraHighResolution ?
-            ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION :
-                    ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS;
-    camera_metadata_ro_entry_t availableStreamConfigs =
-            metadata.find(scalerSizesTag);
-    if (availableStreamConfigs.count == 0 ||
-            availableStreamConfigs.count % STREAM_CONFIGURATION_SIZE != 0) {
-        return camera3::Size(0, 0);
-    }
-
-    // Get max jpeg size (area-wise).
-    for (size_t i= 0; i < availableStreamConfigs.count; i+= STREAM_CONFIGURATION_SIZE) {
-        int32_t format = availableStreamConfigs.data.i32[i + STREAM_FORMAT_OFFSET];
-        int32_t width = availableStreamConfigs.data.i32[i + STREAM_WIDTH_OFFSET];
-        int32_t height = availableStreamConfigs.data.i32[i + STREAM_HEIGHT_OFFSET];
-        int32_t isInput = availableStreamConfigs.data.i32[i + STREAM_IS_INPUT_OFFSET];
-        if (isInput == ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT
-                && format == HAL_PIXEL_FORMAT_BLOB &&
-                (width * height > maxJpegWidth * maxJpegHeight)) {
-            maxJpegWidth = width;
-            maxJpegHeight = height;
-        }
+int32_t SessionConfigurationUtils::getAppropriateModeTag(int32_t defaultTag, bool maxResolution) {
+    if (!maxResolution) {
+        return defaultTag;
+    }
+    switch (defaultTag) {
+        case ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS:
+            return ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION;
+        case ANDROID_SCALER_AVAILABLE_MIN_FRAME_DURATIONS:
+            return ANDROID_SCALER_AVAILABLE_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION;
+        case ANDROID_SCALER_AVAILABLE_STALL_DURATIONS:
+            return ANDROID_SCALER_AVAILABLE_STALL_DURATIONS_MAXIMUM_RESOLUTION;
+        case ANDROID_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS:
+            return ANDROID_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION;
+        case ANDROID_DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS:
+            return ANDROID_DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION;
+        case ANDROID_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS:
+            return ANDROID_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS_MAXIMUM_RESOLUTION;
+        case ANDROID_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS:
+            return ANDROID_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION;
+        case ANDROID_DEPTH_AVAILABLE_DYNAMIC_DEPTH_MIN_FRAME_DURATIONS:
+            return ANDROID_DEPTH_AVAILABLE_DYNAMIC_DEPTH_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION;
+        case ANDROID_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STALL_DURATIONS:
+            return ANDROID_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STALL_DURATIONS_MAXIMUM_RESOLUTION;
+        case ANDROID_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS:
+            return ANDROID_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION;
+        case ANDROID_HEIC_AVAILABLE_HEIC_MIN_FRAME_DURATIONS:
+            return ANDROID_HEIC_AVAILABLE_HEIC_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION;
+        case ANDROID_HEIC_AVAILABLE_HEIC_STALL_DURATIONS:
+            return ANDROID_HEIC_AVAILABLE_HEIC_STALL_DURATIONS_MAXIMUM_RESOLUTION;
+        case ANDROID_SENSOR_OPAQUE_RAW_SIZE:
+            return ANDROID_SENSOR_OPAQUE_RAW_SIZE_MAXIMUM_RESOLUTION;
+        case ANDROID_LENS_INTRINSIC_CALIBRATION:
+            return ANDROID_LENS_INTRINSIC_CALIBRATION_MAXIMUM_RESOLUTION;
+        case ANDROID_LENS_DISTORTION:
+            return ANDROID_LENS_DISTORTION_MAXIMUM_RESOLUTION;
+        default:
+            ALOGE("%s: Tag %d doesn't have a maximum resolution counterpart", __FUNCTION__,
+                    defaultTag);
+            return -1;
     }
-
-    return camera3::Size(maxJpegWidth, maxJpegHeight);
+    return -1;
 }
 
-size_t getUHRMaxJpegBufferSize(camera3::Size uhrMaxJpegSize,
-        camera3::Size defaultMaxJpegSize, size_t defaultMaxJpegBufferSize) {
-    return (uhrMaxJpegSize.width * uhrMaxJpegSize.height) /
-            (defaultMaxJpegSize.width * defaultMaxJpegSize.height) * defaultMaxJpegBufferSize;
+bool SessionConfigurationUtils::getArrayWidthAndHeight(const CameraMetadata *deviceInfo,
+        int32_t arrayTag, int32_t *width, int32_t *height) {
+    if (width == nullptr || height == nullptr) {
+        ALOGE("%s: width / height nullptr", __FUNCTION__);
+        return false;
+    }
+    camera_metadata_ro_entry_t entry;
+    entry = deviceInfo->find(arrayTag);
+    if (entry.count != 4) return false;
+    *width = entry.data.i32[2];
+    *height = entry.data.i32[3];
+    return true;
 }
 
 StreamConfigurationPair
-getStreamConfigurationPair(const CameraMetadata &staticInfo) {
+SessionConfigurationUtils::getStreamConfigurationPair(const CameraMetadata &staticInfo) {
     camera3::StreamConfigurationPair streamConfigurationPair;
     camera3::StreamConfiguration::getStreamConfigurations(staticInfo, false,
             &streamConfigurationPair.mDefaultStreamConfigurationMap);
@@ -141,13 +193,13 @@ getStreamConfigurationPair(const CameraMetadata &staticInfo) {
     return streamConfigurationPair;
 }
 
-int64_t euclidDistSquare(int32_t x0, int32_t y0, int32_t x1, int32_t y1) {
+int64_t SessionConfigurationUtils::euclidDistSquare(int32_t x0, int32_t y0, int32_t x1, int32_t y1) {
     int64_t d0 = x0 - x1;
     int64_t d1 = y0 - y1;
     return d0 * d0 + d1 * d1;
 }
 
-bool roundBufferDimensionNearest(int32_t width, int32_t height,
+bool SessionConfigurationUtils::roundBufferDimensionNearest(int32_t width, int32_t height,
         int32_t format, android_dataspace dataSpace,
         const CameraMetadata& info, bool maxResolution, /*out*/int32_t* outWidth,
         /*out*/int32_t* outHeight) {
@@ -208,81 +260,7 @@ bool roundBufferDimensionNearest(int32_t width, int32_t height,
     return true;
 }
 
-//check if format is 10-bit compatible
-bool is10bitCompatibleFormat(int32_t format) {
-    switch(format) {
-        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
-        case HAL_PIXEL_FORMAT_YCBCR_P010:
-            return true;
-        default:
-            return false;
-    }
-}
-
-bool isDynamicRangeProfileSupported(int64_t dynamicRangeProfile, const CameraMetadata& staticInfo) {
-    if (dynamicRangeProfile == ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD) {
-        // Supported by default
-        return true;
-    }
-
-    camera_metadata_ro_entry_t entry = staticInfo.find(ANDROID_REQUEST_AVAILABLE_CAPABILITIES);
-    bool is10bitDynamicRangeSupported = false;
-    for (size_t i = 0; i < entry.count; ++i) {
-        uint8_t capability = entry.data.u8[i];
-        if (capability == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_DYNAMIC_RANGE_TEN_BIT) {
-            is10bitDynamicRangeSupported = true;
-            break;
-        }
-    }
-
-    if (!is10bitDynamicRangeSupported) {
-        return false;
-    }
-
-    switch (dynamicRangeProfile) {
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10_PLUS:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HLG10:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM_PO:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF_PO:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_OEM_PO:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_8B_HDR_REF_PO:
-            entry = staticInfo.find(ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP);
-            for (size_t i = 0; i < entry.count; i += 3) {
-                if (dynamicRangeProfile == entry.data.i64[i]) {
-                    return true;
-                }
-            }
-
-            return false;
-        default:
-            return false;
-    }
-
-    return false;
-}
-
-//check if format is 10-bit compatible
-bool is10bitDynamicRangeProfile(int64_t dynamicRangeProfile) {
-    switch (dynamicRangeProfile) {
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10_PLUS:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HDR10:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_HLG10:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_OEM_PO:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF:
-        case ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_DOLBY_VISION_10B_HDR_REF_PO:
-            return true;
-        default:
-            return false;
-    }
-}
-
-bool isPublicFormat(int32_t format)
+bool SessionConfigurationUtils::isPublicFormat(int32_t format)
 {
     switch(format) {
         case HAL_PIXEL_FORMAT_RGBA_8888:
@@ -309,34 +287,11 @@ bool isPublicFormat(int32_t format)
     }
 }
 
-bool isStreamUseCaseSupported(int64_t streamUseCase,
-        const CameraMetadata &deviceInfo) {
-    camera_metadata_ro_entry_t availableStreamUseCases =
-            deviceInfo.find(ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES);
-
-    if (availableStreamUseCases.count == 0 &&
-            streamUseCase == ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT) {
-        return true;
-    }
-    // Allow vendor stream use case unconditionally.
-    if (streamUseCase >= ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_VENDOR_START) {
-        return true;
-    }
-
-    for (size_t i = 0; i < availableStreamUseCases.count; i++) {
-        if (availableStreamUseCases.data.i64[i] == streamUseCase) {
-            return true;
-        }
-    }
-    return false;
-}
-
-binder::Status createSurfaceFromGbp(
+binder::Status SessionConfigurationUtils::createSurfaceFromGbp(
         OutputStreamInfo& streamInfo, bool isStreamInfoValid,
         sp<Surface>& surface, const sp<IGraphicBufferProducer>& gbp,
         const String8 &logicalCameraId, const CameraMetadata &physicalCameraMetadata,
-        const std::vector<int32_t> &sensorPixelModesUsed, int64_t dynamicRangeProfile,
-        int64_t streamUseCase, int timestampBase, int mirrorMode) {
+        const std::vector<int32_t> &sensorPixelModesUsed){
     // bufferProducer must be non-null
     if (gbp == nullptr) {
         String8 msg = String8::format("Camera %s: Surface is NULL", logicalCameraId.string());
@@ -434,43 +389,6 @@ binder::Status createSurfaceFromGbp(
         ALOGE("%s: %s", __FUNCTION__, msg.string());
         return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());
     }
-    if (!SessionConfigurationUtils::isDynamicRangeProfileSupported(dynamicRangeProfile,
-                physicalCameraMetadata)) {
-        String8 msg = String8::format("Camera %s: Dynamic range profile 0x%" PRIx64
-                " not supported,failed to create output stream", logicalCameraId.string(),
-                dynamicRangeProfile);
-        ALOGE("%s: %s", __FUNCTION__, msg.string());
-        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());
-    }
-    if (SessionConfigurationUtils::is10bitDynamicRangeProfile(dynamicRangeProfile) &&
-            !SessionConfigurationUtils::is10bitCompatibleFormat(format)) {
-        String8 msg = String8::format("Camera %s: No 10-bit supported stream configurations with "
-                "format %#x defined and profile %" PRIx64 ", failed to create output stream",
-                logicalCameraId.string(), format, dynamicRangeProfile);
-        ALOGE("%s: %s", __FUNCTION__, msg.string());
-        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());
-    }
-    if (!SessionConfigurationUtils::isStreamUseCaseSupported(streamUseCase,
-            physicalCameraMetadata)) {
-        String8 msg = String8::format("Camera %s: stream use case %" PRId64 " not supported,"
-                " failed to create output stream", logicalCameraId.string(), streamUseCase);
-        ALOGE("%s: %s", __FUNCTION__, msg.string());
-        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());
-    }
-    if (timestampBase < OutputConfiguration::TIMESTAMP_BASE_DEFAULT ||
-            timestampBase > OutputConfiguration::TIMESTAMP_BASE_CHOREOGRAPHER_SYNCED) {
-        String8 msg = String8::format("Camera %s: invalid timestamp base %d",
-                logicalCameraId.string(), timestampBase);
-        ALOGE("%s: %s", __FUNCTION__, msg.string());
-        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());
-    }
-    if (mirrorMode < OutputConfiguration::MIRROR_MODE_AUTO ||
-            mirrorMode > OutputConfiguration::MIRROR_MODE_V) {
-        String8 msg = String8::format("Camera %s: invalid mirroring mode %d",
-                logicalCameraId.string(), mirrorMode);
-        ALOGE("%s: %s", __FUNCTION__, msg.string());
-        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());
-    }
 
     if (!isStreamInfoValid) {
         streamInfo.width = width;
@@ -479,10 +397,6 @@ binder::Status createSurfaceFromGbp(
         streamInfo.dataSpace = dataSpace;
         streamInfo.consumerUsage = consumerUsage;
         streamInfo.sensorPixelModesUsed = overriddenSensorPixelModes;
-        streamInfo.dynamicRangeProfile = dynamicRangeProfile;
-        streamInfo.streamUseCase = streamUseCase;
-        streamInfo.timestampBase = timestampBase;
-        streamInfo.mirrorMode = mirrorMode;
         return binder::Status::ok();
     }
     if (width != streamInfo.width) {
@@ -523,49 +437,114 @@ binder::Status createSurfaceFromGbp(
     return binder::Status::ok();
 }
 
-void mapStreamInfo(const OutputStreamInfo &streamInfo,
+void SessionConfigurationUtils::mapStreamInfo(const OutputStreamInfo &streamInfo,
             camera3::camera_stream_rotation_t rotation, String8 physicalId,
-            int32_t groupId, aidl::android::hardware::camera::device::Stream *stream /*out*/) {
+            int32_t groupId, hardware::camera::device::V3_7::Stream *stream /*out*/) {
     if (stream == nullptr) {
         return;
     }
 
-    stream->streamType = aidl::android::hardware::camera::device::StreamType::OUTPUT;
-    stream->width = streamInfo.width;
-    stream->height = streamInfo.height;
-    stream->format = AidlCamera3Device::mapToAidlPixelFormat(streamInfo.format);
+    stream->v3_4.v3_2.streamType = hardware::camera::device::V3_2::StreamType::OUTPUT;
+    stream->v3_4.v3_2.width = streamInfo.width;
+    stream->v3_4.v3_2.height = streamInfo.height;
+    stream->v3_4.v3_2.format = Camera3Device::mapToPixelFormat(streamInfo.format);
     auto u = streamInfo.consumerUsage;
     camera3::Camera3OutputStream::applyZSLUsageQuirk(streamInfo.format, &u);
-    stream->usage = AidlCamera3Device::mapToAidlConsumerUsage(u);
-    stream->dataSpace = AidlCamera3Device::mapToAidlDataspace(streamInfo.dataSpace);
-    stream->rotation = AidlCamera3Device::mapToAidlStreamRotation(rotation);
-    stream->id = -1; // Invalid stream id
-    stream->physicalCameraId = std::string(physicalId.string());
-    stream->bufferSize = 0;
+    stream->v3_4.v3_2.usage = Camera3Device::mapToConsumerUsage(u);
+    stream->v3_4.v3_2.dataSpace = Camera3Device::mapToHidlDataspace(streamInfo.dataSpace);
+    stream->v3_4.v3_2.rotation = Camera3Device::mapToStreamRotation(rotation);
+    stream->v3_4.v3_2.id = -1; // Invalid stream id
+    stream->v3_4.physicalCameraId = std::string(physicalId.string());
+    stream->v3_4.bufferSize = 0;
     stream->groupId = groupId;
     stream->sensorPixelModesUsed.resize(streamInfo.sensorPixelModesUsed.size());
     size_t idx = 0;
-    using SensorPixelMode = aidl::android::hardware::camera::metadata::SensorPixelMode;
     for (auto mode : streamInfo.sensorPixelModesUsed) {
         stream->sensorPixelModesUsed[idx++] =
-                static_cast<SensorPixelMode>(mode);
-    }
-    using DynamicRangeProfile =
-            aidl::android::hardware::camera::metadata::RequestAvailableDynamicRangeProfilesMap;
-    stream->dynamicRangeProfile = static_cast<DynamicRangeProfile>(streamInfo.dynamicRangeProfile);
-    using StreamUseCases =
-            aidl::android::hardware::camera::metadata::ScalerAvailableStreamUseCases;
-    stream->useCase = static_cast<StreamUseCases>(streamInfo.streamUseCase);
+                static_cast<CameraMetadataEnumAndroidSensorPixelMode>(mode);
+    }
+}
+
+binder::Status SessionConfigurationUtils::checkPhysicalCameraId(
+        const std::vector<std::string> &physicalCameraIds, const String8 &physicalCameraId,
+        const String8 &logicalCameraId) {
+    if (physicalCameraId.size() == 0) {
+        return binder::Status::ok();
+    }
+    if (std::find(physicalCameraIds.begin(), physicalCameraIds.end(),
+        physicalCameraId.string()) == physicalCameraIds.end()) {
+        String8 msg = String8::format("Camera %s: Camera doesn't support physicalCameraId %s.",
+                logicalCameraId.string(), physicalCameraId.string());
+        ALOGE("%s: %s", __FUNCTION__, msg.string());
+        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());
+    }
+    return binder::Status::ok();
+}
+
+binder::Status SessionConfigurationUtils::checkSurfaceType(size_t numBufferProducers,
+        bool deferredConsumer, int surfaceType)  {
+    if (numBufferProducers > MAX_SURFACES_PER_STREAM) {
+        ALOGE("%s: GraphicBufferProducer count %zu for stream exceeds limit of %d",
+                __FUNCTION__, numBufferProducers, MAX_SURFACES_PER_STREAM);
+        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, "Surface count is too high");
+    } else if ((numBufferProducers == 0) && (!deferredConsumer)) {
+        ALOGE("%s: Number of consumers cannot be smaller than 1", __FUNCTION__);
+        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, "No valid consumers.");
+    }
+
+    bool validSurfaceType = ((surfaceType == OutputConfiguration::SURFACE_TYPE_SURFACE_VIEW) ||
+            (surfaceType == OutputConfiguration::SURFACE_TYPE_SURFACE_TEXTURE));
+
+    if (deferredConsumer && !validSurfaceType) {
+        ALOGE("%s: Target surface has invalid surfaceType = %d.", __FUNCTION__, surfaceType);
+        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, "Target Surface is invalid");
+    }
+
+    return binder::Status::ok();
+}
+
+binder::Status SessionConfigurationUtils::checkOperatingMode(int operatingMode,
+        const CameraMetadata &staticInfo, const String8 &cameraId) {
+    if (operatingMode < 0) {
+        String8 msg = String8::format(
+            "Camera %s: Invalid operating mode %d requested", cameraId.string(), operatingMode);
+        ALOGE("%s: %s", __FUNCTION__, msg.string());
+        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,
+                msg.string());
+    }
+
+    bool isConstrainedHighSpeed = (operatingMode == ICameraDeviceUser::CONSTRAINED_HIGH_SPEED_MODE);
+    if (isConstrainedHighSpeed) {
+        camera_metadata_ro_entry_t entry = staticInfo.find(ANDROID_REQUEST_AVAILABLE_CAPABILITIES);
+        bool isConstrainedHighSpeedSupported = false;
+        for(size_t i = 0; i < entry.count; ++i) {
+            uint8_t capability = entry.data.u8[i];
+            if (capability == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO) {
+                isConstrainedHighSpeedSupported = true;
+                break;
+            }
+        }
+        if (!isConstrainedHighSpeedSupported) {
+            String8 msg = String8::format(
+                "Camera %s: Try to create a constrained high speed configuration on a device"
+                " that doesn't support it.", cameraId.string());
+            ALOGE("%s: %s", __FUNCTION__, msg.string());
+            return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,
+                    msg.string());
+        }
+    }
+
+    return binder::Status::ok();
 }
 
 binder::Status
-convertToHALStreamCombination(
+SessionConfigurationUtils::convertToHALStreamCombination(
         const SessionConfiguration& sessionConfiguration,
         const String8 &logicalCameraId, const CameraMetadata &deviceInfo,
         metadataGetter getMetadata, const std::vector<std::string> &physicalCameraIds,
-        aidl::android::hardware::camera::device::StreamConfiguration &streamConfiguration,
+        hardware::camera::device::V3_7::StreamConfiguration &streamConfiguration,
         bool overrideForPerfClass, bool *earlyExit) {
-    using SensorPixelMode = aidl::android::hardware::camera::metadata::SensorPixelMode;
+
     auto operatingMode = sessionConfiguration.getOperatingMode();
     binder::Status res = checkOperatingMode(operatingMode, deviceInfo, logicalCameraId);
     if (!res.isOk()) {
@@ -578,7 +557,7 @@ convertToHALStreamCombination(
         return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());
     }
     *earlyExit = false;
-    auto ret = AidlCamera3Device::mapToAidlStreamConfigurationMode(
+    auto ret = Camera3Device::mapToStreamConfigurationMode(
             static_cast<camera_stream_configuration_mode_t> (operatingMode),
             /*out*/ &streamConfiguration.operationMode);
     if (ret != OK) {
@@ -599,31 +578,19 @@ convertToHALStreamCombination(
     streamConfiguration.streams.resize(streamCount);
     size_t streamIdx = 0;
     if (isInputValid) {
-        std::vector<SensorPixelMode> defaultSensorPixelModes;
+        hardware::hidl_vec<CameraMetadataEnumAndroidSensorPixelMode> defaultSensorPixelModes;
         defaultSensorPixelModes.resize(1);
         defaultSensorPixelModes[0] =
-                static_cast<SensorPixelMode>(ANDROID_SENSOR_PIXEL_MODE_DEFAULT);
-        aidl::android::hardware::camera::device::Stream stream;
-        stream.id = 0;
-        stream.streamType =  aidl::android::hardware::camera::device::StreamType::INPUT;
-        stream.width = static_cast<uint32_t> (sessionConfiguration.getInputWidth());
-        stream.height =  static_cast<uint32_t> (sessionConfiguration.getInputHeight());
-        stream.format =
-                AidlCamera3Device::AidlCamera3Device::mapToAidlPixelFormat(
-                        sessionConfiguration.getInputFormat());
-        stream.usage = static_cast<aidl::android::hardware::graphics::common::BufferUsage>(0);
-        stream.dataSpace =
-              static_cast<aidl::android::hardware::graphics::common::Dataspace>(
-                      HAL_DATASPACE_UNKNOWN);
-        stream.rotation = aidl::android::hardware::camera::device::StreamRotation::ROTATION_0;
-        stream.bufferSize = 0;
-        stream.groupId = -1;
-        stream.sensorPixelModesUsed = defaultSensorPixelModes;
-        using DynamicRangeProfile =
-            aidl::android::hardware::camera::metadata::RequestAvailableDynamicRangeProfilesMap;
-        stream.dynamicRangeProfile =
-            DynamicRangeProfile::ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD;
-        streamConfiguration.streams[streamIdx++] = stream;
+                static_cast<CameraMetadataEnumAndroidSensorPixelMode>(
+                        ANDROID_SENSOR_PIXEL_MODE_DEFAULT);
+        streamConfiguration.streams[streamIdx++] = {{{/*streamId*/0,
+                hardware::camera::device::V3_2::StreamType::INPUT,
+                static_cast<uint32_t> (sessionConfiguration.getInputWidth()),
+                static_cast<uint32_t> (sessionConfiguration.getInputHeight()),
+                Camera3Device::mapToPixelFormat(sessionConfiguration.getInputFormat()),
+                /*usage*/ 0, HAL_DATASPACE_UNKNOWN,
+                hardware::camera::device::V3_2::StreamRotation::ROTATION_0},
+                /*physicalId*/ nullptr, /*bufferSize*/0}, /*groupId*/-1, defaultSensorPixelModes};
         streamConfiguration.multiResolutionInputImage =
                 sessionConfiguration.inputIsMultiResolution();
     }
@@ -634,7 +601,6 @@ convertToHALStreamCombination(
         bool deferredConsumer = it.isDeferred();
         String8 physicalCameraId = String8(it.getPhysicalCameraId());
 
-        int64_t dynamicRangeProfile = it.getDynamicRangeProfile();
         std::vector<int32_t> sensorPixelModesUsed = it.getSensorPixelModesUsed();
         const CameraMetadata &physicalDeviceInfo = getMetadata(physicalCameraId,
                 overrideForPerfClass);
@@ -656,9 +622,6 @@ convertToHALStreamCombination(
             return res;
         }
 
-        int64_t streamUseCase = it.getStreamUseCase();
-        int timestampBase = it.getTimestampBase();
-        int mirrorMode = it.getMirrorMode();
         if (deferredConsumer) {
             streamInfo.width = it.getWidth();
             streamInfo.height = it.getHeight();
@@ -669,7 +632,6 @@ convertToHALStreamCombination(
             if (surfaceType == OutputConfiguration::SURFACE_TYPE_SURFACE_VIEW) {
                 streamInfo.consumerUsage |= GraphicBuffer::USAGE_HW_COMPOSER;
             }
-            streamInfo.dynamicRangeProfile = it.getDynamicRangeProfile();
             if (checkAndOverrideSensorPixelModesUsed(sensorPixelModesUsed,
                     streamInfo.format, streamInfo.width,
                     streamInfo.height, metadataChosen, false /*flexibleConsumer*/,
@@ -679,7 +641,6 @@ convertToHALStreamCombination(
                         return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,
                                 "Deferred surface sensor pixel modes not valid");
             }
-            streamInfo.streamUseCase = streamUseCase;
             mapStreamInfo(streamInfo, camera3::CAMERA_STREAM_ROTATION_0, physicalCameraId, groupId,
                     &streamConfiguration.streams[streamIdx++]);
             isStreamInfoValid = true;
@@ -692,8 +653,7 @@ convertToHALStreamCombination(
         for (auto& bufferProducer : bufferProducers) {
             sp<Surface> surface;
             res = createSurfaceFromGbp(streamInfo, isStreamInfoValid, surface, bufferProducer,
-                    logicalCameraId, metadataChosen, sensorPixelModesUsed, dynamicRangeProfile,
-                    streamUseCase, timestampBase, mirrorMode);
+                    logicalCameraId, metadataChosen, sensorPixelModesUsed);
 
             if (!res.isOk())
                 return res;
@@ -751,78 +711,6 @@ convertToHALStreamCombination(
     return binder::Status::ok();
 }
 
-binder::Status checkPhysicalCameraId(
-        const std::vector<std::string> &physicalCameraIds, const String8 &physicalCameraId,
-        const String8 &logicalCameraId) {
-    if (physicalCameraId.size() == 0) {
-        return binder::Status::ok();
-    }
-    if (std::find(physicalCameraIds.begin(), physicalCameraIds.end(),
-        physicalCameraId.string()) == physicalCameraIds.end()) {
-        String8 msg = String8::format("Camera %s: Camera doesn't support physicalCameraId %s.",
-                logicalCameraId.string(), physicalCameraId.string());
-        ALOGE("%s: %s", __FUNCTION__, msg.string());
-        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, msg.string());
-    }
-    return binder::Status::ok();
-}
-
-binder::Status checkSurfaceType(size_t numBufferProducers,
-        bool deferredConsumer, int surfaceType)  {
-    if (numBufferProducers > MAX_SURFACES_PER_STREAM) {
-        ALOGE("%s: GraphicBufferProducer count %zu for stream exceeds limit of %d",
-                __FUNCTION__, numBufferProducers, MAX_SURFACES_PER_STREAM);
-        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, "Surface count is too high");
-    } else if ((numBufferProducers == 0) && (!deferredConsumer)) {
-        ALOGE("%s: Number of consumers cannot be smaller than 1", __FUNCTION__);
-        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, "No valid consumers.");
-    }
-
-    bool validSurfaceType = ((surfaceType == OutputConfiguration::SURFACE_TYPE_SURFACE_VIEW) ||
-            (surfaceType == OutputConfiguration::SURFACE_TYPE_SURFACE_TEXTURE));
-
-    if (deferredConsumer && !validSurfaceType) {
-        ALOGE("%s: Target surface has invalid surfaceType = %d.", __FUNCTION__, surfaceType);
-        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT, "Target Surface is invalid");
-    }
-
-    return binder::Status::ok();
-}
-
-binder::Status checkOperatingMode(int operatingMode,
-        const CameraMetadata &staticInfo, const String8 &cameraId) {
-    if (operatingMode < 0) {
-        String8 msg = String8::format(
-            "Camera %s: Invalid operating mode %d requested", cameraId.string(), operatingMode);
-        ALOGE("%s: %s", __FUNCTION__, msg.string());
-        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,
-                msg.string());
-    }
-
-    bool isConstrainedHighSpeed = (operatingMode == ICameraDeviceUser::CONSTRAINED_HIGH_SPEED_MODE);
-    if (isConstrainedHighSpeed) {
-        camera_metadata_ro_entry_t entry = staticInfo.find(ANDROID_REQUEST_AVAILABLE_CAPABILITIES);
-        bool isConstrainedHighSpeedSupported = false;
-        for(size_t i = 0; i < entry.count; ++i) {
-            uint8_t capability = entry.data.u8[i];
-            if (capability == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO) {
-                isConstrainedHighSpeedSupported = true;
-                break;
-            }
-        }
-        if (!isConstrainedHighSpeedSupported) {
-            String8 msg = String8::format(
-                "Camera %s: Try to create a constrained high speed configuration on a device"
-                " that doesn't support it.", cameraId.string());
-            ALOGE("%s: %s", __FUNCTION__, msg.string());
-            return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,
-                    msg.string());
-        }
-    }
-
-    return binder::Status::ok();
-}
-
 static bool inStreamConfigurationMap(int format, int width, int height,
         const std::unordered_map<int, std::vector<camera3::StreamConfiguration>> &sm) {
     auto scs = sm.find(format);
@@ -841,7 +729,7 @@ static std::unordered_set<int32_t> convertToSet(const std::vector<int32_t> &sens
     return std::unordered_set<int32_t>(sensorPixelModesUsed.begin(), sensorPixelModesUsed.end());
 }
 
-status_t checkAndOverrideSensorPixelModesUsed(
+status_t SessionConfigurationUtils::checkAndOverrideSensorPixelModesUsed(
         const std::vector<int32_t> &sensorPixelModesUsed, int format, int width, int height,
         const CameraMetadata &staticInfo, bool flexibleConsumer,
         std::unordered_set<int32_t> *overriddenSensorPixelModesUsed) {
@@ -907,7 +795,44 @@ status_t checkAndOverrideSensorPixelModesUsed(
     return OK;
 }
 
-bool targetPerfClassPrimaryCamera(
+bool SessionConfigurationUtils::isUltraHighResolutionSensor(const CameraMetadata &deviceInfo) {
+    camera_metadata_ro_entry_t entryCap;
+    entryCap = deviceInfo.find(ANDROID_REQUEST_AVAILABLE_CAPABILITIES);
+    // Go through the capabilities and check if it has
+    // ANDROID_REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR
+    for (size_t i = 0; i < entryCap.count; ++i) {
+        uint8_t capability = entryCap.data.u8[i];
+        if (capability == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR) {
+            return true;
+        }
+    }
+    return false;
+}
+
+bool SessionConfigurationUtils::convertHALStreamCombinationFromV37ToV34(
+        hardware::camera::device::V3_4::StreamConfiguration &streamConfigV34,
+        const hardware::camera::device::V3_7::StreamConfiguration &streamConfigV37) {
+    if (streamConfigV37.multiResolutionInputImage) {
+        // ICameraDevice older than 3.7 doesn't support multi-resolution input image.
+        return false;
+    }
+
+    streamConfigV34.streams.resize(streamConfigV37.streams.size());
+    for (size_t i = 0; i < streamConfigV37.streams.size(); i++) {
+        if (streamConfigV37.streams[i].groupId != -1) {
+            // ICameraDevice older than 3.7 doesn't support multi-resolution output
+            // image
+            return false;
+        }
+        streamConfigV34.streams[i] = streamConfigV37.streams[i].v3_4;
+    }
+    streamConfigV34.operationMode = streamConfigV37.operationMode;
+    streamConfigV34.sessionParams = streamConfigV37.sessionParams;
+
+    return true;
+}
+
+bool SessionConfigurationUtils::targetPerfClassPrimaryCamera(
         const std::set<std::string>& perfClassPrimaryCameraIds, const std::string& cameraId,
         int targetSdkVersion) {
     bool isPerfClassPrimaryCamera =
@@ -915,6 +840,5 @@ bool targetPerfClassPrimaryCamera(
     return targetSdkVersion >= SDK_VERSION_S && isPerfClassPrimaryCamera;
 }
 
-} // namespace SessionConfigurationUtils
 } // namespace camera3
 } // namespace android
diff --git a/services/camera/libcameraservice/utils/SessionConfigurationUtils.h b/services/camera/libcameraservice/utils/SessionConfigurationUtils.h
index a127c7bdcb..192e2415b8 100644
--- a/services/camera/libcameraservice/utils/SessionConfigurationUtils.h
+++ b/services/camera/libcameraservice/utils/SessionConfigurationUtils.h
@@ -21,18 +21,15 @@
 #include <camera/camera2/OutputConfiguration.h>
 #include <camera/camera2/SessionConfiguration.h>
 #include <camera/camera2/SubmitInfo.h>
-#include <aidl/android/hardware/camera/device/ICameraDevice.h>
+#include <android/hardware/camera/device/3.7/types.h>
 #include <android/hardware/camera/device/3.4/ICameraDeviceSession.h>
 #include <android/hardware/camera/device/3.7/ICameraDeviceSession.h>
 
 #include <device3/Camera3StreamInterface.h>
-#include <utils/IPCTransport.h>
 
 #include <set>
 #include <stdint.h>
 
-#include "SessionConfigurationUtilsHost.h"
-
 // Convenience methods for constructing binder::Status objects for error returns
 
 #define STATUS_ERROR(errorCode, errorString) \
@@ -47,7 +44,7 @@
 namespace android {
 namespace camera3 {
 
-typedef std::function<CameraMetadata (const String8 &, bool overrideForPerfClass)> metadataGetter;
+typedef std::function<CameraMetadata (const String8 &, int targetSdkVersion)> metadataGetter;
 
 class StreamConfiguration {
 public:
@@ -72,92 +69,96 @@ struct StreamConfigurationPair {
             mMaximumResolutionStreamConfigurationMap;
 };
 
-namespace SessionConfigurationUtils {
+class SessionConfigurationUtils {
+public:
+    static camera3::Size getMaxJpegResolution(const CameraMetadata &metadata,
+            bool ultraHighResolution);
 
-camera3::Size getMaxJpegResolution(const CameraMetadata &metadata,
-        bool ultraHighResolution);
+    static size_t getUHRMaxJpegBufferSize(camera3::Size uhrMaxJpegSize,
+            camera3::Size defaultMaxJpegSize, size_t defaultMaxJpegBufferSize);
 
-size_t getUHRMaxJpegBufferSize(camera3::Size uhrMaxJpegSize,
-        camera3::Size defaultMaxJpegSize, size_t defaultMaxJpegBufferSize);
+    static int64_t euclidDistSquare(int32_t x0, int32_t y0, int32_t x1, int32_t y1);
 
-int64_t euclidDistSquare(int32_t x0, int32_t y0, int32_t x1, int32_t y1);
+    // Find the closest dimensions for a given format in available stream configurations with
+    // a width <= ROUNDING_WIDTH_CAP
+    static bool roundBufferDimensionNearest(int32_t width, int32_t height, int32_t format,
+            android_dataspace dataSpace, const CameraMetadata& info, bool maxResolution,
+            /*out*/int32_t* outWidth, /*out*/int32_t* outHeight);
 
-// Find the closest dimensions for a given format in available stream configurations with
-// a width <= ROUNDING_WIDTH_CAP
-bool roundBufferDimensionNearest(int32_t width, int32_t height, int32_t format,
-        android_dataspace dataSpace, const CameraMetadata& info, bool maxResolution,
-        /*out*/int32_t* outWidth, /*out*/int32_t* outHeight);
+    static bool getArrayWidthAndHeight(const CameraMetadata *deviceInfo, int32_t arrayTag,
+            int32_t *width, int32_t *height);
 
-// check if format is not custom format
-bool isPublicFormat(int32_t format);
+    //check if format is not custom format
+    static bool isPublicFormat(int32_t format);
 
-// Create a Surface from an IGraphicBufferProducer. Returns error if
-// IGraphicBufferProducer's property doesn't match with streamInfo
-binder::Status createSurfaceFromGbp(
+    // Create a Surface from an IGraphicBufferProducer. Returns error if
+    // IGraphicBufferProducer's property doesn't match with streamInfo
+    static binder::Status createSurfaceFromGbp(
         camera3::OutputStreamInfo& streamInfo, bool isStreamInfoValid,
         sp<Surface>& surface, const sp<IGraphicBufferProducer>& gbp,
         const String8 &logicalCameraId, const CameraMetadata &physicalCameraMetadata,
-        const std::vector<int32_t> &sensorPixelModesUsed,  int64_t dynamicRangeProfile,
-        int64_t streamUseCase, int timestampBase, int mirrorMode);
-
-//check if format is 10-bit output compatible
-bool is10bitCompatibleFormat(int32_t format);
-
-// check if the dynamic range requires 10-bit output
-bool is10bitDynamicRangeProfile(int64_t dynamicRangeProfile);
-
-// Check if the device supports a given dynamicRangeProfile
-bool isDynamicRangeProfileSupported(int64_t dynamicRangeProfile, const CameraMetadata& staticMeta);
-
-bool isStreamUseCaseSupported(int64_t streamUseCase, const CameraMetadata &deviceInfo);
-
-void mapStreamInfo(const OutputStreamInfo &streamInfo,
-        camera3::camera_stream_rotation_t rotation, String8 physicalId,
-        int32_t groupId, aidl::android::hardware::camera::device::Stream *stream /*out*/);
-
-// Check that the physicalCameraId passed in is spported by the camera
-// device.
-binder::Status checkPhysicalCameraId(
-const std::vector<std::string> &physicalCameraIds, const String8 &physicalCameraId,
-const String8 &logicalCameraId);
-
-binder::Status checkSurfaceType(size_t numBufferProducers,
-bool deferredConsumer, int surfaceType);
-
-binder::Status checkOperatingMode(int operatingMode,
-const CameraMetadata &staticInfo, const String8 &cameraId);
-
-binder::Status
-convertToHALStreamCombination(
-    const SessionConfiguration& sessionConfiguration,
-    const String8 &logicalCameraId, const CameraMetadata &deviceInfo,
-    metadataGetter getMetadata, const std::vector<std::string> &physicalCameraIds,
-    aidl::android::hardware::camera::device::StreamConfiguration &streamConfiguration,
-    bool overrideForPerfClass, bool *earlyExit);
-
-StreamConfigurationPair getStreamConfigurationPair(const CameraMetadata &metadata);
-
-status_t checkAndOverrideSensorPixelModesUsed(
-        const std::vector<int32_t> &sensorPixelModesUsed, int format, int width, int height,
-        const CameraMetadata &staticInfo, bool flexibleConsumer,
-        std::unordered_set<int32_t> *overriddenSensorPixelModesUsed);
-
-bool targetPerfClassPrimaryCamera(
-        const std::set<std::string>& perfClassPrimaryCameraIds, const std::string& cameraId,
-        int32_t targetSdkVersion);
-
-constexpr int32_t MAX_SURFACES_PER_STREAM = 4;
-
-constexpr int32_t ROUNDING_WIDTH_CAP = 1920;
-
-constexpr int32_t SDK_VERSION_S = 31;
-extern int32_t PERF_CLASS_LEVEL;
-extern bool IS_PERF_CLASS;
-constexpr int32_t PERF_CLASS_JPEG_THRESH_W = 1920;
-constexpr int32_t PERF_CLASS_JPEG_THRESH_H = 1080;
+        const std::vector<int32_t> &sensorPixelModesUsed);
+
+    static void mapStreamInfo(const camera3::OutputStreamInfo &streamInfo,
+            camera3::camera_stream_rotation_t rotation, String8 physicalId, int32_t groupId,
+            hardware::camera::device::V3_7::Stream *stream /*out*/);
+
+    // Check that the physicalCameraId passed in is spported by the camera
+    // device.
+    static binder::Status checkPhysicalCameraId(
+        const std::vector<std::string> &physicalCameraIds, const String8 &physicalCameraId,
+        const String8 &logicalCameraId);
+
+    static binder::Status checkSurfaceType(size_t numBufferProducers,
+        bool deferredConsumer, int surfaceType);
+
+    static binder::Status checkOperatingMode(int operatingMode,
+        const CameraMetadata &staticInfo, const String8 &cameraId);
+
+    // utility function to convert AIDL SessionConfiguration to HIDL
+    // streamConfiguration. Also checks for validity of SessionConfiguration and
+    // returns a non-ok binder::Status if the passed in session configuration
+    // isn't valid.
+    static binder::Status
+    convertToHALStreamCombination(const SessionConfiguration& sessionConfiguration,
+            const String8 &cameraId, const CameraMetadata &deviceInfo,
+            metadataGetter getMetadata, const std::vector<std::string> &physicalCameraIds,
+            hardware::camera::device::V3_7::StreamConfiguration &streamConfiguration,
+            bool overrideForPerfClass, bool *earlyExit);
+
+    // Utility function to convert a V3_7::StreamConfiguration to
+    // V3_4::StreamConfiguration. Return false if the original V3_7 configuration cannot
+    // be used by older version HAL.
+    static bool convertHALStreamCombinationFromV37ToV34(
+            hardware::camera::device::V3_4::StreamConfiguration &streamConfigV34,
+            const hardware::camera::device::V3_7::StreamConfiguration &streamConfigV37);
+
+    static StreamConfigurationPair getStreamConfigurationPair(const CameraMetadata &metadata);
+
+    static status_t checkAndOverrideSensorPixelModesUsed(
+            const std::vector<int32_t> &sensorPixelModesUsed, int format, int width, int height,
+            const CameraMetadata &staticInfo, bool flexibleConsumer,
+            std::unordered_set<int32_t> *overriddenSensorPixelModesUsed);
+
+    static bool isUltraHighResolutionSensor(const CameraMetadata &deviceInfo);
+
+    static int32_t getAppropriateModeTag(int32_t defaultTag, bool maxResolution = false);
+
+    static bool targetPerfClassPrimaryCamera(
+            const std::set<std::string>& perfClassPrimaryCameraIds, const std::string& cameraId,
+            int32_t targetSdkVersion);
+
+    static const int32_t MAX_SURFACES_PER_STREAM = 4;
+
+    static const int32_t ROUNDING_WIDTH_CAP = 1920;
+
+    static const int32_t SDK_VERSION_S = 31;
+    static int32_t PERF_CLASS_LEVEL;
+    static bool IS_PERF_CLASS;
+    static const int32_t PERF_CLASS_JPEG_THRESH_W = 1920;
+    static const int32_t PERF_CLASS_JPEG_THRESH_H = 1080;
+};
 
-} // SessionConfigurationUtils
 } // camera3
 } // android
-
 #endif
diff --git a/services/camera/libcameraservice/utils/SessionConfigurationUtilsHidl.cpp b/services/camera/libcameraservice/utils/SessionConfigurationUtilsHidl.cpp
deleted file mode 100644
index 4e6f832560..0000000000
--- a/services/camera/libcameraservice/utils/SessionConfigurationUtilsHidl.cpp
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <cutils/properties.h>
-
-#include "SessionConfigurationUtils.h"
-#include "SessionConfigurationUtilsHidl.h"
-
-#include "../CameraService.h"
-#include "device3/aidl/AidlCamera3Device.h"
-#include "device3/hidl/HidlCamera3Device.h"
-#include "device3/Camera3OutputStream.h"
-
-using android::camera3::OutputStreamInfo;
-using android::hardware::camera2::ICameraDeviceUser;
-using android::hardware::camera::metadata::V3_6::CameraMetadataEnumAndroidSensorPixelMode;
-
-namespace android {
-namespace camera3 {
-
-namespace SessionConfigurationUtils {
-
-status_t
-convertAidlToHidl37StreamCombination(
-        const aidl::android::hardware::camera::device::StreamConfiguration &aidl,
-        hardware::camera::device::V3_7::StreamConfiguration &hidl) {
-    hidl.operationMode =
-        static_cast<hardware::camera::device::V3_2::StreamConfigurationMode>(aidl.operationMode);
-    if (aidl.streamConfigCounter < 0) {
-        return BAD_VALUE;
-    }
-    hidl.streamConfigCounter = static_cast<uint32_t>(aidl.streamConfigCounter);
-    hidl.multiResolutionInputImage = aidl.multiResolutionInputImage;
-    hidl.sessionParams = aidl.sessionParams.metadata;
-    hidl.streams.resize(aidl.streams.size());
-    size_t i = 0;
-    for (const auto &stream : aidl.streams) {
-        if (static_cast<int>(stream.dynamicRangeProfile) !=
-                ANDROID_REQUEST_AVAILABLE_DYNAMIC_RANGE_PROFILES_MAP_STANDARD) {
-            ALOGE("%s  Dynamic range profile %" PRId64 " not supported by HIDL", __FUNCTION__,
-                    stream.dynamicRangeProfile);
-            return BAD_VALUE;
-        }
-
-        if (static_cast<int>(stream.useCase) != ANDROID_SCALER_AVAILABLE_STREAM_USE_CASES_DEFAULT) {
-            ALOGE("%s Stream use case %" PRId64 "not supported by HIDL", __FUNCTION__,
-                    stream.useCase);
-            return BAD_VALUE;
-        }
-
-        // hidl v3_7
-        hidl.streams[i].groupId = stream.groupId;
-        hidl.streams[i].sensorPixelModesUsed.resize(stream.sensorPixelModesUsed.size());
-        size_t j = 0;
-        for (const auto &mode : stream.sensorPixelModesUsed) {
-            hidl.streams[i].sensorPixelModesUsed[j] =
-                    static_cast<CameraMetadataEnumAndroidSensorPixelMode>(mode);
-            j++;
-        }
-
-        //hidl v3_4
-        hidl.streams[i].v3_4.physicalCameraId = stream.physicalCameraId;
-
-        if (stream.bufferSize < 0) {
-            return BAD_VALUE;
-        }
-        hidl.streams[i].v3_4.bufferSize = static_cast<uint32_t>(stream.bufferSize);
-
-        // hild v3_2
-        hidl.streams[i].v3_4.v3_2.id = stream.id;
-        hidl.streams[i].v3_4.v3_2.format =
-                static_cast<hardware::graphics::common::V1_0::PixelFormat>(stream.format);
-
-        if (stream.width < 0 || stream.height < 0) {
-            return BAD_VALUE;
-        }
-        hidl.streams[i].v3_4.v3_2.width = static_cast<uint32_t>(stream.width);
-        hidl.streams[i].v3_4.v3_2.height = static_cast<uint32_t>(stream.height);
-        hidl.streams[i].v3_4.v3_2.usage =
-                static_cast<hardware::camera::device::V3_2::BufferUsageFlags>(stream.usage);
-        hidl.streams[i].v3_4.v3_2.streamType =
-                static_cast<hardware::camera::device::V3_2::StreamType>(stream.streamType);
-        hidl.streams[i].v3_4.v3_2.dataSpace =
-                static_cast<hardware::camera::device::V3_2::DataspaceFlags>(stream.dataSpace);
-        hidl.streams[i].v3_4.v3_2.rotation =
-                static_cast<hardware::camera::device::V3_2::StreamRotation>(stream.rotation);
-        i++;
-    }
-    return OK;
-}
-
-binder::Status
-convertToHALStreamCombination(
-        const SessionConfiguration& sessionConfiguration,
-        const String8 &logicalCameraId, const CameraMetadata &deviceInfo,
-        metadataGetter getMetadata, const std::vector<std::string> &physicalCameraIds,
-        hardware::camera::device::V3_7::StreamConfiguration &streamConfiguration,
-        bool overrideForPerfClass, bool *earlyExit) {
-    aidl::android::hardware::camera::device::StreamConfiguration aidlStreamConfiguration;
-    auto ret = convertToHALStreamCombination(sessionConfiguration, logicalCameraId, deviceInfo,
-            getMetadata, physicalCameraIds, aidlStreamConfiguration, overrideForPerfClass,
-            earlyExit);
-    if (!ret.isOk()) {
-        return ret;
-    }
-    if (earlyExit != nullptr && *earlyExit) {
-        return binder::Status::ok();
-    }
-
-    if (convertAidlToHidl37StreamCombination(aidlStreamConfiguration, streamConfiguration) != OK) {
-        return STATUS_ERROR(CameraService::ERROR_ILLEGAL_ARGUMENT,
-                "Invalid AIDL->HIDL3.7 conversion");
-    }
-
-    return binder::Status::ok();
-}
-
-bool convertHALStreamCombinationFromV37ToV34(
-        hardware::camera::device::V3_4::StreamConfiguration &streamConfigV34,
-        const hardware::camera::device::V3_7::StreamConfiguration &streamConfigV37) {
-    if (streamConfigV37.multiResolutionInputImage) {
-        // ICameraDevice older than 3.7 doesn't support multi-resolution input image.
-        return false;
-    }
-
-    streamConfigV34.streams.resize(streamConfigV37.streams.size());
-    for (size_t i = 0; i < streamConfigV37.streams.size(); i++) {
-        if (streamConfigV37.streams[i].groupId != -1) {
-            // ICameraDevice older than 3.7 doesn't support multi-resolution output
-            // image
-            return false;
-        }
-        streamConfigV34.streams[i] = streamConfigV37.streams[i].v3_4;
-    }
-    streamConfigV34.operationMode = streamConfigV37.operationMode;
-    streamConfigV34.sessionParams = streamConfigV37.sessionParams;
-
-    return true;
-}
-
-} // namespace SessionConfigurationUtils
-} // namespace camera3
-} // namespace android
diff --git a/services/camera/libcameraservice/utils/SessionConfigurationUtilsHidl.h b/services/camera/libcameraservice/utils/SessionConfigurationUtilsHidl.h
deleted file mode 100644
index c47abe03d0..0000000000
--- a/services/camera/libcameraservice/utils/SessionConfigurationUtilsHidl.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef ANDROID_SERVERS_CAMERA_SESSION_CONFIGURATION_UTILS_HIDL_H
-#define ANDROID_SERVERS_CAMERA_SESSION_CONFIGURATION_UTILS_HIDL_H
-
-#include <android/hardware/camera/device/3.4/ICameraDeviceSession.h>
-#include <android/hardware/camera/device/3.7/ICameraDeviceSession.h>
-
-#include <utils/SessionConfigurationUtils.h>
-
-// Convenience methods for constructing binder::Status objects for error returns
-
-namespace android {
-namespace camera3 {
-
-namespace SessionConfigurationUtils {
-
-// utility function to convert AIDL SessionConfiguration to HIDL
-// streamConfiguration. Also checks for validity of SessionConfiguration and
-// returns a non-ok binder::Status if the passed in session configuration
-// isn't valid.
-binder::Status
-convertToHALStreamCombination(const SessionConfiguration& sessionConfiguration,
-        const String8 &cameraId, const CameraMetadata &deviceInfo,
-        metadataGetter getMetadata, const std::vector<std::string> &physicalCameraIds,
-        hardware::camera::device::V3_7::StreamConfiguration &streamConfiguration,
-        bool overrideForPerfClass, bool *earlyExit);
-
-// Utility function to convert a V3_7::StreamConfiguration to
-// V3_4::StreamConfiguration. Return false if the original V3_7 configuration cannot
-// be used by older version HAL.
-bool convertHALStreamCombinationFromV37ToV34(
-        hardware::camera::device::V3_4::StreamConfiguration &streamConfigV34,
-        const hardware::camera::device::V3_7::StreamConfiguration &streamConfigV37);
-} // SessionConfigurationUtils
-} // camera3
-} // android
-
-#endif
diff --git a/services/camera/libcameraservice/utils/SessionConfigurationUtilsHost.cpp b/services/camera/libcameraservice/utils/SessionConfigurationUtilsHost.cpp
deleted file mode 100644
index 1efdc6071d..0000000000
--- a/services/camera/libcameraservice/utils/SessionConfigurationUtilsHost.cpp
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "SessionConfigurationUtilsHost.h"
-
-namespace android {
-namespace camera3 {
-namespace SessionConfigurationUtils {
-
-int32_t getAppropriateModeTag(int32_t defaultTag, bool maxResolution) {
-    if (!maxResolution) {
-        return defaultTag;
-    }
-    switch (defaultTag) {
-        case ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS:
-            return ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION;
-        case ANDROID_SCALER_AVAILABLE_MIN_FRAME_DURATIONS:
-            return ANDROID_SCALER_AVAILABLE_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION;
-        case ANDROID_SCALER_AVAILABLE_STALL_DURATIONS:
-            return ANDROID_SCALER_AVAILABLE_STALL_DURATIONS_MAXIMUM_RESOLUTION;
-        case ANDROID_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS:
-            return ANDROID_DEPTH_AVAILABLE_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION;
-        case ANDROID_DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS:
-            return ANDROID_DEPTH_AVAILABLE_DEPTH_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION;
-        case ANDROID_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS:
-            return ANDROID_DEPTH_AVAILABLE_DEPTH_STALL_DURATIONS_MAXIMUM_RESOLUTION;
-        case ANDROID_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS:
-            return ANDROID_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION;
-        case ANDROID_DEPTH_AVAILABLE_DYNAMIC_DEPTH_MIN_FRAME_DURATIONS:
-            return ANDROID_DEPTH_AVAILABLE_DYNAMIC_DEPTH_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION;
-        case ANDROID_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STALL_DURATIONS:
-            return ANDROID_DEPTH_AVAILABLE_DYNAMIC_DEPTH_STALL_DURATIONS_MAXIMUM_RESOLUTION;
-        case ANDROID_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS:
-            return ANDROID_HEIC_AVAILABLE_HEIC_STREAM_CONFIGURATIONS_MAXIMUM_RESOLUTION;
-        case ANDROID_HEIC_AVAILABLE_HEIC_MIN_FRAME_DURATIONS:
-            return ANDROID_HEIC_AVAILABLE_HEIC_MIN_FRAME_DURATIONS_MAXIMUM_RESOLUTION;
-        case ANDROID_HEIC_AVAILABLE_HEIC_STALL_DURATIONS:
-            return ANDROID_HEIC_AVAILABLE_HEIC_STALL_DURATIONS_MAXIMUM_RESOLUTION;
-        case ANDROID_SENSOR_OPAQUE_RAW_SIZE:
-            return ANDROID_SENSOR_OPAQUE_RAW_SIZE_MAXIMUM_RESOLUTION;
-        case ANDROID_LENS_INTRINSIC_CALIBRATION:
-            return ANDROID_LENS_INTRINSIC_CALIBRATION_MAXIMUM_RESOLUTION;
-        case ANDROID_LENS_DISTORTION:
-            return ANDROID_LENS_DISTORTION_MAXIMUM_RESOLUTION;
-        default:
-            ALOGE("%s: Tag %d doesn't have a maximum resolution counterpart", __FUNCTION__,
-                    defaultTag);
-            return -1;
-    }
-    return -1;
-}
-
-bool isUltraHighResolutionSensor(const CameraMetadata &deviceInfo) {
-    camera_metadata_ro_entry_t entryCap;
-    entryCap = deviceInfo.find(ANDROID_REQUEST_AVAILABLE_CAPABILITIES);
-    // Go through the capabilities and check if it has
-    // ANDROID_REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR
-    for (size_t i = 0; i < entryCap.count; ++i) {
-        uint8_t capability = entryCap.data.u8[i];
-        if (capability == ANDROID_REQUEST_AVAILABLE_CAPABILITIES_ULTRA_HIGH_RESOLUTION_SENSOR) {
-            return true;
-        }
-    }
-    return false;
-}
-
-bool getArrayWidthAndHeight(const CameraMetadata *deviceInfo,
-        int32_t arrayTag, int32_t *width, int32_t *height) {
-    if (width == nullptr || height == nullptr) {
-        ALOGE("%s: width / height nullptr", __FUNCTION__);
-        return false;
-    }
-    camera_metadata_ro_entry_t entry;
-    entry = deviceInfo->find(arrayTag);
-    if (entry.count != 4) return false;
-    *width = entry.data.i32[2];
-    *height = entry.data.i32[3];
-    return true;
-}
-
-} // namespace SessionConfigurationUtils
-} // namespace camera3
-} // namespace android
\ No newline at end of file
diff --git a/services/camera/libcameraservice/utils/SessionConfigurationUtilsHost.h b/services/camera/libcameraservice/utils/SessionConfigurationUtilsHost.h
deleted file mode 100644
index 45b1e91ecb..0000000000
--- a/services/camera/libcameraservice/utils/SessionConfigurationUtilsHost.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef ANDROID_SERVERS_CAMERA_SESSION_CONFIGURATION_UTILS_HOST_H
-#define ANDROID_SERVERS_CAMERA_SESSION_CONFIGURATION_UTILS_HOST_H
-
-#include "camera/CameraMetadata.h"
-
-namespace android {
-namespace camera3 {
-namespace SessionConfigurationUtils {
-
-bool isUltraHighResolutionSensor(const CameraMetadata &deviceInfo);
-
-int32_t getAppropriateModeTag(int32_t defaultTag, bool maxResolution = false);
-
-bool getArrayWidthAndHeight(const CameraMetadata *deviceInfo, int32_t arrayTag,
-        int32_t *width, int32_t *height);
-
-} // SessionConfigurationUtils
-} // camera3
-} // android
-
-#endif
\ No newline at end of file
diff --git a/services/camera/libcameraservice/utils/SessionStatsBuilder.cpp b/services/camera/libcameraservice/utils/SessionStatsBuilder.cpp
index c3aac7276a..7a7707cf28 100644
--- a/services/camera/libcameraservice/utils/SessionStatsBuilder.cpp
+++ b/services/camera/libcameraservice/utils/SessionStatsBuilder.cpp
@@ -60,7 +60,6 @@ void SessionStatsBuilder::buildAndReset(int64_t* requestCount,
     mErrorResultCount = 0;
     mCounterStopped = false;
     mDeviceError = false;
-    mUserTag.clear();
     for (auto& streamStats : mStatsMap) {
         StreamStats& streamStat = streamStats.second;
         streamStat.mRequestedFrameCount = 0;
diff --git a/services/camera/libcameraservice/utils/SessionStatsBuilder.h b/services/camera/libcameraservice/utils/SessionStatsBuilder.h
index 2936531cd2..c23abb6067 100644
--- a/services/camera/libcameraservice/utils/SessionStatsBuilder.h
+++ b/services/camera/libcameraservice/utils/SessionStatsBuilder.h
@@ -84,7 +84,6 @@ private:
     int64_t mErrorResultCount;
     bool mCounterStopped;
     bool mDeviceError;
-    std::string mUserTag;
     // Map from stream id to stream statistics
     std::map<int, StreamStats> mStatsMap;
 };
-- 
2.34.1

