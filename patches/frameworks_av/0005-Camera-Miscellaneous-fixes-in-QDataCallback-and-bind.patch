From d66022576594a1d5c26fa994977566fa3ea8576f Mon Sep 17 00:00:00 2001
From: Mounika Reddy Tangirala <mtangi@codeaurora.org>
Date: Tue, 22 May 2018 17:41:52 +0530
Subject: [PATCH 05/18] Camera: Miscellaneous fixes in QDataCallback and binder
 death scenarios.

This is a squash of following changes:

                      Change-ID                          Subject
   ------------------------------------------------------------------------------
1) I6fc5fa6e01c002bc46be058fcd977be14cae0270    CameraService: Fix deadlock in binder death cleanup
2) I7239f6eb6a9dec67393e11b83d0ef6c986215940    Camera: CameraHardwareInterface: Releasing mHIDLMemoryMapLock in QdataCallback
3) I3fbe4ad836c2abbd512e3728cf49f9424b726ba0	Camera:CameraService: Added lock on mHIDLMemPoolId in QDataCallback

CRs-Fixed: 2246547

CameraService: Fix deadlock in binder death cleanup
Issue:
In the event of a binder death, there is a chance of deadlock
due to recursive lock acquisition in the death handling sequence.
Fix:
Clear evicted client list before acquiring service lock.

Change-Id: I6fc5fa6e01c002bc46be058fcd977be14cae0270

Camera: CameraHardwareInterface: Releasing mHIDLMemoryMapLock in QdataCallback
Issue: Camera is getting stuck due to mHIDLMemoryMapLock when called for
       QDataCallback then  unregister  memory from HAL.
Solution: Releasing mHIDLMemoryMapLock after reading mHIDLMemoryMap variable

Change-Id: I7239f6eb6a9dec67393e11b83d0ef6c986215940

Camera:CameraService: Added lock on mHIDLMemPoolId in QDataCallback..
securing mHIDLMemPoolId (unordered_map variable) from multithreading.

Change-Id: I3fbe4ad836c2abbd512e3728cf49f9424b726ba0
---
 services/camera/libcameraservice/CameraService.cpp  |  3 ++-
 .../device1/CameraHardwareInterface.cpp             | 13 +++++++++----
 2 files changed, 11 insertions(+), 5 deletions(-)

diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
index 954fd7e9ed..4cf74244f1 100644
--- a/services/camera/libcameraservice/CameraService.cpp
+++ b/services/camera/libcameraservice/CameraService.cpp
@@ -2661,7 +2661,8 @@ bool CameraService::evictClientIdByRemote(const wp<IBinder>& remote) {
                 ret = true;
             }
         }
-
+        //clear the evicted client list before acquring service lock again.
+        evicted.clear();
         // Reacquire mServiceLock
         mServiceLock.lock();
 
diff --git a/services/camera/libcameraservice/device1/CameraHardwareInterface.cpp b/services/camera/libcameraservice/device1/CameraHardwareInterface.cpp
index be27ea38e5..a122a4a9b5 100644
--- a/services/camera/libcameraservice/device1/CameraHardwareInterface.cpp
+++ b/services/camera/libcameraservice/device1/CameraHardwareInterface.cpp
@@ -139,14 +139,19 @@ hardware::Return<void> CameraHardwareInterface::dataCallback(
 hardware::Return<void> CameraHardwareInterface::QDataCallback(
         DataCallbackMsg msgType, uint32_t data, uint32_t bufferIndex,
         const vendor::qti::hardware::camera::device::V1_0::QCameraFrameMetadata& metadata) {
-    if (mHidlMemPoolMap.count(data) == 0) {
-        ALOGE("%s: memory pool ID %d not found", __FUNCTION__, data);
-        return hardware::Void();
+    camera_memory_t* mem = nullptr;
+    {
+        std::lock_guard<std::mutex> lock(mHidlMemPoolMapLock);
+        if (mHidlMemPoolMap.count(data) == 0) {
+            ALOGE("%s: memory pool ID %d not found", __FUNCTION__, data);
+            return hardware::Void();
+        }
+        mem = mHidlMemPoolMap.at(data);
     }
     camera_frame_metadata_t md;
     md.number_of_faces = metadata.faces.size();
     md.faces = (camera_face_t*) metadata.faces.data();
-    sDataCb((int32_t) msgType, mHidlMemPoolMap.at(data), bufferIndex, &md, this);
+    sDataCb((int32_t) msgType, mem, bufferIndex, &md, this);
     return hardware::Void();
 }
 
-- 
2.34.1

